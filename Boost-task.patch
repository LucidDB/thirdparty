diff -urN boost/boost/task/as_sub_task.hpp boost-altered/boost/task/as_sub_task.hpp
--- boost/boost/task/as_sub_task.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/as_sub_task.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,61 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_AS_SUB_TASK_H
+#define BOOST_TASK_AS_SUB_TASK_H
+
+#include <boost/bind.hpp>
+#include <boost/config.hpp>
+#include <boost/function.hpp>
+#include <boost/thread/detail/move.hpp>
+
+#include <boost/task/detail/interrupter.hpp>
+#include <boost/task/detail/worker.hpp>
+#include <boost/task/future.hpp>
+#include <boost/task/handle.hpp>
+#include <boost/task/new_thread.hpp>
+#include <boost/task/task.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+struct as_sub_task
+{
+	template< typename R >
+# if defined(BOOST_HAS_RVALUE_REFS)
+	handle< R > operator()( task< R > && t_)
+# else
+	handle< R > operator()( boost::detail::thread_move_t< task< R > > t_)
+# endif
+	{
+		detail::worker * w( detail::worker::tss_get() );
+		if ( w)
+		{
+			task< R > t( t_);
+			shared_future< R > fut( t.get_future() );
+			detail::interrupter intr;
+			function< bool() > wcb(
+				bind(
+					& shared_future< R >::is_ready,
+					fut) );
+			t.set_wait_callback(
+				bind(
+					( void ( detail::worker::*)( function< bool() > const&) ) & detail::worker::reschedule_until,
+					w,
+					wcb) );
+			w->put( detail::pool_callable( boost::move( t), intr) );
+			return handle< R >( fut, intr);
+		}
+		else
+			return new_thread()( t_);
+	}
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_AS_SUB_TASK_H
diff -urN boost/boost/task/async.hpp boost-altered/boost/task/async.hpp
--- boost/boost/task/async.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/async.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,59 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_ASYNC_H
+#define BOOST_TASK_ASYNC_H
+
+#include <boost/config.hpp>
+#include <boost/thread/detail/move.hpp>
+
+#include <boost/task/as_sub_task.hpp>
+#include <boost/task/handle.hpp>
+#include <boost/task/static_pool.hpp>
+#include <boost/task/task.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+# if defined(BOOST_HAS_RVALUE_REFS)
+template< typename R >
+handle< R > async( task< R > && t)
+{ return as_sub_task()( t); }
+
+template< typename R, typename EP >
+handle< R > async( task< R > && t, EP ep)
+{ return ep( t); }
+
+template< typename R, typename Channel >
+handle< R > async( task< R > && t, static_pool< Channel > & pool)
+{ return pool.submit( t); }
+
+template< typename R, typename Channel, typename Attr >
+handle< R > async( task< R > && t, Attr attr, static_pool< Channel > & pool)
+{ return pool.submit( t, attr); }
+# else
+template< typename R >
+handle< R > async( boost::detail::thread_move_t< task< R > > t)
+{ return as_sub_task()( t); }
+
+template< typename R, typename EP >
+handle< R > async( boost::detail::thread_move_t< task< R > > t, EP ep)
+{ return ep( t); }
+
+template< typename R, typename Channel >
+handle< R > async( boost::detail::thread_move_t< task< R > > t, static_pool< Channel > & pool)
+{ return pool.submit( t); }
+
+template< typename R, typename Channel, typename Attr >
+handle< R > async( boost::detail::thread_move_t< task< R > > t, Attr attr, static_pool< Channel > & pool)
+{ return pool.submit( t, attr); }
+# endif
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_ASYNC_H
diff -urN boost/boost/task/bounded_channel.hpp boost-altered/boost/task/bounded_channel.hpp
--- boost/boost/task/bounded_channel.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/bounded_channel.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,395 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_BOUNDED_CHANNEL_H
+#define BOOST_TASK_BOUNDED_CHANNEL_H
+
+#include <cstddef>
+#include <vector>
+
+#include <boost/assert.hpp>
+#include <boost/bind.hpp>
+#include <boost/foreach.hpp>
+#include <boost/function.hpp>
+#include <boost/thread/condition.hpp>
+#include <boost/thread/locks.hpp>
+#include <boost/thread/shared_mutex.hpp>
+
+#include <boost/task/detail/pool_callable.hpp>
+#include <boost/task/exceptions.hpp>
+#include <boost/task/watermark.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+template< typename SchedulingPolicy >
+class bounded_channel
+{
+public:
+	typedef SchedulingPolicy					scheduler_type;
+	typedef typename scheduler_type::impl::item	item;
+
+private:
+	typedef typename scheduler_type::impl	queue;
+
+	enum channel_state
+	{
+		channel_active,
+		channel_deactive,
+		channel_deactive_now
+	};
+
+	channel_state	state_;
+	queue			queue_;
+	shared_mutex	mtx_;
+	condition		not_empty_cond_;
+	condition		not_full_cond_;
+	std::size_t		hwm_;
+	std::size_t		lwm_;
+
+	bool active_() const
+	{ return state_ == channel_active; }
+
+	bool deactive_() const
+	{ return state_ == channel_deactive; }
+
+	bool deactive_now_() const
+	{ return state_ == channel_deactive_now; }
+
+	void activate_()
+	{ state_ = channel_active; }
+
+	void clear_()
+	{
+		BOOST_ASSERT( ! active_() );
+		queue_.clear();
+		BOOST_ASSERT( empty_() );
+	}
+
+	void deactivate_()
+	{
+		if ( active_() )
+		{
+			state_ = channel_deactive;
+			not_empty_cond_.notify_all();
+		}
+
+		BOOST_ASSERT( deactive_() );
+	}
+
+	void deactivate_now_()
+	{
+		if ( active_() )
+		{
+			state_ = channel_deactive_now;
+			not_empty_cond_.notify_all();
+		}
+
+		BOOST_ASSERT( deactive_now_() );
+	}
+
+	const std::vector< detail::pool_callable > drain_()
+	{
+		BOOST_ASSERT( deactive_now_() );
+		std::vector< detail::pool_callable > unprocessed;
+		unprocessed.reserve( queue_.size() );
+		BOOST_FOREACH( detail::pool_callable ca, queue_)
+		{ unprocessed.push_back( ca); }
+		clear_();
+		BOOST_ASSERT( empty_() );
+		return unprocessed;
+	}
+
+	bool empty_() const
+	{ return queue_.empty(); }
+
+	bool full_() const
+	{ return size_() >= hwm_; }
+
+	std::size_t size_() const
+	{ return queue_.size(); }
+
+	void upper_bound_( std::size_t hwm)
+	{
+		if ( lwm_ > hwm )
+			throw invalid_watermark("low watermark must be less than or equal to high watermark");
+		std::size_t tmp( hwm_);
+		hwm_ = hwm;
+		if ( hwm_ > tmp) not_full_cond_.notify_one();
+	}
+
+	void lower_bound_( std::size_t lwm)
+	{
+		if ( lwm > hwm_ )
+			throw invalid_watermark("low watermark must be less than or equal to high watermark");
+		std::size_t tmp( lwm_);
+		lwm_ = lwm;
+		if ( lwm_ > tmp) not_full_cond_.notify_one();
+	}
+
+	void put_(
+		item const& itm,
+		unique_lock< shared_mutex > & lk)
+	{
+		not_full_cond_.wait(
+			lk,
+			bind(
+				& bounded_channel::producers_activate_,
+				this) );
+		if ( ! active_() )
+			throw task_rejected("channel is not active");
+		queue_.push( itm);
+		not_empty_cond_.notify_one();
+	}
+
+	template< typename Duration >
+	void put_(
+		item const& itm,
+		Duration const& rel_time,
+		unique_lock< shared_mutex > & lk)
+	{
+		if ( ! not_full_cond_.timed_wait(
+			lk,
+			rel_time,
+			bind(
+				& bounded_channel::producers_activate_,
+				this) ) )
+			throw task_rejected("timed out");
+		if ( ! active_() )
+			throw task_rejected("channel is not active");
+		queue_.push( itm);
+		not_empty_cond_.notify_one();
+	}
+
+	bool take_(
+		detail::pool_callable & ca,
+		unique_lock< shared_mutex > & lk)
+	{
+		if ( deactive_now_() || ( deactive_() && empty_() ) )
+			return false;
+		try
+		{
+			not_empty_cond_.wait(
+				lk,
+				bind(
+					& bounded_channel::consumers_activate_,
+					this) );
+		}
+		catch ( thread_interrupted const&)
+		{ return false; }
+		if ( deactive_now_() || ( deactive_() && empty_() ) )
+			return false;
+		ca = queue_.pop();
+		if ( size_() <= lwm_)
+		{
+			if ( lwm_ == hwm_)
+				not_full_cond_.notify_one();
+			else
+				// more than one producer could be waiting
+				// for submiting an action object
+				not_full_cond_.notify_all();
+		}
+		return ! ca.empty();
+	}
+
+	template< typename Duration >
+	bool take_(
+		detail::pool_callable & ca,
+		Duration const& rel_time,
+		unique_lock< shared_mutex > & lk)
+	{
+		if ( deactive_now_() || ( deactive_() && empty_() ) )
+			return false;
+		try
+		{
+			if ( ! not_empty_cond_.timed_wait(
+				lk,
+				rel_time,
+				bind(
+					& bounded_channel::consumers_activate_,
+					this) ) )
+				return false;
+		}
+		catch ( thread_interrupted const&)
+		{ return false; }
+		if ( deactive_now_() || ( deactive_() && empty_() ) )
+			return false;
+		ca = queue_.pop();
+		if ( size_() <= lwm_)
+		{
+			if ( lwm_ == hwm_)
+				not_full_cond_.notify_one();
+			else
+				// more than one producer could be waiting
+				// in order to submit an task
+				not_full_cond_.notify_all();
+		}
+		return ! ca.empty();
+	}
+
+	bool try_take_( detail::pool_callable & ca)
+	{
+		if ( deactive_now_() || empty_() )
+			return false;
+		ca = queue_.pop();
+		if ( size_() <= lwm_)
+		{
+			if ( lwm_ == hwm_)
+				not_full_cond_.notify_one();
+			else
+				// more than one producer could be waiting
+				// in order to submit an task
+				not_full_cond_.notify_all();
+		}
+		return ! ca.empty();
+	}
+
+	bool producers_activate_() const
+	{ return ! active_() || ! full_(); }
+
+	bool consumers_activate_() const
+	{ return ! active_() || ! empty_(); }
+
+public:
+	bounded_channel(
+		high_watermark const& hwm,
+		low_watermark const& lwm)
+	:
+	state_( channel_active),
+	queue_(),
+	mtx_(),
+	not_empty_cond_(),
+	not_full_cond_(),
+	hwm_( hwm),
+	lwm_( lwm)
+	{
+		if ( lwm_ > hwm_ )
+			throw invalid_watermark("low watermark must be less than or equal to high watermark");
+	}
+
+	bool active()
+	{
+		shared_lock< shared_mutex > lk( mtx_);
+		return active_();
+	}
+
+	void activate()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		activate_();
+	}
+
+	void clear()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		clear_();
+	}
+
+	bool deactive()
+	{ return ! active(); }
+
+	void deactivate()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		deactivate_();
+	}
+
+	void deactivate_now()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		deactivate_now_();
+	}
+
+	const std::vector< detail::pool_callable > drain()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		return drain_();
+	}
+
+	bool empty()
+	{ 
+		shared_lock< shared_mutex > lk( mtx_);
+		return empty_();
+	}
+
+	bool full()
+	{
+		shared_lock< shared_mutex > lk( mtx_);
+		return full_();
+	}
+
+	std::size_t upper_bound()
+	{
+		shared_lock< shared_mutex > lk( mtx_);
+		return hwm_;
+	}
+
+	void upper_bound( std::size_t hwm)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		upper_bound_( hwm);
+	}
+
+	std::size_t lower_bound()
+	{
+		shared_lock< shared_mutex > lk( mtx_);
+		return lwm_;
+	}
+
+	void lower_bound( std::size_t lwm)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		lower_bound_( lwm);
+	}
+
+	std::size_t size()
+	{ 
+		shared_lock< shared_mutex > lk( mtx_);
+		return size_();
+	}
+
+	void put( item const& itm)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		put_( itm, lk);
+	}
+
+	template< typename Duration >
+	void put(
+		item const& itm,
+		Duration const& rel_time)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		put_( itm, rel_time, lk);
+	}
+
+	bool take( detail::pool_callable & ca)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		return take_( ca, lk);
+	}
+
+	template< typename Duration >
+	bool take(
+		detail::pool_callable & ca,
+		Duration const& rel_time)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		return take_( ca, rel_time, lk);
+	}
+
+	bool try_take( detail::pool_callable & ca)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		return try_take_( ca);
+	}
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_BOUNDED_CHANNEL_H
diff -urN boost/boost/task/detail/atomic_aix.hpp boost-altered/boost/task/detail/atomic_aix.hpp
--- boost/boost/task/detail/atomic_aix.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic_aix.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,46 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_AIX_H
+#define BOOST_TASK_DETAIL_ATOMIC_AIX_H
+
+extern "C"
+{
+#include <sys/atomic_ops.h>
+}
+
+#include <boost/assert.hpp>
+#include <boost/cstdint.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+inline
+void atomic_exchange( uint32_t volatile * object, uint32_t desired)
+{ * object = desired; }
+
+inline
+uint32_t atomic_fetch_add( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return ::fetch_and_add( object, 1);
+}
+
+inline
+uint32_t atomic_fetch_sub( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return ::fetch_and_add( object, -1);
+}
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_AIX_H
+
diff -urN boost/boost/task/detail/atomic_gcc.hpp boost-altered/boost/task/detail/atomic_gcc.hpp
--- boost/boost/task/detail/atomic_gcc.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic_gcc.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,60 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_GCC_H
+#define BOOST_TASK_DETAIL_ATOMIC_GCC_H
+
+// based on boost/smart_ptr/detail/atomic_count_gcc.hpp
+
+# if __GNUC__ * 100 + __GNUC_MINOR__ >= 402
+#include <ext/atomicity.h> 
+# else 
+#include <bits/atomicity.h>
+# endif
+
+#include <boost/assert.hpp>
+#include <boost/cstdint.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+
+#if defined(__GLIBCXX__) // g++ 3.4+
+
+using __gnu_cxx::__atomic_add;
+using __gnu_cxx::__exchange_and_add;
+
+#endif
+
+inline
+void atomic_exchange( uint32_t volatile * object, uint32_t desired)
+{
+  // inline asm xchg for i386 || x86_64?
+  * object = desired;
+}
+
+inline
+uint32_t atomic_fetch_add( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return __exchange_and_add( ( _Atomic_word volatile *) object, 1) + 1;
+}
+
+inline
+uint32_t atomic_fetch_sub( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return __exchange_and_add( ( _Atomic_word volatile *) object, -1) - 1;
+}
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_GCC_H
+
diff -urN boost/boost/task/detail/atomic_gcc_ppc.hpp boost-altered/boost/task/detail/atomic_gcc_ppc.hpp
--- boost/boost/task/detail/atomic_gcc_ppc.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic_gcc_ppc.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,83 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_GCC_PPC_H
+#define BOOST_TASK_DETAIL_ATOMIC_GCC_PPC_H
+
+#include <boost/assert.hpp>
+#include <boost/cstdint.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+inline
+void atomic_exchange( uint32_t volatile * object, uint32_t desired)
+{
+	uint32_t r;
+
+	__asm__ __volatile__
+	(
+		"0:\n\t"
+		"lwarx   %0, 0, %2 \n\t"
+		"stwcx.  %1, 0, %2 \n\t"
+		"bne-     1b" :
+		"=r" ( r) :
+		"r" ( desired), "r" ( object)
+	);
+}
+
+inline
+uint32_t atomic_fetch_add( uint32_t volatile * object, uint32_t operand)
+{
+	int object_ = static_cast< int >( object);
+	int operand_ = static_cast< int >( operand);
+	int r, t;
+
+	__asm__ __volatile__
+	(
+		"0:\n\t"
+		"lwarx  %0,0,%2\n\t"
+		"add    %1,%0,%3\n\t"
+		"stwcx. %1,0,%2\n\t"
+		"bne-   0b"
+		: "=&r" ( r), "=&r" ( t)
+		: "b" ( object_), "r" ( operand_)
+		: "memory", "cc"
+	);
+
+	return ++r;
+}
+
+inline
+uint32_t atomic_fetch_sub( uint32_t volatile * object, uint32_t operand)
+{
+	int object_ = static_cast< int >( object);
+	int operand_ = static_cast< int >( -1 * operand);
+	int r;
+
+	__asm__ __volatile__
+	(
+		"0:\n\t"
+		"lwarx  %0,0,%2\n\t"
+		"add    %1,%0,%3\n\t"
+		"stwcx. %1,0,%2\n\t"
+		"bne-   0b"
+		: "=&r" ( r), "=&r" ( t)
+		: "b" ( object_), "r" ( operand_)
+		: "memory", "cc"
+	);
+
+	return --r;
+}
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_GCC_PPC_H
+
diff -urN boost/boost/task/detail/atomic_gcc_x86.hpp boost-altered/boost/task/detail/atomic_gcc_x86.hpp
--- boost/boost/task/detail/atomic_gcc_x86.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic_gcc_x86.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,69 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_GCC_X86_H
+#define BOOST_TASK_DETAIL_ATOMIC_GCC_X86_H
+
+#include <boost/assert.hpp>
+#include <boost/cstdint.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+inline
+void atomic_exchange( uint32_t volatile * object, uint32_t desired)
+{
+	__asm__ __volatile__
+	(
+		"xchg %0, %1" :
+		"+r" ( desired), "+m" ( * object)
+	);
+}
+
+inline
+long atomic_fetch_add( uint32_t volatile * object, uint32_t operand)
+{
+	int operand_ = static_cast< int >( operand);
+	int r;
+
+	__asm__ __volatile__
+	(
+		"lock\n\t"
+		"xadd %1, %0" :
+		"+m"( * object), "=r"( r):
+		"1"( operand_):
+		"memory", "cc"
+	);
+
+	return ++r;
+}
+
+inline
+long atomic_fetch_sub( uint32_t volatile * object, uint32_t operand)
+{
+	int operand_ = static_cast< int >( -1 * operand);
+	int r;
+
+	__asm__ __volatile__
+	(
+		"lock\n\t"
+		"xadd %1, %0":
+		"+m"( * object), "=r"( r ):
+		"1"( operand_):
+		"memory", "cc"
+	);
+
+	return --r;
+}
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_GCC_X86_H
+
diff -urN boost/boost/task/detail/atomic.hpp boost-altered/boost/task/detail/atomic.hpp
--- boost/boost/task/detail/atomic.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,49 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_H
+#define BOOST_TASK_DETAIL_ATOMIC_H
+
+// MS compatible compilers support #pragma once
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+#include <boost/config.hpp>
+
+#include <boost/task/detail/has_sync.hpp>
+
+# if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#include <boost/task/detail/atomic_interlocked.hpp>
+
+# elif defined( __GNUC__ ) && ( defined( __i386__ ) || defined( __x86_64__ ) )
+#include <boost/task/detail/atomic_gcc_x86.hpp>
+
+# elif defined( __GNUC__ ) && ( defined(__PPC__) || defined(__ppc__) )
+#include <boost/task/detail/atomic_gcc_ppc.hpp>
+
+# elif defined( BOOST_TASK_HAS_SYNC)
+#include <boost/task/detail/atomic_sync.hpp>
+
+# elif defined(__GLIBCPP__) || defined(__GLIBCXX__)
+#include <boost/task/detail/atomic_gcc.hpp>
+
+# elif defined(__IBMCPP__) || defined(_AIX)
+#include <boost/task/detail/atomic_aix.hpp>
+
+# elif defined(__hpux)
+#include <boost/task/detail/atomic_hpux.hpp>
+
+# elif defined(sun) || defined(__sun)
+#include <boost/task/detail/atomic_solaris.hpp>
+
+# else
+#include <boost/task/detail/atomic_interprocess.hpp>
+
+# endif
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_H
+
diff -urN boost/boost/task/detail/atomic_hpux.hpp boost-altered/boost/task/detail/atomic_hpux.hpp
--- boost/boost/task/detail/atomic_hpux.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic_hpux.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,45 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_HPUX_H
+#define BOOST_TASK_DETAIL_ATOMIC_HPUX_H
+
+extern "C"
+{
+#include <atomic.h>
+}
+
+#include <boost/assert.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+inline
+void atomic_exchange( uint32_t volatile * object, uint32_t desired)
+{ * object = desired; }
+
+inline
+uint32_t atomic_fetch_add( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return ::atomic_inc( object);
+}
+
+inline
+uint32_t atomic_fetch_sub( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return ::atomic_dec( object);
+}
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_HPUX_H
+
diff -urN boost/boost/task/detail/atomic_interlocked.hpp boost-altered/boost/task/detail/atomic_interlocked.hpp
--- boost/boost/task/detail/atomic_interlocked.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic_interlocked.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,42 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_INTERLOCKED_H
+#define BOOST_TASK_DETAIL_ATOMIC_INTERLOCKED_H
+
+#include <boost/assert.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/detail/interlocked.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+inline
+void atomic_exchange( uint32_t volatile * object, uint32_t desired)
+{ BOOST_INTERLOCKED_EXCHANGE( reinterpret_cast< long volatile * >( object), desired); }
+
+inline
+uint32_t atomic_fetch_add( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return BOOST_INTERLOCKED_INCREMENT( reinterpret_cast< long volatile * >( object) );
+}
+
+inline
+uint32_t atomic_fetch_sub( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return BOOST_INTERLOCKED_DECREMENT( reinterpret_cast< long volatile * >( object) );
+}
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_INTERLOCKED_H
+
diff -urN boost/boost/task/detail/atomic_interprocess.hpp boost-altered/boost/task/detail/atomic_interprocess.hpp
--- boost/boost/task/detail/atomic_interprocess.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic_interprocess.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,42 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_INTERPROCESS_H
+#define BOOST_TASK_DETAIL_ATOMIC_INTERPROCESS_H
+
+#include <boost/assert.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/interprocess/detail/atomic.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+inline
+void atomic_exchange( volatile uint32_t * object, uint32_t desired)
+{ interprocess::detail::atomic_write32( object, desired); }
+
+inline
+unsigned int atomic_fetch_add( volatile uint32_t * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return interprocess::detail::atomic_inc32( object);
+}
+
+inline
+unsigned int atomic_fetch_sub( volatile uint32_t * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return interprocess::detail::atomic_dec32( object);
+}
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_INTERPROCESS_H
+
diff -urN boost/boost/task/detail/atomic_solaris.hpp boost-altered/boost/task/detail/atomic_solaris.hpp
--- boost/boost/task/detail/atomic_solaris.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic_solaris.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,46 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_SOLARIS_H
+#define BOOST_TASK_DETAIL_ATOMIC_SOLARIS_H
+
+extern "C"
+{
+#include <atomic.h>
+}
+
+#include <boost/assert.hpp>
+#include <boost/cstdint.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+inline
+void atomic_exchange( uint32_t volatile * object, uint32_t desired)
+{ * object = desired; }
+
+inline
+uint32_t atomic_fetch_add( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return ::atomic_inc_32_nv( object);
+}
+
+inline
+uint32_t atomic_fetch_sub( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return ::atomic_dec_32_nv( object);
+}
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_SOLARIS_H
+
diff -urN boost/boost/task/detail/atomic_sync.hpp boost-altered/boost/task/detail/atomic_sync.hpp
--- boost/boost/task/detail/atomic_sync.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/atomic_sync.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,50 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_ATOMIC_SYNC_H
+#define BOOST_TASK_DETAIL_ATOMIC_SYNC_H
+
+// based on boost/smart_ptr/detail/atomic_count_gc.hpp
+
+# if defined( __ia64__ ) && defined( __INTEL_COMPILER )
+extern "C"
+{
+#include<ia64intrin.h>
+}
+# endif
+
+#include <boost/assert.hpp>
+#include <boost/cstdint.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+inline
+void atomic_exchange( uint32_t volatile * object, uint32_t desired)
+{ * object = desired; }
+
+inline
+uint32_t atomic_fetch_add( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return __sync_add_and_fetch( object, 1);
+}
+
+inline
+uint32_t atomic_fetch_sub( uint32_t volatile * object, uint32_t operand)
+{
+	BOOST_ASSERT( operand == 1);
+	return __sync_add_and_fetch( object, -1);
+}
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_ATOMIC_SYNC_H
+
diff -urN boost/boost/task/detail/bind_processor_aix.hpp boost-altered/boost/task/detail/bind_processor_aix.hpp
--- boost/boost/task/detail/bind_processor_aix.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/bind_processor_aix.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,51 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_BIND_PROCESSOR_AIX_H
+#define BOOST_TASK_DETAIL_BIND_PROCESSOR_AIX_H
+
+extern "C"
+{
+#include <sys/processor.h>
+#include <sys/thread.h>
+}
+
+#include <boost/assert.hpp>
+#include <boost/thread.hpp>
+#include <boost/system/system_error.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace this_thread
+{
+	inline
+	void bind_to_processor( unsigned int n)
+	{
+		BOOST_ASSERT( n >= 0);
+		BOOST_ASSERT( n < boost::thread::hardware_concurrency() );
+
+		if ( ::bindprocessor( BINDTHREAD, ::thread_self(), static_cast< cpu_t >( n) ) == -1)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno,
+						boost::system::system_category) );
+	}
+
+	
+	inline
+	void bind_to_any_processor()
+	{
+		if ( ::bindprocessor( BINDTHREAD, ::thread_self(), PROCESSOR_CLASS_ANY) == -1)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno,
+						boost::system::system_category) );
+	}
+}}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_BIND_PROCESSOR_AIX_H
diff -urN boost/boost/task/detail/bind_processor_freebsd.hpp boost-altered/boost/task/detail/bind_processor_freebsd.hpp
--- boost/boost/task/detail/bind_processor_freebsd.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/bind_processor_freebsd.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,61 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_BIND_PROCESSOR_FREEBSD_H
+#define BOOST_TASK_DETAIL_BIND_PROCESSOR_FREEBSD_H
+
+extern "C"
+{
+#include <sys/param.h>
+#include <sys/cpuset.h>
+}
+
+#include <boost/assert.hpp>
+#include <boost/thread.hpp>
+#include <boost/system/system_error.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace this_thread
+{
+	inline
+	void bind_to_processor( unsigned int n)
+	{
+		BOOST_ASSERT( n >= 0);
+		BOOST_ASSERT( n < boost::thread::hardware_concurrency() );
+
+		cpuset_t cpuset;
+		CPU_ZERO( & cpuset);
+		CPU_SET( n, & cpuset);
+
+		if ( ::cpuset_setaffinity(  CPU_LEVEL_WHICH, CPU_WHICH_TID, -1, sizeof( cpuset), & cpuset) == -1)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno,
+						boost::system::system_category) );
+	}
+
+	inline
+	void bind_to_any_processor()
+	{
+		cpuset_t cpuset;
+		CPU_ZERO( & cpuset);
+
+		unsigned int max( boost::thread::hardware_concurrency() );
+		for ( unsigned int i( 0); i < max; ++i)
+			CPU_SET( i, & cpuset);
+
+		if ( ::cpuset_setaffinity(  CPU_LEVEL_WHICH, CPU_WHICH_TID, -1, sizeof( cpuset), & cpuset) == -1)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno,
+						boost::system::system_category) );
+	}
+}}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_BIND_PROCESSOR_FREEBSD_H
diff -urN boost/boost/task/detail/bind_processor.hpp boost-altered/boost/task/detail/bind_processor.hpp
--- boost/boost/task/detail/bind_processor.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/bind_processor.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,37 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_BIND_PROCESSOR_H
+#define BOOST_TASK_DETAIL_BIND_PROCESSOR_H
+
+#include <boost/task/detail/config.hpp>
+
+# if defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
+#   define BOOST_HAS_PROCESSOR_BINDINGS 1
+#   include <boost/task/detail/bind_processor_windows.hpp>
+# elif defined(linux) || defined(__linux) || defined(__linux__)
+#   define BOOST_HAS_PROCESSOR_BINDINGS 1
+#   include <boost/task/detail/bind_processor_linux.hpp>
+# elif defined(__IBMCPP__) || defined(_AIX)
+#   define BOOST_HAS_PROCESSOR_BINDINGS 1
+#   include <boost/task/detail/bind_processor_aix.hpp>
+# elif defined(__hpux)
+#   define BOOST_HAS_PROCESSOR_BINDINGS 1
+#   include <boost/task/detail/bind_processor_hpux.hpp>
+# elif defined(sun) || defined(__sun)
+#   define BOOST_HAS_PROCESSOR_BINDINGS 1
+#   include <boost/task/detail/bind_processor_solaris.hpp>
+# elif defined(__FreeBSD__)
+#include <sys/param.h>
+# if (__FreeBSD_version >= 701000)
+#   define BOOST_HAS_PROCESSOR_BINDINGS 1
+#   include <boost/task/detail/bind_processor_freebsd.hpp>
+# endif
+# else
+#   undef BOOST_HAS_PROCESSOR_BINDINGS
+# endif
+
+#endif // BOOST_TASK_DETAIL_BIND_PROCESSOR_H
diff -urN boost/boost/task/detail/bind_processor_hpux.hpp boost-altered/boost/task/detail/bind_processor_hpux.hpp
--- boost/boost/task/detail/bind_processor_hpux.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/bind_processor_hpux.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,63 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_BIND_PROCESSOR_HPUX_H
+#define BOOST_TASK_DETAIL_BIND_PROCESSOR_HPUX_H
+
+extern "C"
+{
+#include <sys/pthread.h>
+}
+
+#include <boost/assert.hpp>
+#include <boost/thread.hpp>
+#include <boost/system/system_error.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace this_thread
+{
+	inline
+	void bind_to_processor( unsigned int n)
+	{
+		BOOST_ASSERT( n >= 0);
+		BOOST_ASSERT( n < boost::thread::hardware_concurrency() );
+
+		::pthread_spu_t spu;
+		int errno_(
+			::pthread_processor_bind_np(
+				PTHREAD_BIND_FORCED_NP,
+				& spu,
+				static_cast< pthread_spu_t >( n),
+				PTHREAD_SELFTID_NP) );
+		if ( errno_ != 0)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno_,
+						boost::system::system_category) );
+	}
+
+	inline
+	void bind_to_any_processor()
+	{
+		::pthread_spu_t spu;
+		int errno_(
+			::pthread_processor_bind_np(
+				PTHREAD_BIND_FORCED_NP,
+				& spu,
+				PTHREAD_SPUFLOAT_NP,
+				PTHREAD_SELFTID_NP) );
+		if ( errno_ != 0)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno_,
+						boost::system::system_category) );
+	}
+}}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_BIND_PROCESSOR_HPUX_H
diff -urN boost/boost/task/detail/bind_processor_linux.hpp boost-altered/boost/task/detail/bind_processor_linux.hpp
--- boost/boost/task/detail/bind_processor_linux.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/bind_processor_linux.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,64 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_BIND_PRCESSOR_LINUX_H
+#define BOOST_TASK_DETAIL_BIND_PRCESSOR_LINUX_H
+
+extern "C"
+{
+#include <pthread.h>
+#include <sched.h>
+}
+
+#include <boost/assert.hpp>
+#include <boost/thread.hpp>
+#include <boost/system/system_error.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace this_thread
+{
+	inline
+	void bind_to_processor( unsigned int n)
+	{
+		BOOST_ASSERT( n >= 0);
+		BOOST_ASSERT( n < CPU_SETSIZE);
+		BOOST_ASSERT( n < boost::thread::hardware_concurrency() );
+
+		cpu_set_t cpuset;
+		CPU_ZERO( & cpuset);
+		CPU_SET( n, & cpuset);
+	
+		int errno_( ::pthread_setaffinity_np( ::pthread_self(), sizeof( cpuset), & cpuset) );
+		if ( errno_ != 0)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno_,
+						boost::system::system_category) );
+	}
+
+	inline
+	void bind_to_any_processor()
+	{
+		cpu_set_t cpuset;
+		CPU_ZERO( & cpuset);
+
+		unsigned int max( boost::thread::hardware_concurrency() );
+		for ( unsigned int i( 0); i < max; ++i)
+			CPU_SET( i, & cpuset);
+
+		int errno_( ::pthread_setaffinity_np( ::pthread_self(), sizeof( cpuset), & cpuset) );
+		if ( errno_ != 0)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno_,
+						boost::system::system_category) );
+	}
+}}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_BIND_PRCESSOR_LINUX_H
diff -urN boost/boost/task/detail/bind_processor_solaris.hpp boost-altered/boost/task/detail/bind_processor_solaris.hpp
--- boost/boost/task/detail/bind_processor_solaris.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/bind_processor_solaris.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,51 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_BIND_PROCESSOR_SOLARIS_H
+#define BOOST_TASK_DETAIL_BIND_PROCESSOR_SOLARIS_H
+
+extern "C"
+{
+#include <sys/types.h>
+#include <sys/processor.h>
+#include <sys/procset.h>
+}
+
+#include <boost/assert.hpp>
+#include <boost/thread.hpp>
+#include <boost/system/system_error.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace this_thread
+{
+	inline
+	void bind_to_processor( unsigned int n)
+	{
+		BOOST_ASSERT( n >= 0);
+		BOOST_ASSERT( n < boost::thread::hardware_concurrency() );
+
+		if ( ::processor_bind( P_LWPID, P_MYID, static_cast< processorid_t >( n), 0) == -1)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno,
+						boost::system::system_category) );
+	}
+
+	inline
+	void bind_to_any_processor()
+	{
+		if ( ::processor_bind( P_LWPID, P_MYID, PBIND_NONE, 0) == -1)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						errno,
+						boost::system::system_category) );
+	}
+}}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_BIND_PROCESSOR_SOLARIS_H
diff -urN boost/boost/task/detail/bind_processor_windows.hpp boost-altered/boost/task/detail/bind_processor_windows.hpp
--- boost/boost/task/detail/bind_processor_windows.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/bind_processor_windows.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,53 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_BIND_PROCESSOR_WINDOWS_H
+#define BOOST_TASK_DETAIL_BIND_PROCESSOR_WINDOWS_H
+
+extern "C"
+{
+#include <windows.h>
+}
+
+#include <boost/assert.hpp>
+#include <boost/thread.hpp>
+#include <boost/system/system_error.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace this_thread
+{
+	inline
+	void bind_to_processor( unsigned int n)
+	{
+		BOOST_ASSERT( n >= 0);
+		BOOST_ASSERT( n < boost::thread::hardware_concurrency() );
+
+		if ( ::SetThreadAffinityMask( ::GetCurrentThread(), ( DWORD_PTR)1 << n) == 0)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						::GetLastError(),
+						boost::system::system_category) );
+	}
+
+	inline
+	void bind_to_any_processor()
+	{
+		DWORD_PTR ptr( 1);
+		for ( unsigned int i( 0); i < boost::thread::hardware_concurrency(); ++i)
+			ptr = ptr << i;
+
+		if ( ::SetThreadAffinityMask( ::GetCurrentThread(), ptr) == 0)
+			throw boost::system::system_error(
+					boost::system::error_code(
+						::GetLastError(),
+						boost::system::system_category) );
+	}
+}}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_BIND_PROCESSOR_WINDOWS_H
diff -urN boost/boost/task/detail/config.hpp boost-altered/boost/task/detail/config.hpp
--- boost/boost/task/detail/config.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/config.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,90 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+// this file is based on config.hpp of boost.thread
+
+#ifndef BOOST_TASK_DETAIL_CONFIG_H
+#define BOOST_TASK_DETAIL_CONFIG_H
+
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+# if BOOST_WORKAROUND(__BORLANDC__, < 0x600)
+#   pragma warn -8008 // Condition always true/false
+#   pragma warn -8080 // Identifier declared but never used
+#   pragma warn -8057 // Parameter never used
+#   pragma warn -8066 // Unreachable code
+# endif
+
+# if defined(BOOST_ALL_DYN_LINK) || defined(BOOST_TASK_DYN_LINK)
+#   undef  BOOST_TASK_USE_LIB
+#   define BOOST_TASK_USE_DLL
+# endif
+
+# if defined(BOOST_WINDOWS_API) && defined(BOOST_POSIX_API)
+#   error "Both BOOST_WINDOWS_API and BOOST_POSIX_API are defined!"
+# elif ! defined(BOOST_WINDOWS_API ) && ! defined(BOOST_POSIX_API)
+#   if defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__CYGWIN__)
+#     define BOOST_WINDOWS_API
+#   else
+#     define BOOST_POSIX_API
+#   endif
+# endif
+
+# if defined(BOOST_TASK_BUILD_DLL)   //Build dll
+# elif defined(BOOST_TASK_BUILD_LIB) //Build lib
+# elif defined(BOOST_TASK_USE_DLL)   //Use dll
+# elif defined(BOOST_TASK_USE_LIB)   //Use lib
+# else //Use default
+#   if defined(BOOST_TASK_PLATFORM_WIN32)
+#      if defined(BOOST_MSVC) || defined(BOOST_INTEL_WIN)
+            //For compilers supporting auto-tss cleanup
+            //with Boost.Threads lib, use Boost.Threads lib
+#         define BOOST_TASK_USE_LIB
+#      else
+            //For compilers not yet supporting auto-tss cleanup
+            //with Boost.Threads lib, use Boost.Threads dll
+#         define BOOST_TASK_USE_DLL
+#      endif
+#   else
+#      define BOOST_TASK_USE_LIB
+#   endif
+# endif
+
+# if defined(BOOST_HAS_DECLSPEC)
+#   if defined(BOOST_TASK_BUILD_DLL) //Build dll
+#      define BOOST_TASK_DECL __declspec(dllexport)
+#   elif defined(BOOST_TASK_USE_DLL) //Use dll
+#      define BOOST_TASK_DECL __declspec(dllimport)
+#   else
+#      define BOOST_TASK_DECL
+#   endif
+# else
+#   define BOOST_TASK_DECL
+# endif
+
+// Automatically link to the correct build variant where possible.
+# if ! defined(BOOST_ALL_NO_LIB) && ! defined(BOOST_TASK_NO_LIB) && ! defined(BOOST_TASK_BUILD_DLL) && ! defined(BOOST_TASK_BUILD_LIB)
+
+// Tell the autolink to link dynamically, this will get undef'ed by auto_link.hpp
+# if defined(BOOST_TASK_USE_DLL)
+#   define BOOST_DYN_LINK
+# endif
+
+// Set the name of our library, this will get undef'ed by auto_link.hpp
+# if defined(BOOST_TASK_LIB_NAME)
+#   define BOOST_LIB_NAME BOOST_TASK_LIB_NAME
+# else
+#   define BOOST_LIB_NAME boost_task
+# endif
+
+// If we're importing code from a dll, then tell auto_link.hpp about it
+// And include the header that does the work
+#include <boost/config/auto_link.hpp>
+# endif  // auto-linking disabled
+
+#endif // BOOST_TASK_DETAIL_CONFIG_H
+
diff -urN boost/boost/task/detail/guard.hpp boost-altered/boost/task/detail/guard.hpp
--- boost/boost/task/detail/guard.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/guard.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,45 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_GUARD_H
+#define BOOST_TASK_DETAIL_GUARD_H
+
+#include <boost/cstdint.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task/detail/config.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+namespace detail
+{
+class BOOST_TASK_DECL guard : private noncopyable
+{
+private:
+	volatile uint32_t	&	active_worker_;
+
+public:
+	guard( volatile uint32_t & active_worker);
+
+	~guard();
+};
+} } }
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_GUARD_H
+
diff -urN boost/boost/task/detail/has_sync.hpp boost-altered/boost/task/detail/has_sync.hpp
--- boost/boost/task/detail/has_sync.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/has_sync.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,49 @@
+#ifndef BOOST_TASK_DETAIL_HAS_SYNC_H
+#define BOOST_TASK_DETAIL_HAS_SYNC_H
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+// based on boost/smart_ptr/detail/sp_has_sync.hpp
+//
+//  Copyright (c) 2008, 2009 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  Defines the BOOST_SP_HAS_SYNC macro if the __sync_* intrinsics
+//  are available.
+//
+
+#if defined(__GNUC__) && ( __GNUC__ * 100 + __GNUC_MINOR__ >= 401 )
+
+#define BOOST_TASK_HAS_SYNC
+
+#if defined( __arm__ )  || defined( __armel__ )
+#undef BOOST_TASK_HAS_SYNC
+#endif
+
+#if defined( __hppa ) || defined( __hppa__ )
+#undef BOOST_TASK_HAS_SYNC
+#endif
+
+#if defined( __m68k__ )
+#undef BOOST_TASK_HAS_SYNC
+#endif
+
+#if defined( __sparc__ )
+#undef BOOST_TASK_HAS_SYNC
+#endif
+
+#if defined( __INTEL_COMPILER ) && !defined( __ia64__ )
+#undef BOOST_TASK_HAS_SYNC
+#endif
+
+#endif // __GNUC__ * 100 + __GNUC_MINOR__ >= 401
+
+#endif // BOOST_TASK_DETAIL_HAS_SYNC_H
diff -urN boost/boost/task/detail/interrupter.hpp boost-altered/boost/task/detail/interrupter.hpp
--- boost/boost/task/detail/interrupter.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/interrupter.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,81 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_INTERRUPTER_H
+#define BOOST_TASK_DETAIL_INTERRUPTER_H
+
+#include <boost/shared_ptr.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/mutex.hpp>
+#include <boost/thread/locks.hpp>
+#include <boost/thread/mutex.hpp>
+#include <boost/thread/thread_time.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task/detail/config.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+namespace detail
+{
+class BOOST_TASK_DECL interrupter
+{
+private:
+	class impl : private noncopyable
+	{
+	private:
+		bool					interruption_requested_;
+		mutex					mtx_;
+		shared_ptr< thread >	thrd_;
+
+		void interrupt_();
+
+	public:
+		impl();
+
+		~impl();
+
+		void set( shared_ptr< thread > const& thrd);
+
+		void reset();
+
+		void interrupt();
+
+		bool interruption_requested();
+	};
+
+	shared_ptr< impl >	impl_;
+
+public:
+	interrupter();
+
+	void set( shared_ptr< thread > const& thrd);
+
+	void reset();
+
+	void interrupt();
+
+	bool interruption_requested();
+
+	void swap( interrupter & other)
+	{ impl_.swap( other.impl_); }
+};
+}}}
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_INTERRUPTER_H
diff -urN boost/boost/task/detail/meta.hpp boost-altered/boost/task/detail/meta.hpp
--- boost/boost/task/detail/meta.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/meta.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,26 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_INFO_H
+#define BOOST_TASK_DETAIL_INFO_H
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+struct has_attribute
+{};
+
+struct has_no_attribute
+{};
+} } }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_INFO_H
+
diff -urN boost/boost/task/detail/move.hpp boost-altered/boost/task/detail/move.hpp
--- boost/boost/task/detail/move.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/move.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,52 @@
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+// (C) Copyright 2007-8 Anthony Williams
+
+#ifndef BOOST_TASK_MOVE_HPP
+#define BOOST_TASK_MOVE_HPP
+
+#ifndef BOOST_NO_SFINAE
+#include <boost/utility/enable_if.hpp>
+#include <boost/type_traits/is_convertible.hpp>
+#endif
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost
+{
+	namespace detail
+	{
+		template< typename T >
+		struct task_move_t
+		{
+			T	&	t;
+			explicit task_move_t( T & t_)
+			: t( t_)
+			{}
+
+			T & operator*() const
+			{ return t; }
+
+			T* operator->() const
+			{ return &  t; }
+
+		private:
+			void operator=( task_move_t &);
+		};
+	}
+
+#ifndef BOOST_NO_SFINAE
+	template< typename T >
+	typename enable_if< boost::is_convertible< T &, detail::task_move_t< T > >, T >::type move( T & t)
+	{ return T( detail::task_move_t< T >( t) ); }
+#endif
+
+	template< typename T >
+	detail::task_move_t< T > move( detail::task_move_t< T > t)
+	{ return t; }
+}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_MOVE_HPP
diff -urN boost/boost/task/detail/pool_callable.hpp boost-altered/boost/task/detail/pool_callable.hpp
--- boost/boost/task/detail/pool_callable.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/pool_callable.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,122 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_POOL_CALLABLE_H
+#define BOOST_TASK_DETAIL_POOL_CALLABLE_H
+
+#include <boost/config.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/thread.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task/detail/config.hpp>
+#include <boost/task/detail/interrupter.hpp>
+#include <boost/task/task.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+namespace detail
+{
+class BOOST_TASK_DECL pool_callable
+{
+private:
+	friend class scoped_guard;
+
+	struct impl
+	{
+		virtual ~impl() {}
+		virtual void run() = 0;
+		virtual void set( shared_ptr< thread > &) = 0;
+		virtual void reset() = 0;
+	};
+
+	template< typename R >
+	class impl_wrapper : public impl
+	{
+	private:
+		task< R >		t_;
+		detail::interrupter	i_;
+
+	public:
+# if defined(BOOST_HAS_RVALUE_REFS)
+		impl_wrapper(
+			task< R > && t,
+			detail::interrupter const& i)
+		: t_( t), i_( i)
+		{}
+# else
+		impl_wrapper(
+			boost::detail::thread_move_t< task< R > > t,
+			detail::interrupter const& i)
+		: t_( t), i_( i)
+		{}
+# endif
+
+		void run()
+		{ t_(); }
+
+		void set( shared_ptr< thread > & thrd)
+		{ i_.set( thrd); }
+
+		void reset()
+		{ i_.reset(); }
+	};
+
+	shared_ptr< impl >	impl_;
+
+public:
+	class scoped_guard : public noncopyable
+	{
+	private:
+		pool_callable	&	ca_;
+	
+	public:
+		scoped_guard( pool_callable &, shared_ptr< thread > &);
+	
+		~scoped_guard();
+	};
+
+	pool_callable();
+
+# if defined(BOOST_HAS_RVALUE_REFS)
+	template< typename R >
+	pool_callable(
+		task< R > && t,
+		detail::interrupter const& i)
+	: impl_( new impl_wrapper<  R >( t, i) )
+	{}
+# else
+	template< typename R >
+	pool_callable(
+		boost::detail::thread_move_t< task< R > > t,
+		detail::interrupter const& i)
+	: impl_( new impl_wrapper<  R >( t, i) )
+	{}
+# endif
+
+	void operator()();
+
+	bool empty() const;
+
+	void clear();
+};
+}}}
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_POOL_CALLABLE_H
+
diff -urN boost/boost/task/detail/worker_group.hpp boost-altered/boost/task/detail/worker_group.hpp
--- boost/boost/task/detail/worker_group.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/worker_group.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,99 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_WORKER_GROUP_H
+#define BOOST_TASK_DETAIL_WORKER_GROUP_H
+
+#include <cstddef>
+
+#include <boost/multi_index_container.hpp>
+#include <boost/multi_index/mem_fun.hpp>
+#include <boost/multi_index/ordered_index.hpp>
+#include <boost/multi_index/random_access_index.hpp>
+#include <boost/thread.hpp>
+
+#include <boost/task/detail/config.hpp>
+#include <boost/task/detail/worker.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+namespace detail
+{
+class BOOST_TASK_DECL worker_group
+{
+private:
+	struct id_idx_tag {};
+	struct rnd_idx_tag {};
+
+	typedef multi_index::multi_index_container<
+		worker,
+		multi_index::indexed_by<
+			multi_index::ordered_unique<
+				multi_index::tag< id_idx_tag >,
+				multi_index::const_mem_fun<
+					worker,
+					const thread::id,
+					& worker::get_id
+				>
+			>,
+			multi_index::random_access< multi_index::tag< rnd_idx_tag > >
+		>
+	>				container;
+
+	typedef container::index< id_idx_tag >::type		id_idx;
+	typedef container::index< rnd_idx_tag >::type		rnd_idx;
+
+	container		cont_;
+	id_idx		&	id_idx_;
+	rnd_idx		&	rnd_idx_;
+
+public:
+	typedef id_idx::iterator		iterator;
+	typedef id_idx::const_iterator	const_iterator;
+
+	worker_group();
+
+	const worker operator[]( std::size_t pos) const;
+
+	std::size_t size() const;
+
+	const iterator begin();
+
+	const const_iterator begin() const;
+
+	const iterator end();
+
+	const const_iterator end() const;
+
+	const const_iterator find( thread::id const& id) const;
+
+	void join_all();
+
+	void interrupt_all();
+
+	void insert( worker const& w);
+
+	void signal_shutdown_all();
+
+	void signal_shutdown_now_all();
+};
+} } }
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_WORKER_GROUP_H
+
diff -urN boost/boost/task/detail/worker.hpp boost-altered/boost/task/detail/worker.hpp
--- boost/boost/task/detail/worker.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/worker.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,336 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_WORKER_H
+#define BOOST_TASK_DETAIL_WORKER_H
+
+#include <cstddef>
+#include <utility>
+
+#include <boost/assert.hpp>
+#include <boost/function.hpp>
+#include <boost/random.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/thread.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task/detail/config.hpp>
+#include <boost/task/detail/pool_callable.hpp>
+#include <boost/task/detail/guard.hpp>
+#include <boost/task/detail/interrupter.hpp>
+#include <boost/task/detail/wsq.hpp>
+#include <boost/task/poolsize.hpp>
+#include <boost/task/scanns.hpp>
+#include <boost/task/semaphore.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+namespace detail
+{
+class BOOST_TASK_DECL worker
+{
+private:
+	static thread_specific_ptr< worker >	tss_;
+
+	struct impl
+	{
+		virtual ~impl() {}
+
+		virtual const thread::id get_id() const = 0;
+
+		virtual void join() const = 0;
+
+		virtual void interrupt() const = 0;
+
+		virtual void put( pool_callable const&) = 0;
+
+		virtual bool try_take( pool_callable &) = 0;
+
+		virtual bool try_steal( pool_callable &) = 0;
+
+		virtual void signal_shutdown() = 0;
+
+		virtual void signal_shutdown_now() = 0;
+
+		virtual void reschedule_until( function< bool() > const&) = 0;
+
+		virtual void run() = 0;
+	};
+
+	template< typename Pool >
+	class impl_pool : public impl,
+					  private noncopyable
+	{
+	private:
+		class random_idx
+		{
+		private:
+			rand48 rng_;
+			uniform_int<> six_;
+			variate_generator< rand48 &, uniform_int<> > die_;
+	
+		public:
+			random_idx( std::size_t size)
+			:
+			rng_(),
+			six_( 0, size - 1),
+			die_( rng_, six_)
+			{}
+	
+			std::size_t operator()()
+			{ return die_(); }
+		};
+
+		Pool					&	pool_;
+		shared_ptr< thread >		thrd_;
+		wsq				 			wsq_;
+		semaphore					shtdwn_sem_;
+		semaphore					shtdwn_now_sem_;
+		bool						shtdwn_;
+		posix_time::time_duration	asleep_;
+		scanns						max_scns_;
+		std::size_t					scns_;
+		random_idx					rnd_idx_;
+
+		void execute_( pool_callable & ca)
+		{
+			BOOST_ASSERT( ! ca.empty() );
+			guard grd( get_pool().active_worker_);
+			{
+				pool_callable::scoped_guard lk( ca, thrd_);
+				ca();
+			}
+			ca.clear();
+			BOOST_ASSERT( ca.empty() );
+		}
+	
+		void next_pool_callable_( pool_callable & ca)
+		{
+			if ( ! try_take( ca) )
+			{
+				if ( ! get_pool().channel_.try_take( ca) )
+				{
+					std::size_t idx( rnd_idx_() );
+					for ( std::size_t j( 0); j < get_pool().wg_.size(); ++j)
+					{
+						worker other( get_pool().wg_[idx]);
+						if ( this_thread::get_id() == other.get_id() ) continue;
+						if ( ++idx >= get_pool().wg_.size() ) idx = 0;
+						if ( other.try_steal( ca) ) break;
+					}
+	
+					if ( ca.empty() )
+					{
+						guard grd( get_pool().idle_worker_);
+						if ( shutdown_() ) return;
+						++scns_;
+						if ( scns_ >= max_scns_)
+						{
+							if ( get_pool().size_() == get_pool().idle_worker_)
+								get_pool().channel_.take( ca, asleep_);
+							else
+								this_thread::sleep( asleep_);
+							scns_ = 0;
+						}
+						else
+							this_thread::yield();
+					}
+				}
+			}
+		}
+	
+		void next_local_pool_callable_( pool_callable & ca)
+		{
+			if ( ! try_take( ca) )
+			{
+				guard grd( get_pool().idle_worker_);
+				if ( shutdown_() ) return;
+				++scns_;
+				if ( scns_ >= max_scns_)
+				{
+					this_thread::sleep( asleep_);
+					scns_ = 0;
+				}
+				else
+					this_thread::yield();
+			}
+		}
+
+		bool shutdown_()
+		{
+			if ( shutdown__() && get_pool().channel_.empty() )
+				return true;
+			else if ( shutdown_now__() )
+				return true;
+			return false;
+		}
+
+		bool shutdown__()
+		{
+			if ( ! shtdwn_)
+				shtdwn_ = shtdwn_sem_.try_wait();
+			return shtdwn_;
+		}
+		
+		bool shutdown_now__()
+		{ return shtdwn_now_sem_.try_wait(); }
+
+	public:
+		impl_pool(
+			Pool & pool,
+			poolsize const& psize,
+			posix_time::time_duration const& asleep,
+			scanns const& max_scns,
+			function< void() > const& fn)
+		:
+		pool_( pool),
+		thrd_( new thread( fn) ),
+		wsq_(),
+		shtdwn_sem_( 0),
+		shtdwn_now_sem_( 0),
+		shtdwn_( false),
+		asleep_( asleep),
+		max_scns_( max_scns),
+		scns_( 0),
+		rnd_idx_( psize)
+		{ BOOST_ASSERT( ! fn.empty() ); }
+
+		const thread::id get_id() const
+		{ return thrd_->get_id(); }
+
+		void join() const
+		{ thrd_->join(); }
+
+		void
+		interrupt() const
+		{ thrd_->interrupt(); }
+
+		void signal_shutdown()
+		{ shtdwn_sem_.post(); }
+		
+		void signal_shutdown_now()
+		{ shtdwn_now_sem_.post(); }
+
+		void put( pool_callable const& ca)
+		{
+			BOOST_ASSERT( ! ca.empty() );
+			wsq_.put( ca);
+		}
+
+		bool try_take( pool_callable & ca)
+		{
+			pool_callable tmp;
+			bool result( wsq_.try_take( tmp) );
+			if ( result)
+				ca = tmp;
+			return result;
+		}
+		
+		bool try_steal( pool_callable & ca)
+		{
+			pool_callable tmp;
+			bool result( wsq_.try_steal( tmp) );
+			if ( result)
+				ca = tmp;
+			return result;
+		}
+
+		Pool & get_pool() const
+		{ return pool_; }
+
+		void run()
+		{
+			BOOST_ASSERT( get_id() == this_thread::get_id() );
+
+			pool_callable ca;
+			while ( ! shutdown_() )
+			{
+				next_pool_callable_( ca);
+				if( ! ca.empty() )
+				{
+					execute_( ca);
+					scns_ = 0;
+				}
+			}
+		}
+
+		void reschedule_until( function< bool() > const& pred)
+		{
+			pool_callable ca;
+			while ( ! pred() )
+			{
+				next_local_pool_callable_( ca);
+				if( ! ca.empty() )
+				{
+					execute_( ca);
+					scns_ = 0;
+				}
+			}
+		}
+	};
+
+	shared_ptr< impl >	impl_;
+
+public:
+	template< typename Pool >
+	worker(
+		Pool & pool,
+		poolsize const& psize,
+		posix_time::time_duration const& asleep,
+		scanns const& max_scns,
+		function< void() > const& fn)
+	:
+	impl_(
+		new impl_pool< Pool >(
+			pool,
+			psize,
+			asleep,
+			max_scns,
+			fn) )
+	{}
+
+	const thread::id get_id() const;
+
+	void join() const;
+	void interrupt() const;
+	void signal_shutdown();
+	void signal_shutdown_now();
+
+	void put( pool_callable const&);
+	bool try_take( pool_callable &);
+	bool try_steal( pool_callable &);
+
+	void reschedule_until( function< bool() > const&);
+
+	template< typename Pool >
+	Pool & get_pool() const
+	{
+		impl_pool< Pool > * p( dynamic_cast< impl_pool< Pool > * >( impl_.get() ) );
+		BOOST_ASSERT( p);
+		return p->get_pool();
+	}
+
+	void run();
+
+	static worker * tss_get();
+};
+}}}
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_WORKER_H
+
diff -urN boost/boost/task/detail/wsq.hpp boost-altered/boost/task/detail/wsq.hpp
--- boost/boost/task/detail/wsq.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/detail/wsq.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,62 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_DETAIL_WSQ_H
+#define BOOST_TASK_DETAIL_WSQ_H
+
+#include <boost/cstdint.hpp>
+#include <boost/shared_array.hpp>
+#include <boost/thread/mutex.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task/detail/config.hpp>
+#include <boost/task/detail/pool_callable.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+namespace detail
+{
+class BOOST_TASK_DECL wsq : private noncopyable
+{
+private:
+	const int						initial_size_;
+	shared_array< pool_callable >	array_;
+	int								capacity_;
+	int								mask_;
+	volatile uint32_t				head_idx_;
+	volatile uint32_t				tail_idx_;
+	recursive_mutex					mtx_;
+
+public:
+	wsq();
+
+	bool empty() const;
+
+	std::size_t size() const;
+
+	void put( pool_callable const&);
+
+	bool try_take( pool_callable &);
+
+	bool try_steal( pool_callable &);
+};
+}}}
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_DETAIL_WSQ_H
+
diff -urN boost/boost/task/exceptions.hpp boost-altered/boost/task/exceptions.hpp
--- boost/boost/task/exceptions.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/exceptions.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,103 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_EXCEPTIONS_H
+#define BOOST_TASK_EXCEPTIONS_H
+
+#include <stdexcept>
+#include <string>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+class invalid_poolsize : public std::invalid_argument
+{
+public:
+    invalid_poolsize()
+	: std::invalid_argument("core poolsize must be greater than zero")
+	{}
+};
+
+class invalid_scanns : public std::invalid_argument
+{
+public:
+    invalid_scanns()
+	: std::invalid_argument("scanns must be greater than or equal to zero")
+	{}
+};
+
+class invalid_timeduration : public std::invalid_argument
+{
+public:
+    invalid_timeduration()
+	: std::invalid_argument("argument asleep is not valid")
+	{}
+};
+
+class invalid_watermark : public std::invalid_argument
+{
+public:
+    invalid_watermark( std::string const& msg)
+	: std::invalid_argument( msg)
+	{}
+};
+
+class task_uninitialized : public std::logic_error
+{
+public:
+    task_uninitialized()
+	: std::logic_error("task uninitialized")
+	{}
+};
+
+class task_already_executed : public std::logic_error
+{
+public:
+    task_already_executed()
+	: std::logic_error("task already executed")
+	{}
+};
+
+class task_moved : public std::logic_error
+{
+public:
+    task_moved()
+	: std::logic_error("task moved")
+	{}
+};
+
+class broken_task : public std::logic_error
+{
+public:
+    broken_task()
+	: std::logic_error("broken task")
+	{}
+};
+
+struct task_interrupted
+{};
+
+class task_rejected : public std::runtime_error
+{
+public:
+    task_rejected( std::string const& msg)
+	: std::runtime_error( msg)
+	{}
+};
+
+class pool_moved : public std::logic_error
+{
+public:
+    pool_moved()
+	: std::logic_error("pool moved")
+	{}
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_EXCEPTIONS_H
diff -urN boost/boost/task/fifo.hpp boost-altered/boost/task/fifo.hpp
--- boost/boost/task/fifo.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/fifo.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,71 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_FIFO_H
+#define BOOST_TASK_FIFO_H
+
+#include <cstddef>
+#include <list>
+
+#include <boost/task/detail/pool_callable.hpp>
+#include <boost/task/detail/meta.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+struct fifo
+{
+	typedef detail::has_no_attribute	attribute_tag_type;
+
+	class impl
+	{
+	public:
+		typedef detail::pool_callable					item;
+		typedef std::list< item >::iterator			iterator;
+		typedef std::list< item >::const_iterator	const_iterator;
+	
+	private:
+		std::list< item >	lst_;
+	
+	public:
+		void push( item const& itm)
+		{ lst_.push_back( itm); }
+	
+		const item pop()
+		{
+			item itm( lst_.front() );
+			lst_.pop_front();
+			return itm;
+		}
+	
+		std::size_t size() const
+		{ return lst_.size(); }
+	
+		bool empty() const
+		{ return lst_.empty(); }
+	
+		void clear()
+		{ lst_.clear(); }
+	
+		const iterator begin()
+		{ return lst_.begin(); }
+	
+		const const_iterator begin() const
+		{ return lst_.begin(); }
+	
+		const iterator end()
+		{ return lst_.end(); }
+	
+		const const_iterator end() const
+		{ return lst_.end(); }
+	};
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_FIFO_H
diff -urN boost/boost/task/future.hpp boost-altered/boost/task/future.hpp
--- boost/boost/task/future.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/future.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,1363 @@
+//  (C) Copyright 2008 Anthony Williams 
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_FUTURE_HPP
+#define BOOST_FUTURE_HPP
+#include <stdexcept>
+#include <boost/exception.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/detail/move.hpp>
+#include <boost/thread/thread_time.hpp>
+#include <boost/exception_ptr.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/scoped_ptr.hpp>
+#include <boost/type_traits/is_fundamental.hpp>
+#include <boost/type_traits/is_convertible.hpp>
+#include <boost/mpl/if.hpp>
+#include <boost/config.hpp>
+#include <algorithm>
+#include <boost/function.hpp>
+#include <boost/bind.hpp>
+#include <boost/ref.hpp>
+#include <boost/scoped_array.hpp>
+#include <boost/utility/enable_if.hpp>
+#include <list>
+#include <boost/next_prior.hpp>
+
+namespace boost
+{
+    class future_uninitialized:
+        public std::logic_error
+    {
+    public:
+        future_uninitialized():
+            std::logic_error("Future Uninitialized")
+        {}
+    };
+    class broken_promise:
+        public std::logic_error
+    {
+    public:
+        broken_promise():
+            std::logic_error("Broken promise")
+        {}
+    };
+    class future_already_retrieved:
+        public std::logic_error
+    {
+    public:
+        future_already_retrieved():
+            std::logic_error("Future already retrieved")
+        {}
+    };
+    class promise_already_satisfied:
+        public std::logic_error
+    {
+    public:
+        promise_already_satisfied():
+            std::logic_error("Promise already satisfied")
+        {}
+    };
+
+    class task_already_started:
+        public std::logic_error
+    {
+    public:
+        task_already_started():
+            std::logic_error("Task already started")
+        {}
+    };
+
+    class task_moved:
+        public std::logic_error
+    {
+    public:
+        task_moved():
+            std::logic_error("Task moved")
+        {}
+    };
+
+    namespace future_state
+    {
+        enum state { uninitialized, waiting, ready, moved };
+    }
+
+    namespace detail
+    {
+        struct future_object_base
+        {
+            boost::exception_ptr exception;
+            bool done;
+            boost::mutex mutex;
+            boost::condition_variable waiters;
+            typedef std::list<boost::condition_variable_any*> waiter_list;
+            waiter_list external_waiters;
+            boost::function<void()> callback;
+
+            future_object_base():
+                done(false)
+            {}
+            virtual ~future_object_base()
+            {}
+
+            waiter_list::iterator register_external_waiter(boost::condition_variable_any& cv)
+            {
+                boost::unique_lock<boost::mutex> lock(mutex);
+                do_callback(lock);
+                return external_waiters.insert(external_waiters.end(),&cv);
+            }
+            
+            void remove_external_waiter(waiter_list::iterator it)
+            {
+                boost::lock_guard<boost::mutex> lock(mutex);
+                external_waiters.erase(it);
+            }
+
+            void mark_finished_internal()
+            {
+                done=true;
+                waiters.notify_all();
+                for(waiter_list::const_iterator it=external_waiters.begin(),
+                        end=external_waiters.end();it!=end;++it)
+                {
+                    (*it)->notify_all();
+                }
+            }
+
+            struct relocker
+            {
+                boost::unique_lock<boost::mutex>& lock;
+                
+                relocker(boost::unique_lock<boost::mutex>& lock_):
+                    lock(lock_)
+                {
+                    lock.unlock();
+                }
+                ~relocker()
+                {
+                    lock.lock();
+                }
+            };
+
+            void do_callback(boost::unique_lock<boost::mutex>& lock)
+            {
+                if(callback && !done)
+                {
+                    boost::function<void()> local_callback=callback;
+                    relocker relock(lock);
+                    local_callback();
+                }
+            }
+            
+
+            void wait(bool rethrow=true)
+            {
+                boost::unique_lock<boost::mutex> lock(mutex);
+                do_callback(lock);
+                while(!done)
+                {
+                    waiters.wait(lock);
+                }
+                if(rethrow && exception)
+                {
+                    boost::rethrow_exception(exception);
+                }
+            }
+
+            bool timed_wait_until(boost::system_time const& target_time)
+            {
+                boost::unique_lock<boost::mutex> lock(mutex);
+                do_callback(lock);
+                while(!done)
+                {
+                    bool const success=waiters.timed_wait(lock,target_time);
+                    if(!success && !done)
+                    {
+                        return false;
+                    }
+                }
+                return true;
+            }
+            
+            void mark_exceptional_finish_internal(boost::exception_ptr const& e)
+            {
+                exception=e;
+                mark_finished_internal();
+            }
+            void mark_exceptional_finish()
+            {
+                boost::lock_guard<boost::mutex> lock(mutex);
+                mark_exceptional_finish_internal(boost::current_exception());
+            }
+
+            bool has_value()
+            {
+                boost::lock_guard<boost::mutex> lock(mutex);
+                return done && !exception;
+            }
+            bool has_exception()
+            {
+                boost::lock_guard<boost::mutex> lock(mutex);
+                return done && exception;
+            }
+
+            template<typename F,typename U>
+            void set_wait_callback(F f,U* u)
+            {
+                callback=boost::bind(f,boost::ref(*u));
+            }
+            
+        private:
+            future_object_base(future_object_base const&);
+            future_object_base& operator=(future_object_base const&);
+        };
+
+        template<typename T>
+        struct future_traits
+        {
+            typedef boost::scoped_ptr<T> storage_type;
+#ifdef BOOST_HAS_RVALUE_REFS
+            typedef T const& source_reference_type;
+            struct dummy;
+            typedef typename boost::mpl::if_<boost::is_fundamental<T>,dummy&,T&&>::type rvalue_source_type;
+            typedef typename boost::mpl::if_<boost::is_fundamental<T>,T,T&&>::type move_dest_type;
+#else
+            typedef T& source_reference_type;
+            typedef typename boost::mpl::if_<boost::is_convertible<T&,boost::detail::thread_move_t<T> >,boost::detail::thread_move_t<T>,T const&>::type rvalue_source_type;
+            typedef typename boost::mpl::if_<boost::is_convertible<T&,boost::detail::thread_move_t<T> >,boost::detail::thread_move_t<T>,T>::type move_dest_type;
+#endif
+
+            static void init(storage_type& storage,source_reference_type t)
+            {
+                storage.reset(new T(t));
+            }
+            
+            static void init(storage_type& storage,rvalue_source_type t)
+            {
+                storage.reset(new T(static_cast<rvalue_source_type>(t)));
+            }
+
+            static void cleanup(storage_type& storage)
+            {
+                storage.reset();
+            }
+        };
+        
+        template<typename T>
+        struct future_traits<T&>
+        {
+            typedef T* storage_type;
+            typedef T& source_reference_type;
+            struct rvalue_source_type
+            {};
+            typedef T& move_dest_type;
+
+            static void init(storage_type& storage,T& t)
+            {
+                storage=&t;
+            }
+
+            static void cleanup(storage_type& storage)
+            {
+                storage=0;
+            }
+        };
+
+        template<>
+        struct future_traits<void>
+        {
+            typedef bool storage_type;
+            typedef void move_dest_type;
+
+            static void init(storage_type& storage)
+            {
+                storage=true;
+            }
+
+            static void cleanup(storage_type& storage)
+            {
+                storage=false;
+            }
+
+        };
+
+        template<typename T>
+        struct future_object:
+            detail::future_object_base
+        {
+            typedef typename future_traits<T>::storage_type storage_type;
+            typedef typename future_traits<T>::source_reference_type source_reference_type;
+            typedef typename future_traits<T>::rvalue_source_type rvalue_source_type;
+            typedef typename future_traits<T>::move_dest_type move_dest_type;
+            
+            storage_type result;
+
+            future_object():
+                result(0)
+            {}
+
+            void mark_finished_with_result_internal(source_reference_type result_)
+            {
+                future_traits<T>::init(result,result_);
+                mark_finished_internal();
+            }
+            void mark_finished_with_result_internal(rvalue_source_type result_)
+            {
+                future_traits<T>::init(result,static_cast<rvalue_source_type>(result_));
+                mark_finished_internal();
+            }
+
+            void mark_finished_with_result(source_reference_type result_)
+            {
+                boost::lock_guard<boost::mutex> lock(mutex);
+                mark_finished_with_result_internal(result_);
+            }
+            void mark_finished_with_result(rvalue_source_type result_)
+            {
+                boost::lock_guard<boost::mutex> lock(mutex);
+                mark_finished_with_result_internal(result_);
+            }
+
+            move_dest_type get()
+            {
+                wait();
+                return *result;
+            }
+
+            future_state::state get_state()
+            {
+                boost::lock_guard<boost::mutex> guard(mutex);
+                if(!done)
+                {
+                    return future_state::waiting;
+                }
+                else
+                {
+                    return future_state::ready;
+                }
+            }
+
+        private:
+            future_object(future_object const&);
+            future_object& operator=(future_object const&);
+        };
+
+        template<>
+        struct future_object<void>:
+            detail::future_object_base
+        {
+            future_object()
+            {}
+
+            void mark_finished_with_result_internal()
+            {
+                mark_finished_internal();
+            }
+
+            void mark_finished_with_result()
+            {
+                boost::lock_guard<boost::mutex> lock(mutex);
+                mark_finished_with_result_internal();
+            }
+
+            void get()
+            {
+                wait();
+            }
+            
+            future_state::state get_state()
+            {
+                boost::lock_guard<boost::mutex> guard(mutex);
+                if(!done)
+                {
+                    return future_state::waiting;
+                }
+                else
+                {
+                    return future_state::ready;
+                }
+            }
+
+        private:
+            future_object(future_object const&);
+            future_object& operator=(future_object const&);
+        };
+
+        class future_waiter
+        {
+            struct registered_waiter
+            {
+                boost::shared_ptr<detail::future_object_base> future;
+                detail::future_object_base::waiter_list::iterator wait_iterator;
+                unsigned index;
+
+                registered_waiter(boost::shared_ptr<detail::future_object_base> const& future_,
+                                  detail::future_object_base::waiter_list::iterator wait_iterator_,
+                                  unsigned index_):
+                    future(future_),wait_iterator(wait_iterator_),index(index_)
+                {}
+
+            };
+            
+            struct all_futures_lock
+            {
+                unsigned count;
+                boost::scoped_array<boost::unique_lock<boost::mutex> > locks;
+                
+                all_futures_lock(std::vector<registered_waiter>& futures):
+                    count(futures.size()),locks(new boost::unique_lock<boost::mutex>[count])
+                {
+                    for(unsigned i=0;i<count;++i)
+                    {
+                        locks[i]=boost::unique_lock<boost::mutex>(futures[i].future->mutex);
+                    }
+                }
+                
+                void lock()
+                {
+                    boost::lock(locks.get(),locks.get()+count);
+                }
+                
+                void unlock()
+                {
+                    for(unsigned i=0;i<count;++i)
+                    {
+                        locks[i].unlock();
+                    }
+                }
+            };
+            
+            boost::condition_variable_any cv;
+            std::vector<registered_waiter> futures;
+            unsigned future_count;
+            
+        public:
+            future_waiter():
+                future_count(0)
+            {}
+            
+            template<typename F>
+            void add(F& f)
+            {
+                if(f.future)
+                {
+                    futures.push_back(registered_waiter(f.future,f.future->register_external_waiter(cv),future_count));
+                }
+                ++future_count;
+            }
+
+            unsigned wait()
+            {
+                all_futures_lock lk(futures);
+                for(;;)
+                {
+                    for(unsigned i=0;i<futures.size();++i)
+                    {
+                        if(futures[i].future->done)
+                        {
+                            return futures[i].index;
+                        }
+                    }
+                    cv.wait(lk);
+                }
+            }
+            
+            ~future_waiter()
+            {
+                for(unsigned i=0;i<futures.size();++i)
+                {
+                    futures[i].future->remove_external_waiter(futures[i].wait_iterator);
+                }
+            }
+            
+        };
+        
+    }
+
+    template <typename R>
+    class unique_future;
+
+    template <typename R>
+    class shared_future;
+
+    template<typename T>
+    struct is_future_type
+    {
+        BOOST_STATIC_CONSTANT(bool, value=false);
+    };
+    
+    template<typename T>
+    struct is_future_type<unique_future<T> >
+    {
+        BOOST_STATIC_CONSTANT(bool, value=true);
+    };
+    
+    template<typename T>
+    struct is_future_type<shared_future<T> >
+    {
+        BOOST_STATIC_CONSTANT(bool, value=true);
+    };
+
+    template<typename Iterator>
+    typename boost::disable_if<is_future_type<Iterator>,void>::type wait_for_all(Iterator begin,Iterator end)
+    {
+        for(Iterator current=begin;current!=end;++current)
+        {
+            current->wait();
+        }
+    }
+
+    template<typename F1,typename F2>
+    typename boost::enable_if<is_future_type<F1>,void>::type wait_for_all(F1& f1,F2& f2)
+    {
+        f1.wait();
+        f2.wait();
+    }
+
+    template<typename F1,typename F2,typename F3>
+    void wait_for_all(F1& f1,F2& f2,F3& f3)
+    {
+        f1.wait();
+        f2.wait();
+        f3.wait();
+    }
+    
+    template<typename F1,typename F2,typename F3,typename F4>
+    void wait_for_all(F1& f1,F2& f2,F3& f3,F4& f4)
+    {
+        f1.wait();
+        f2.wait();
+        f3.wait();
+        f4.wait();
+    }
+
+    template<typename F1,typename F2,typename F3,typename F4,typename F5>
+    void wait_for_all(F1& f1,F2& f2,F3& f3,F4& f4,F5& f5)
+    {
+        f1.wait();
+        f2.wait();
+        f3.wait();
+        f4.wait();
+        f5.wait();
+    }
+
+    template<typename Iterator>
+    typename boost::disable_if<is_future_type<Iterator>,Iterator>::type wait_for_any(Iterator begin,Iterator end)
+    {
+        detail::future_waiter waiter;
+        for(Iterator current=begin;current!=end;++current)
+        {
+            waiter.add(*current);
+        }
+        return boost::next(begin,waiter.wait());
+    }
+
+    template<typename F1,typename F2>
+    typename boost::enable_if<is_future_type<F1>,unsigned>::type wait_for_any(F1& f1,F2& f2)
+    {
+        detail::future_waiter waiter;
+        waiter.add(f1);
+        waiter.add(f2);
+        return waiter.wait();
+    }
+
+    template<typename F1,typename F2,typename F3>
+    unsigned wait_for_any(F1& f1,F2& f2,F3& f3)
+    {
+        detail::future_waiter waiter;
+        waiter.add(f1);
+        waiter.add(f2);
+        waiter.add(f3);
+        return waiter.wait();
+    }
+    
+    template<typename F1,typename F2,typename F3,typename F4>
+    unsigned wait_for_any(F1& f1,F2& f2,F3& f3,F4& f4)
+    {
+        detail::future_waiter waiter;
+        waiter.add(f1);
+        waiter.add(f2);
+        waiter.add(f3);
+        waiter.add(f4);
+        return waiter.wait();
+    }
+
+    template<typename F1,typename F2,typename F3,typename F4,typename F5>
+    unsigned wait_for_any(F1& f1,F2& f2,F3& f3,F4& f4,F5& f5)
+    {
+        detail::future_waiter waiter;
+        waiter.add(f1);
+        waiter.add(f2);
+        waiter.add(f3);
+        waiter.add(f4);
+        waiter.add(f5);
+        return waiter.wait();
+    }
+    
+    template <typename R>
+    class promise;
+
+    template <typename R>
+    class packaged_task;
+
+    template <typename R>
+    class unique_future
+    {
+        unique_future(unique_future & rhs);// = delete;
+        unique_future& operator=(unique_future& rhs);// = delete;
+
+        typedef boost::shared_ptr<detail::future_object<R> > future_ptr;
+        
+        future_ptr future;
+
+        friend class shared_future<R>;
+        friend class promise<R>;
+        friend class packaged_task<R>;
+        friend class detail::future_waiter;
+
+        typedef typename detail::future_traits<R>::move_dest_type move_dest_type;
+
+        unique_future(future_ptr future_):
+            future(future_)
+        {}
+
+    public:
+        typedef future_state::state state;
+
+        unique_future()
+        {}
+       
+        ~unique_future()
+        {}
+
+#ifdef BOOST_HAS_RVALUE_REFS
+        unique_future(unique_future && other)
+        {
+            future.swap(other.future);
+        }
+        unique_future& operator=(unique_future && other)
+        {
+            future=other.future;
+            other.future.reset();
+            return *this;
+        }
+#else
+        unique_future(boost::detail::thread_move_t<unique_future> other):
+            future(other->future)
+        {
+            other->future.reset();
+        }
+
+        unique_future& operator=(boost::detail::thread_move_t<unique_future> other)
+        {
+            future=other->future;
+            other->future.reset();
+            return *this;
+        }
+
+        operator boost::detail::thread_move_t<unique_future>()
+        {
+            return boost::detail::thread_move_t<unique_future>(*this);
+        }
+#endif
+
+        void swap(unique_future& other)
+        {
+            future.swap(other.future);
+        }
+
+        // retrieving the value
+        move_dest_type get()
+        {
+            if(!future)
+            {
+                throw future_uninitialized();
+            }
+
+            return future->get();
+        }
+        
+        // functions to check state, and wait for ready
+        state get_state() const
+        {
+            if(!future)
+            {
+                return future_state::uninitialized;
+            }
+            return future->get_state();
+        }
+        
+
+        bool is_ready() const
+        {
+            return get_state()==future_state::ready;
+        }
+        
+        bool has_exception() const
+        {
+            return future && future->has_exception();
+        }
+        
+        bool has_value() const
+        {
+            return future && future->has_value();
+        }
+        
+        void wait() const
+        {
+            if(!future)
+            {
+                throw future_uninitialized();
+            }
+            future->wait(false);
+        }
+        
+        template<typename Duration>
+        bool timed_wait(Duration const& rel_time) const
+        {
+            return timed_wait_until(boost::get_system_time()+rel_time);
+        }
+        
+        bool timed_wait_until(boost::system_time const& abs_time) const
+        {
+            if(!future)
+            {
+                throw future_uninitialized();
+            }
+            return future->timed_wait_until(abs_time);
+        }
+        
+    };
+
+    template <typename R>
+    class shared_future
+    {
+        typedef boost::shared_ptr<detail::future_object<R> > future_ptr;
+        
+        future_ptr future;
+
+//         shared_future(const unique_future<R>& other);
+//         shared_future& operator=(const unique_future<R>& other);
+
+        friend class detail::future_waiter;
+        friend class promise<R>;
+        friend class packaged_task<R>;
+        
+        shared_future(future_ptr future_):
+            future(future_)
+        {}
+
+    public:
+        shared_future(shared_future const& other):
+            future(other.future)
+        {}
+
+        typedef future_state::state state;
+
+        shared_future()
+        {}
+
+        ~shared_future()
+        {}
+
+        shared_future& operator=(shared_future const& other)
+        {
+            future=other.future;
+            return *this;
+        }
+#ifdef BOOST_HAS_RVALUE_REFS
+        shared_future(shared_future && other)
+        {
+            future.swap(other.future);
+        }
+        shared_future(unique_future<R> && other)
+        {
+            future.swap(other.future);
+        }
+        shared_future& operator=(shared_future && other)
+        {
+            future.swap(other.future);
+            other.future.reset();
+            return *this;
+        }
+        shared_future& operator=(unique_future<R> && other)
+        {
+            future.swap(other.future);
+            other.future.reset();
+            return *this;
+        }
+#else            
+        shared_future(boost::detail::thread_move_t<shared_future> other):
+            future(other->future)
+        {
+            other->future.reset();
+        }
+//         shared_future(const unique_future<R> &) = delete;
+        shared_future(boost::detail::thread_move_t<unique_future<R> > other):
+            future(other->future)
+        {
+            other->future.reset();
+        }
+        shared_future& operator=(boost::detail::thread_move_t<shared_future> other)
+        {
+            future.swap(other->future);
+            other->future.reset();
+            return *this;
+        }
+        shared_future& operator=(boost::detail::thread_move_t<unique_future<R> > other)
+        {
+            future.swap(other->future);
+            other->future.reset();
+            return *this;
+        }
+
+        operator boost::detail::thread_move_t<shared_future>()
+        {
+            return boost::detail::thread_move_t<shared_future>(*this);
+        }
+
+#endif
+
+        void swap(shared_future& other)
+        {
+            future.swap(other.future);
+        }
+
+        // retrieving the value
+        R get()
+        {
+            if(!future)
+            {
+                throw future_uninitialized();
+            }
+
+            return future->get();
+        }
+        
+        // functions to check state, and wait for ready
+        state get_state() const
+        {
+            if(!future)
+            {
+                return future_state::uninitialized;
+            }
+            return future->get_state();
+        }
+        
+
+        bool is_ready() const
+        {
+            return get_state()==future_state::ready;
+        }
+        
+        bool has_exception() const
+        {
+            return future && future->has_exception();
+        }
+        
+        bool has_value() const
+        {
+            return future && future->has_value();
+        }
+
+        void wait() const
+        {
+            if(!future)
+            {
+                throw future_uninitialized();
+            }
+            future->wait(false);
+        }
+        
+        template<typename Duration>
+        bool timed_wait(Duration const& rel_time) const
+        {
+            return timed_wait_until(boost::get_system_time()+rel_time);
+        }
+        
+        bool timed_wait_until(boost::system_time const& abs_time) const
+        {
+            if(!future)
+            {
+                throw future_uninitialized();
+            }
+            return future->timed_wait_until(abs_time);
+        }
+        
+    };
+
+    template <typename R>
+    class promise
+    {
+        typedef boost::shared_ptr<detail::future_object<R> > future_ptr;
+        
+        future_ptr future;
+        bool future_obtained;
+        
+        promise(promise & rhs);// = delete;
+        promise & operator=(promise & rhs);// = delete;
+
+        void lazy_init()
+        {
+            if(!future)
+            {
+                future_obtained=false;
+                future.reset(new detail::future_object<R>);
+            }
+        }
+        
+    public:
+//         template <class Allocator> explicit promise(Allocator a);
+
+        promise():
+            future(),future_obtained(false)
+        {}
+        
+        ~promise()
+        {
+            if(future)
+            {
+                boost::lock_guard<boost::mutex> lock(future->mutex);
+
+                if(!future->done)
+                {
+                    future->mark_exceptional_finish_internal(boost::copy_exception(broken_promise()));
+                }
+            }
+        }
+
+        // Assignment
+#ifdef BOOST_HAS_RVALUE_REFS
+        promise(promise && rhs):
+            future_obtained(rhs.future_obtained)
+        {
+            future.swap(rhs.future);
+        }
+        promise & operator=(promise&& rhs)
+        {
+            future.swap(rhs.future);
+            future_obtained=rhs.future_obtained;
+            rhs.future.reset();
+            return *this;
+        }
+#else
+        promise(boost::detail::thread_move_t<promise> rhs):
+            future(rhs->future),future_obtained(rhs->future_obtained)
+        {
+            rhs->future.reset();
+        }
+        promise & operator=(boost::detail::thread_move_t<promise> rhs)
+        {
+            future=rhs->future;
+            future_obtained=rhs->future_obtained;
+            rhs->future.reset();
+            return *this;
+        }
+
+        operator boost::detail::thread_move_t<promise>()
+        {
+            return boost::detail::thread_move_t<promise>(*this);
+        }
+#endif   
+        
+        void swap(promise& other)
+        {
+            future.swap(other.future);
+            std::swap(future_obtained,other.future_obtained);
+        }
+
+        // Result retrieval
+        unique_future<R> get_future()
+        {
+            lazy_init();
+            if(future_obtained)
+            {
+                throw future_already_retrieved();
+            }
+            future_obtained=true;
+            return unique_future<R>(future);
+        }
+
+        void set_value(typename detail::future_traits<R>::source_reference_type r)
+        {
+            lazy_init();
+            boost::lock_guard<boost::mutex> lock(future->mutex);
+            if(future->done)
+            {
+                throw promise_already_satisfied();
+            }
+            future->mark_finished_with_result_internal(r);
+        }
+
+//         void set_value(R && r);
+        void set_value(typename detail::future_traits<R>::rvalue_source_type r)
+        {
+            lazy_init();
+            boost::lock_guard<boost::mutex> lock(future->mutex);
+            if(future->done)
+            {
+                throw promise_already_satisfied();
+            }
+            future->mark_finished_with_result_internal(static_cast<typename detail::future_traits<R>::rvalue_source_type>(r));
+        }
+
+        void set_exception(boost::exception_ptr p)
+        {
+            lazy_init();
+            boost::lock_guard<boost::mutex> lock(future->mutex);
+            if(future->done)
+            {
+                throw promise_already_satisfied();
+            }
+            future->mark_exceptional_finish_internal(p);
+        }
+
+        template<typename F>
+        void set_wait_callback(F f)
+        {
+            lazy_init();
+            future->set_wait_callback(f,this);
+        }
+        
+    };
+
+    template <>
+    class promise<void>
+    {
+        typedef boost::shared_ptr<detail::future_object<void> > future_ptr;
+        
+        future_ptr future;
+        bool future_obtained;
+        
+        promise(promise & rhs);// = delete;
+        promise & operator=(promise & rhs);// = delete;
+
+        void lazy_init()
+        {
+            if(!future)
+            {
+                future_obtained=false;
+                future.reset(new detail::future_object<void>);
+            }
+        }
+    public:
+//         template <class Allocator> explicit promise(Allocator a);
+
+        promise():
+            future(),future_obtained(false)
+        {}
+        
+        ~promise()
+        {
+            if(future)
+            {
+                boost::lock_guard<boost::mutex> lock(future->mutex);
+
+                if(!future->done)
+                {
+                    future->mark_exceptional_finish_internal(boost::copy_exception(broken_promise()));
+                }
+            }
+        }
+
+        // Assignment
+#ifdef BOOST_HAS_RVALUE_REFS
+        promise(promise && rhs):
+            future_obtained(rhs.future_obtained)
+        {
+            future.swap(rhs.future);
+        }
+        promise & operator=(promise&& rhs)
+        {
+            future.swap(rhs.future);
+            future_obtained=rhs.future_obtained;
+            rhs.future.reset();
+            return *this;
+        }
+#else
+        promise(boost::detail::thread_move_t<promise> rhs):
+            future(rhs->future),future_obtained(rhs->future_obtained)
+        {
+            rhs->future.reset();
+        }
+        promise & operator=(boost::detail::thread_move_t<promise> rhs)
+        {
+            future=rhs->future;
+            future_obtained=rhs->future_obtained;
+            rhs->future.reset();
+            return *this;
+        }
+
+        operator boost::detail::thread_move_t<promise>()
+        {
+            return boost::detail::thread_move_t<promise>(*this);
+        }
+#endif
+        
+        void swap(promise& other)
+        {
+            future.swap(other.future);
+            std::swap(future_obtained,other.future_obtained);
+        }
+
+        // Result retrieval
+        unique_future<void> get_future()
+        {
+            lazy_init();
+            
+            if(future_obtained)
+            {
+                throw future_already_retrieved();
+            }
+            future_obtained=true;
+            return unique_future<void>(future);
+        }
+
+        void set_value()
+        {
+            lazy_init();
+            boost::lock_guard<boost::mutex> lock(future->mutex);
+            if(future->done)
+            {
+                throw promise_already_satisfied();
+            }
+            future->mark_finished_with_result_internal();
+        }
+
+        void set_exception(boost::exception_ptr p)
+        {
+            lazy_init();
+            boost::lock_guard<boost::mutex> lock(future->mutex);
+            if(future->done)
+            {
+                throw promise_already_satisfied();
+            }
+            future->mark_exceptional_finish_internal(p);
+        }
+
+        template<typename F>
+        void set_wait_callback(F f)
+        {
+            lazy_init();
+            future->set_wait_callback(f,this);
+        }
+        
+    };
+
+    namespace detail
+    {
+        template<typename R>
+        struct task_base:
+            detail::future_object<R>
+        {
+            bool started;
+
+            task_base():
+                started(false)
+            {}
+
+            void run()
+            {
+                {
+                    boost::lock_guard<boost::mutex> lk(this->mutex);
+                    if(started)
+                    {
+                        throw task_already_started();
+                    }
+                    started=true;
+                }
+                do_run();
+            }
+
+            void owner_destroyed()
+            {
+                boost::lock_guard<boost::mutex> lk(this->mutex);
+                if(!started)
+                {
+                    started=true;
+                    this->mark_exceptional_finish_internal(boost::copy_exception(boost::broken_promise()));
+                }
+            }
+            
+            
+            virtual void do_run()=0;
+        };
+        
+        
+        template<typename R,typename F>
+        struct task_object:
+            task_base<R>
+        {
+            F f;
+            task_object(F const& f_):
+                f(f_)
+            {}
+            task_object(boost::detail::thread_move_t<F> f_):
+                f(f_)
+            {}
+            
+            void do_run()
+            {
+                try
+                {
+					this->mark_finished_with_result(f());
+                }
+                catch(...)
+                {
+                    this->mark_exceptional_finish();
+                }
+            }
+        };
+
+        template<typename F>
+        struct task_object<void,F>:
+            task_base<void>
+        {
+            F f;
+            task_object(F const& f_):
+                f(f_)
+            {}
+            task_object(boost::detail::thread_move_t<F> f_):
+                f(f_)
+            {}
+            
+            void do_run()
+            {
+                try
+                {
+                    f();
+                    this->mark_finished_with_result();
+                }
+                catch(...)
+                {
+                    this->mark_exceptional_finish();
+                }
+            }
+        };
+
+    }
+    
+
+    template<typename R>
+    class packaged_task
+    {
+        boost::shared_ptr<detail::task_base<R> > task;
+        bool future_obtained;
+
+        packaged_task(packaged_task&);// = delete;
+        packaged_task& operator=(packaged_task&);// = delete;
+        
+    public:
+        packaged_task():
+            future_obtained(false)
+        {}
+        
+        // construction and destruction
+        template <class F>
+        explicit packaged_task(F const& f):
+            task(new detail::task_object<R,F>(f)),future_obtained(false)
+        {}
+        explicit packaged_task(R(*f)()):
+            task(new detail::task_object<R,R(*)()>(f)),future_obtained(false)
+        {}
+        
+        template <class F>
+        explicit packaged_task(boost::detail::thread_move_t<F> f):
+            task(new detail::task_object<R,F>(f)),future_obtained(false)
+        {}
+
+//         template <class F, class Allocator>
+//         explicit packaged_task(F const& f, Allocator a);
+//         template <class F, class Allocator>
+//         explicit packaged_task(F&& f, Allocator a);
+
+
+        ~packaged_task()
+        {
+            if(task)
+            {
+                task->owner_destroyed();
+            }
+        }
+
+        // assignment
+#ifdef BOOST_HAS_RVALUE_REFS
+        packaged_task(packaged_task&& other):
+            future_obtained(other.future_obtained)
+        {
+            task.swap(other.task);
+            other.future_obtained=false;
+        }
+        packaged_task& operator=(packaged_task&& other)
+        {
+            packaged_task temp(static_cast<packaged_task&&>(other));
+            swap(temp);
+            return *this;
+        }
+#else
+        packaged_task(boost::detail::thread_move_t<packaged_task> other):
+            future_obtained(other->future_obtained)
+        {
+            task.swap(other->task);
+            other->future_obtained=false;
+        }
+        packaged_task& operator=(boost::detail::thread_move_t<packaged_task> other)
+        {
+            packaged_task temp(other);
+            swap(temp);
+            return *this;
+        }
+        operator boost::detail::thread_move_t<packaged_task>()
+        {
+            return boost::detail::thread_move_t<packaged_task>(*this);
+        }
+#endif
+
+        void swap(packaged_task& other)
+        {
+            task.swap(other.task);
+            std::swap(future_obtained,other.future_obtained);
+        }
+
+        // result retrieval
+        unique_future<R> get_future()
+        {
+            if(!task)
+            {
+                throw task_moved();
+            }
+            else if(!future_obtained)
+            {
+                future_obtained=true;
+                return unique_future<R>(task);
+            }
+            else
+            {
+                throw future_already_retrieved();
+            }
+        }
+        
+
+        // execution
+        void operator()()
+        {
+            if(!task)
+            {
+                throw task_moved();
+            }
+            task->run();
+        }
+
+        template<typename F>
+        void set_wait_callback(F f)
+        {
+            task->set_wait_callback(f,this);
+        }
+        
+    };
+}
+
+#endif
diff -urN boost/boost/task/handle.hpp boost-altered/boost/task/handle.hpp
--- boost/boost/task/handle.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/handle.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,270 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_HANDLE_H
+#define BOOST_TASK_HANDLE_H
+
+#include <boost/thread.hpp>
+#include <boost/thread/thread_time.hpp>
+
+#include <boost/task/detail/interrupter.hpp>
+#include <boost/task/future.hpp>
+#include <boost/task/exceptions.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+
+template< typename Channel >
+class static_pool;
+
+struct own_thread;
+struct new_thread;
+struct as_sub_task;
+
+template< typename R >
+class handle
+{
+private:
+	template< typename Channel >
+	friend class static_pool;
+	friend struct own_thread;
+	friend struct new_thread;
+	friend struct as_sub_task;
+	template< typename Iterator >
+	friend void waitfor_all( Iterator begin, Iterator end);
+	template< typename T1, typename T2 >
+	friend void waitfor_all( T1 & t1, T2 & t2);
+	template< typename T1, typename T2, typename T3 >
+	friend void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3);
+	template< typename T1, typename T2, typename T3, typename T4 >
+	friend void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4);
+	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
+	friend void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);
+	template< typename Iterator >
+	friend Iterator waitfor_any( Iterator begin, Iterator end);
+	template< typename T1, typename T2 >
+	friend unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2);
+	template< typename T1, typename T2, typename T3 >
+	friend unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3);
+	template< typename T1, typename T2, typename T3, typename T4 >
+	friend unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4);
+	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
+	friend unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);
+
+	shared_future< R >		fut_;
+	detail::interrupter		intr_;
+
+	handle(
+		shared_future< R > fut,
+		detail::interrupter const& intr)
+	:
+	fut_( fut),
+	intr_( intr)
+	{}
+
+public:
+	handle()
+	: fut_(), intr_()
+	{}
+
+	void interrupt()
+	{ intr_.interrupt(); }
+
+	void interrupt_and_wait()
+	{
+		interrupt();
+		wait();
+	}
+
+	bool interrupt_and_wait_until( system_time const& abs_time)
+	{
+		interrupt();
+		return wait_until( abs_time);
+	}
+
+	template< typename Duration >
+	bool interrupt_and_wait_for( Duration const& rel_time)
+	{
+		interrupt();
+		return wait_for( rel_time);
+	}
+
+	bool interruption_requested()
+	{ return intr_.interruption_requested(); }
+
+	R get()
+	{
+		try
+		{ return fut_.get(); }
+		catch ( future_uninitialized const&)
+		{ throw task_uninitialized(); }
+		catch ( broken_promise const&)
+		{ throw broken_task(); }
+		catch ( promise_already_satisfied const&)
+		{ throw task_already_executed(); }
+	}
+
+	bool is_ready() const
+	{ return fut_.is_ready(); }
+
+	bool has_value() const
+	{ return fut_.has_value(); }
+
+	bool has_exception() const
+	{ return fut_.has_exception(); }
+
+	void wait() const
+	{
+		try
+		{ fut_.wait(); }
+		catch ( future_uninitialized const&)
+		{ throw task_uninitialized(); }
+		catch ( broken_promise const&)
+		{ throw broken_task(); }
+		catch ( thread_interrupted const&)
+		{ throw task_interrupted(); }
+	}
+
+	template< typename Duration >
+	bool wait_for( Duration const& rel_time) const
+	{
+		try
+		{ return fut_.timed_wait( rel_time); }
+		catch ( future_uninitialized const&)
+		{ throw task_uninitialized(); }
+		catch ( broken_promise const&)
+		{ throw broken_task(); }
+		catch ( thread_interrupted const&)
+		{ throw task_interrupted(); }
+	}
+
+	bool wait_until( system_time const& abs_time) const
+	{
+		try
+		{ return fut_.timed_wait_until( abs_time); }
+		catch ( future_uninitialized const&)
+		{ throw task_uninitialized(); }
+		catch ( broken_promise const&)
+		{ throw broken_task(); }
+		catch ( thread_interrupted const&)
+		{ throw task_interrupted(); }
+	}
+
+	shared_future< R > & get_future()
+	{ return fut_; }
+
+	void swap( handle< R > & other)
+	{
+		fut_.swap( other.fut_);
+		intr_.swap( other.intr_);
+	}
+};
+
+template< typename Iterator >
+void waitfor_all( Iterator begin, Iterator end)
+{
+	try
+	{
+		for ( Iterator i = begin; i != end; ++i)
+			i->wait();
+	}
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+template< typename T1, typename T2 >
+void waitfor_all( T1 & t1, T2 & t2)
+{
+	try
+	{ wait_for_all( t1.fut_, t2.fut_); }
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+template< typename T1, typename T2, typename T3 >
+void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3)
+{
+	try
+	{ wait_for_all( t1.fut_, t2.fut_, t3.fut_); }
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+template< typename T1, typename T2, typename T3, typename T4 >
+void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4)
+{
+	try
+	{ wait_for_all( t1.fut_, t2.fut_, t3.fut_, t4.fut_); }
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+template< typename T1, typename T2, typename T3, typename T4, typename T5 >
+void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5)
+{
+	try
+	{ wait_for_all( t1.fut_, t2.fut_, t3.fut_, t4.fut_, t5.fut_); }
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+template< typename Iterator >
+Iterator waitfor_any( Iterator begin, Iterator end)
+{
+	try
+	{
+		boost::detail::future_waiter waiter;
+		for ( Iterator i = begin; i != end; ++i)
+			waiter.add( i->fut_);
+		return next( begin, waiter.wait() );
+	}
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+template< typename T1, typename T2 >
+unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2)
+{
+	try
+	{ return wait_for_any( t1.fut_, t2.fut_); }
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+template< typename T1, typename T2, typename T3 >
+unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3)
+{
+	try
+	{ return wait_for_any( t1.fut_, t2.fut_, t3.fut_); }
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+template< typename T1, typename T2, typename T3, typename T4 >
+unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4)
+{
+	try
+	{ return wait_for_any( t1.fut_, t2.fut_, t3.fut_, t4.fut_); }
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+template< typename T1, typename T2, typename T3, typename T4, typename T5 >
+unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5)
+{
+	try
+	{ return wait_for_any( t1.fut_, t2.fut_, t3.fut_, t4.fut_, t5.fut_); }
+	catch ( thread_interrupted const&)
+	{ throw task_interrupted(); }
+}
+
+}}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_HANDLE_H
diff -urN boost/boost/task/meta.hpp boost-altered/boost/task/meta.hpp
--- boost/boost/task/meta.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/meta.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,38 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_META_H
+#define BOOST_TASK_META_H
+
+#include <boost/mpl/bool.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/task/detail/meta.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+template< typename Pool >
+struct has_attribute : public mpl::bool_<
+	is_same<
+		detail::has_attribute,
+		typename Pool::channel::scheduler_type::attribute_tag_type
+	>::value
+>
+{};
+
+template< typename Pool >
+struct attribute_type
+{
+	typedef typename Pool::channel::scheduler_type::attribute_type	type;
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_META_H
+
diff -urN boost/boost/task/new_thread.hpp boost-altered/boost/task/new_thread.hpp
--- boost/boost/task/new_thread.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/new_thread.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,65 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_NEW_THREAD_H
+#define BOOST_TASK_NEW_THREAD_H
+
+#include <boost/config.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/detail/move.hpp>
+
+#include <boost/task/detail/interrupter.hpp>
+#include <boost/task/future.hpp>
+#include <boost/task/handle.hpp>
+#include <boost/task/task.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+struct joiner
+{
+	void operator()( thread * thrd)
+	{
+		try
+		{ thrd->join(); }
+		catch (...)
+		{}
+		delete thrd;
+	}
+};
+
+}
+
+struct new_thread
+{
+	template< typename R >
+# if defined(BOOST_HAS_RVALUE_REFS)
+	handle< R > operator()( task< R > && t_)
+# else
+	handle< R > operator()( boost::detail::thread_move_t< task< R > > t_)
+# endif
+	{
+		task< R > t( t_);
+		shared_future< R > fut( t.get_future() );
+
+		shared_ptr< thread > thrd(
+				new thread( boost::move( t) ),
+				detail::joiner() );
+		detail::interrupter intr;
+		intr.set( thrd);
+
+		return handle< R >( fut, intr);
+	}
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_NEW_THREAD_H
diff -urN boost/boost/task/own_thread.hpp boost-altered/boost/task/own_thread.hpp
--- boost/boost/task/own_thread.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/own_thread.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,42 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_OWN_THREAD_H
+#define BOOST_TASK_OWN_THREAD_H
+
+#include <boost/config.hpp>
+#include <boost/thread/detail/move.hpp>
+
+#include <boost/task/detail/interrupter.hpp>
+#include <boost/task/handle.hpp>
+#include <boost/task/task.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+struct own_thread
+{
+	template< typename R >
+# if defined(BOOST_HAS_RVALUE_REFS)
+	handle< R > operator()( task< R > && t_)
+# else
+	handle< R > operator()( boost::detail::thread_move_t< task< R > > t_)
+# endif
+	{
+		task< R > t( t_);
+		shared_future< R > fut( t.get_future() );
+		detail::interrupter intr;
+		intr.reset();
+		t();
+		return handle< R >( fut, intr);
+	}
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_OWN_THREAD_H
diff -urN boost/boost/task/poolsize.hpp boost-altered/boost/task/poolsize.hpp
--- boost/boost/task/poolsize.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/poolsize.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,41 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_POOLSIZE_H
+#define BOOST_TASK_POOLSIZE_H
+
+#include <cstddef>
+
+#include <boost/task/detail/config.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+class BOOST_TASK_DECL poolsize
+{
+private:
+	std::size_t	value_;
+
+public:
+	explicit poolsize( std::size_t value);
+
+	operator std::size_t () const;
+};
+} }
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_POOLSIZE_H
diff -urN boost/boost/task/priority.hpp boost-altered/boost/task/priority.hpp
--- boost/boost/task/priority.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/priority.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,128 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_PRIORITY_H
+#define BOOST_TASK_PRIORITY_H
+
+#include <cstddef>
+#include <utility>
+
+#include <boost/assert.hpp>
+#include <boost/multi_index_container.hpp>
+#include <boost/multi_index/mem_fun.hpp>
+#include <boost/multi_index/ordered_index.hpp>
+
+#include <boost/task/detail/pool_callable.hpp>
+#include <boost/task/detail/meta.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+template<
+	typename Attr,
+	typename Ord = std::greater< Attr >
+>
+struct priority
+{
+	typedef detail::has_attribute	attribute_tag_type;
+	typedef Attr					attribute_type;
+
+	class impl
+	{
+	private:
+		typedef Attr		attribute;
+		typedef Ord			ordering;
+
+	public:
+		class item
+		{
+		private:
+			detail::pool_callable	ca_;
+			attribute			attr_;
+	
+		public:
+			item(
+				detail::pool_callable const& ca,
+				attribute const& attr)
+			: ca_( ca), attr_( attr)
+			{ BOOST_ASSERT( ! ca_.empty() ); }
+	
+			const detail::pool_callable ca() const
+			{ return ca_; }
+	
+			const attribute attr() const
+			{ return attr_; }
+		};
+	
+	private:
+		typedef multi_index::multi_index_container<
+			item,
+			multi_index::indexed_by<
+				multi_index::ordered_non_unique<
+					multi_index::const_mem_fun<
+						item,
+						const attribute,
+						& item::attr
+					>,
+					ordering
+				>
+			>
+		>														list;
+		typedef typename list::template nth_index< 0 >::type	index;
+	
+		list		lst_;
+		index	&	idx_;
+	
+	public:
+		typedef typename list::iterator			iterator;
+		typedef typename list::const_iterator	const_iterator;
+	
+		impl()
+		:
+		lst_(),
+		idx_( lst_.get< 0 >() )
+		{}
+	
+		void push( item const& itm)
+		{ idx_.insert( itm); }
+	
+		const detail::pool_callable pop()
+		{
+			iterator i( lst_.begin() );
+			BOOST_ASSERT( i != lst_.end() );
+			item itm( * i);
+			lst_.erase( i);
+			return itm.ca();
+		}
+	
+		std::size_t size() const
+		{ return lst_.size(); }
+	
+		bool empty() const
+		{ return lst_.empty(); }
+	
+		void clear()
+		{ lst_.clear(); }
+	
+		const iterator begin()
+		{ return lst_.begin(); }
+	
+		const const_iterator begin() const
+		{ return lst_.begin(); }
+	
+		const iterator end()
+		{ return lst_.end(); }
+	
+		const const_iterator end() const
+		{ return lst_.end(); }
+	};
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_PRIORITY_H
diff -urN boost/boost/task/scanns.hpp boost-altered/boost/task/scanns.hpp
--- boost/boost/task/scanns.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/scanns.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,41 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_SCANNS_H
+#define BOOST_TASK_SCANNS_H
+
+#include <cstddef>
+
+#include <boost/task/detail/config.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+class BOOST_TASK_DECL scanns
+{
+private:
+	std::size_t	value_;
+
+public:
+	explicit scanns( std::size_t value);
+
+	operator std::size_t () const;
+};
+} }
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_SCANNS_H
diff -urN boost/boost/task/semaphore.hpp boost-altered/boost/task/semaphore.hpp
--- boost/boost/task/semaphore.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/semaphore.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,63 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_SEMAPHORE_H
+#define BOOST_TASK_SEMAPHORE_H
+
+#include <boost/task/detail/config.hpp>
+
+extern "C"
+{
+# if defined(BOOST_WINDOWS_API)
+#include <Windows.h>
+# elif defined(BOOST_POSIX_API)
+#include <semaphore.h>
+# endif
+}
+
+#include <boost/utility.hpp>
+
+#include <boost/task/detail/config.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+class BOOST_TASK_DECL semaphore : private boost::noncopyable
+{
+private:
+# if defined(BOOST_WINDOWS_API)
+	HANDLE	handle_;
+# elif defined(BOOST_POSIX_API)
+	sem_t	handle_;;
+# endif
+public:
+	semaphore( int);
+
+	~semaphore();
+
+	void post();
+
+	void wait();
+	bool try_wait();
+
+	int value();
+};
+}}
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_SEMAPHORE_H
diff -urN boost/boost/task/smart.hpp boost-altered/boost/task/smart.hpp
--- boost/boost/task/smart.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/smart.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,172 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_SMART_H
+#define BOOST_TASK_SMART_H
+
+#include <cstddef>
+
+#include <boost/assert.hpp>
+#include <boost/multi_index_container.hpp>
+#include <boost/multi_index/mem_fun.hpp>
+#include <boost/multi_index/ordered_index.hpp>
+
+#include <boost/task/detail/pool_callable.hpp>
+#include <boost/task/detail/meta.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+template<
+	typename Attr,
+	typename Ord,
+	typename Enq,
+	typename Deq
+>
+struct smart
+{
+	typedef detail::has_attribute	attribute_tag_type;
+	typedef Attr					attribute_type;
+
+	class impl
+	{
+	private:
+		typedef Attr		attribute;
+		typedef Deq			dequeue_op;
+		typedef Enq			enqueue_op;
+		typedef Ord			ordering;
+
+	public:
+		class item
+		{
+		private:
+			detail::pool_callable	ca_;
+			attribute			attr_;
+	
+		public:
+			item()
+			: ca_(), attr_()
+			{}
+
+			item(
+				detail::pool_callable const& ca,
+				attribute const& attr)
+			: ca_( ca), attr_( attr)
+			{ BOOST_ASSERT( ! ca_.empty() ); }
+	
+			const detail::pool_callable ca() const
+			{ return ca_; }
+	
+			const attribute attr() const
+			{ return attr_; }
+		};
+	
+	private:
+		typedef multi_index::multi_index_container<
+			item,
+			multi_index::indexed_by<
+				multi_index::ordered_non_unique<
+					multi_index::const_mem_fun<
+						item,
+						const attribute,
+						& item::attr
+					>,
+					ordering
+				>
+			>
+		>														list;
+		typedef typename list::template nth_index< 0 >::type	index;
+	
+		list		lst_;
+		index	&	idx_;
+		enqueue_op	enq_op_;
+		dequeue_op	deq_op_;
+	
+	public:
+		typedef typename index::iterator		iterator;
+		typedef typename index::const_iterator	const_iterator;
+	
+		impl(
+			enqueue_op const& enq_op = enqueue_op(),
+			dequeue_op const& deq_op = dequeue_op() )
+		:
+		lst_(),
+		idx_( lst_.get< 0 >() ),
+		enq_op_( enq_op),
+		deq_op_( deq_op)
+		{}
+	
+		void push( item const& itm)
+		{ enq_op_( idx_, itm); }
+	
+		const detail::pool_callable pop()
+		{
+			item itm;
+			deq_op_( idx_, itm);
+			return itm.ca();
+		}
+	
+		std::size_t size() const
+		{ return lst_.size(); }
+	
+		bool empty() const
+		{ return lst_.empty(); }
+	
+		void clear()
+		{ lst_.clear(); }
+	
+		const iterator begin()
+		{ return lst_.begin(); }
+	
+		const const_iterator begin() const
+		{ return lst_.begin(); }
+	
+		const iterator end()
+		{ return lst_.end(); }
+	
+		const const_iterator end() const
+		{ return lst_.end(); }
+	};
+};
+
+struct replace_oldest
+{
+	template<
+		typename Index,
+		typename Item
+	>
+	void operator()( Index & idx, Item const& itm)
+	{
+		typedef typename Index::iterator iterator;
+		iterator i( idx.find( itm.attr() ) );
+		if ( i == idx.end() )
+			idx.insert( itm);
+		else
+			idx.replace( i, itm);
+	}
+};
+
+struct take_oldest
+{
+	template<
+		typename Index,
+		typename Item
+	>
+	void operator()( Index & idx, Item & itm)
+	{
+		typedef typename Index::iterator	iterator;
+		iterator i( idx.begin() );
+		BOOST_ASSERT( i != idx.end() );
+		itm = * i;
+		idx.erase( i);
+	}
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_SMART_H
diff -urN boost/boost/task/static_pool.hpp boost-altered/boost/task/static_pool.hpp
--- boost/boost/task/static_pool.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/static_pool.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,596 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_STATIC_POOL_H
+#define BOOST_TASK_STATIC_POOL_H
+
+#include <cstddef>
+#include <utility>
+#include <vector>
+
+#include <boost/assert.hpp>
+#include <boost/bind.hpp>
+#include <boost/config.hpp>
+#include <boost/cstdint.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/function.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/detail/move.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task/detail/atomic.hpp>
+#include <boost/task/detail/bind_processor.hpp>
+#include <boost/task/detail/interrupter.hpp>
+#include <boost/task/detail/pool_callable.hpp>
+#include <boost/task/detail/worker.hpp>
+#include <boost/task/detail/worker_group.hpp>
+#include <boost/task/exceptions.hpp>
+#include <boost/task/future.hpp>
+#include <boost/task/handle.hpp>
+#include <boost/task/poolsize.hpp>
+#include <boost/task/scanns.hpp>
+#include <boost/task/task.hpp>
+#include <boost/task/watermark.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+template< typename Channel >
+class static_pool : private noncopyable
+{
+public:
+	typedef Channel		channel;
+
+private:
+	template< typename Pool >
+	friend struct has_attribute;
+
+	template< typename Pool >
+	friend struct attribute_type;
+
+	friend class detail::worker;
+
+# if defined(BOOST_MSVC) && (BOOST_MSVC < 1500) // < MSVC 9.0
+	template< typename Pool >
+	friend class detail::worker::impl_pool;
+# endif
+
+	typedef typename channel::item	channel_item;
+	
+# if defined(BOOST_HAS_PROCESSOR_BINDINGS)
+	struct tag_bind_to_processors {};
+# endif
+	
+	class pool_base
+	{
+	private:
+		friend class detail::worker;
+
+# if defined(BOOST_MSVC) && (BOOST_MSVC < 1500) // < MSVC 9.0
+		template< typename Pool >
+		friend class detail::worker::impl_pool;
+# endif
+	
+		detail::worker_group		wg_;
+		shared_mutex			mtx_wg_;
+		volatile uint32_t		state_;
+		channel		 		channel_;
+		volatile uint32_t		active_worker_;
+		volatile uint32_t		idle_worker_;
+
+		void worker_entry_()
+		{
+			shared_lock< shared_mutex > lk( mtx_wg_);
+			typename detail::worker_group::iterator i( wg_.find( this_thread::get_id() ) );
+			lk.unlock();
+			BOOST_ASSERT( i != wg_.end() );
+
+			detail::worker w( * i);
+			w.run();
+		}
+		
+		void create_worker_(
+			poolsize const& psize,
+			posix_time::time_duration const& asleep,
+			scanns const& max_scns)
+		{
+			wg_.insert(
+				detail::worker(
+					* this,
+					psize,
+					asleep,
+					max_scns,
+					boost::bind(
+						& pool_base::worker_entry_,
+						this) ) );
+		}
+
+# if defined(BOOST_HAS_PROCESSOR_BINDINGS)
+		void worker_entry_( std::size_t n)
+		{
+			this_thread::bind_to_processor( n);
+			worker_entry_();
+		}
+
+		void create_worker_(
+			poolsize const& psize,
+			posix_time::time_duration const& asleep,
+			scanns const& max_scns,
+			std::size_t n)
+		{
+			wg_.insert(
+				detail::worker(
+					* this,
+					psize,
+					asleep,
+					max_scns,
+					boost::bind(
+						& pool_base::worker_entry_,
+						this,
+						n) ) );
+		}
+# endif
+
+		std::size_t active_() const
+		{ return active_worker_; }
+
+		std::size_t idle_() const
+		{ return size_() - active_(); }
+
+		std::size_t size_() const
+		{ return wg_.size(); }
+
+		bool closed_() const
+		{ return state_ > 0; }
+
+		unsigned int close_()
+		{ return detail::atomic_fetch_add( & state_, 1); }
+
+	public:
+		explicit pool_base(
+			poolsize const& psize,
+			posix_time::time_duration const& asleep = posix_time::microseconds( 10),
+			scanns const& max_scns = scanns( 20) )
+		:
+		wg_(),
+		mtx_wg_(),
+		state_( 0),
+		channel_(),
+		active_worker_( 0),
+		idle_worker_( 0)
+		{
+			if ( asleep.is_special() || asleep.is_negative() )
+				throw invalid_timeduration();
+			channel_.activate();
+			unique_lock< shared_mutex > lk( mtx_wg_);
+			for ( std::size_t i( 0); i < psize; ++i)
+				create_worker_( psize, asleep, max_scns);
+			lk.unlock();
+		}
+
+		explicit pool_base(
+			poolsize const& psize,
+			high_watermark const& hwm,
+			low_watermark const& lwm,
+			posix_time::time_duration const& asleep = posix_time::microseconds( 100),
+			scanns const& max_scns = scanns( 20) )
+		:
+		wg_(),
+		mtx_wg_(),
+		state_( 0),
+		channel_(
+			hwm,
+			lwm),
+		active_worker_( 0),
+		idle_worker_( 0)
+		{
+			if ( asleep.is_special() || asleep.is_negative() )
+				throw invalid_timeduration();
+			channel_.activate();
+			unique_lock< shared_mutex > lk( mtx_wg_);
+			for ( std::size_t i( 0); i < psize; ++i)
+				create_worker_( psize, asleep, max_scns);
+			lk.unlock();
+		}
+
+# if defined(BOOST_HAS_PROCESSOR_BINDINGS)
+		explicit pool_base(
+			posix_time::time_duration const& asleep = posix_time::microseconds( 10),
+			scanns const& max_scns = scanns( 20) )
+		:
+		wg_(),
+		mtx_wg_(),
+		state_( 0),
+		channel_(),
+		active_worker_( 0),
+		idle_worker_( 0)
+		{
+			if ( asleep.is_special() || asleep.is_negative() )
+				throw invalid_timeduration();
+			poolsize psize( thread::hardware_concurrency() );
+			BOOST_ASSERT( psize > 0);
+			channel_.activate();
+			unique_lock< shared_mutex > lk( mtx_wg_);
+			for ( std::size_t i( 0); i < psize; ++i)
+				create_worker_( psize, asleep, max_scns, i);
+			lk.unlock();
+		}
+
+		explicit pool_base(
+			high_watermark const& hwm,
+			low_watermark const& lwm,
+			posix_time::time_duration const& asleep = posix_time::microseconds( 100),
+			scanns const& max_scns = scanns( 20) )
+		:
+		wg_(),
+		mtx_wg_(),
+		state_( 0),
+		channel_(
+			hwm,
+			lwm),
+		active_worker_( 0),
+		idle_worker_( 0)
+		{
+			if ( asleep.is_special() || asleep.is_negative() )
+				throw invalid_timeduration();
+			poolsize psize( thread::hardware_concurrency() );
+			BOOST_ASSERT( psize > 0);
+			channel_.activate();
+			unique_lock< shared_mutex > lk( mtx_wg_);
+			for ( std::size_t i( 0); i < psize; ++i)
+				create_worker_( psize, asleep, max_scns, i);
+			lk.unlock();
+		}
+# endif
+
+		~pool_base()
+		{ shutdown(); }
+
+		std::size_t active()
+		{
+			shared_lock< shared_mutex > lk( mtx_wg_);
+			return active_();
+		}
+
+		std::size_t idle()
+		{
+			shared_lock< shared_mutex > lk( mtx_wg_);
+			return idle_();
+		}
+
+		void interrupt_all_worker()
+		{
+			if ( closed_() ) return;
+
+			shared_lock< shared_mutex > lk( mtx_wg_);
+			wg_.interrupt_all();
+		}
+
+		void shutdown()
+		{
+			if ( closed_() || close_() > 1) return;
+
+			channel_.deactivate();
+			shared_lock< shared_mutex > lk( mtx_wg_);
+			wg_.signal_shutdown_all();
+			wg_.join_all();
+			lk.unlock();
+		}
+
+		const void shutdown_now()
+		{
+			if ( closed_() || close_() > 1) return;
+
+			channel_.deactivate_now();
+			shared_lock< shared_mutex > lk( mtx_wg_);
+			wg_.signal_shutdown_now_all();
+			wg_.interrupt_all();
+			wg_.join_all();
+			lk.unlock();
+		}
+
+		std::size_t size()
+		{
+			shared_lock< shared_mutex > lk( mtx_wg_);
+			return size_();
+		}
+
+		bool closed()
+		{ return closed_(); }
+
+		void clear()
+		{ channel_.clear(); }
+
+		bool empty()
+		{ return channel_.empty(); }
+
+		std::size_t pending()
+		{ return channel_.size(); }
+
+		std::size_t upper_bound()
+		{ return channel_.upper_bound(); }
+
+		void upper_bound( high_watermark const& hwm)
+		{ channel_.upper_bound( hwm); }
+
+		std::size_t lower_bound()
+		{ return channel_.lower_bound(); }
+
+		void lower_bound( low_watermark const lwm)
+		{ channel_.lower_bound( lwm); }
+
+		template< typename R >
+# if defined(BOOST_HAS_RVALUE_REFS)
+		handle< R > submit( task< R > && t_)
+#else
+		handle< R > submit( boost::detail::thread_move_t< task< R > > t_)
+# endif
+		{
+			if ( closed_() )
+				throw task_rejected("pool is closed");
+
+			task< R > t( t_);
+			shared_future< R > fut( t.get_future() );
+			detail::interrupter intr;
+			channel_.put( detail::pool_callable( boost::move( t), intr) );
+			return handle< R >( fut, intr);
+		}
+
+		template<
+			typename R,
+			typename Attr
+		>
+# if defined(BOOST_HAS_RVALUE_REFS)
+		handle< R > submit( task< R > && t_, Attr const& attr)
+#else
+		
+		handle< R > submit( boost::detail::thread_move_t< task< R > > t_, Attr const& attr)
+# endif
+		{
+			if ( closed_() )
+				throw task_rejected("pool is closed");
+
+			task< R > t( t_);
+			shared_future< R > fut( t.get_future() );
+			detail::interrupter intr;
+			channel_.put( channel_item( detail::pool_callable( boost::move( t), intr), attr) );
+			return handle< R >( fut, intr);
+		}
+	};
+	
+	shared_ptr< pool_base >		pool_;
+
+public:
+	static_pool()
+	: pool_()
+	{}
+	
+	explicit static_pool(
+		poolsize const& psize,
+		posix_time::time_duration const& asleep = posix_time::microseconds( 10),
+		scanns const& max_scns = scanns( 20) )
+	: pool_( new pool_base( psize, asleep, max_scns) )
+	{}
+
+	explicit static_pool(
+		poolsize const& psize,
+		high_watermark const& hwm,
+		low_watermark const& lwm,
+		posix_time::time_duration const& asleep = posix_time::microseconds( 100),
+		scanns const& max_scns = scanns( 20) )
+	: pool_( new pool_base( psize, hwm, lwm, asleep, max_scns) )
+	{}
+
+# if defined(BOOST_HAS_PROCESSOR_BINDINGS)
+	explicit static_pool(
+		tag_bind_to_processors,
+		posix_time::time_duration const& asleep = posix_time::microseconds( 10),
+		scanns const& max_scns = scanns( 20) )
+	: pool_( new pool_base( asleep, max_scns) )
+	{}
+
+	explicit static_pool(
+		tag_bind_to_processors,
+		high_watermark const& hwm,
+		low_watermark const& lwm,
+		posix_time::time_duration const& asleep = posix_time::microseconds( 100),
+		scanns const& max_scns = scanns( 20) )
+	: pool_( new pool_base( hwm, lwm, asleep, max_scns) )
+	{}
+
+	static tag_bind_to_processors bind_to_processors()
+	{ return tag_bind_to_processors(); }
+# endif
+
+# if defined(BOOST_HAS_RVALUE_REFS)
+	static_pool( static_pool && other)
+	: pool_()
+	{ pool_.swap( other.pool_); }
+
+	static_pool & operator=( static_pool && other)
+	{
+	    static_pool tmp( static_cast< static_pool && >( other) );
+	    swap( tmp);
+	    return * this;
+	}
+
+	static_pool && move()
+	{ return static_cast< static_pool && >( * this); }
+# else
+	static_pool( boost::detail::thread_move_t< static_pool > other)
+	: pool_()
+	{ pool_.swap( other->pool_); }
+
+	static_pool & operator=( boost::detail::thread_move_t< static_pool > other)
+	{
+	    static_pool tmp( other);
+	    swap( tmp);
+	    return * this;
+	}
+
+	operator boost::detail::thread_move_t< static_pool >()
+	{ return boost::detail::thread_move_t< static_pool >( * this); }
+# endif
+
+	std::size_t active()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->active();
+	}
+
+	std::size_t idle()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->idle();
+	}
+
+	void interrupt_all_worker()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		pool_->interrupt_all_worker();
+	}
+
+	void shutdown()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		pool_->shutdown();
+	}
+
+	const void shutdown_now()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		pool_->shutdown_now();
+	}
+
+	std::size_t size()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->size();
+	}
+
+	bool closed()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->closed();
+	}
+
+	void clear()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		pool_->clear();
+	}
+
+	bool empty()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->empty();
+	}
+
+	std::size_t pending()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->pending();
+	}
+
+	std::size_t upper_bound()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->upper_bound();
+	}
+
+	void upper_bound( high_watermark const& hwm)
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		pool_->upper_bound( hwm);
+	}
+
+	std::size_t lower_bound()
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->lower_bound();
+	}
+
+	void lower_bound( low_watermark const lwm)
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		pool_->lower_bound( lwm);
+	}
+
+	template< typename R >
+# if defined(BOOST_HAS_RVALUE_REFS)
+	handle< R > submit( task< R > && t)
+#else
+	handle< R > submit( boost::detail::thread_move_t< task< R > > t)
+# endif
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->submit( t);
+	}
+
+	template<
+		typename R,
+		typename Attr
+	>
+# if defined(BOOST_HAS_RVALUE_REFS)
+	handle< R > submit( task< R > && t, Attr const& attr)
+#else
+		
+	handle< R > submit( boost::detail::thread_move_t< task< R > > t, Attr const& attr)
+# endif
+	{
+		if ( ! pool_)
+			throw pool_moved();
+		return pool_->submit( t, attr);
+	}
+
+	typedef typename shared_ptr< pool_base >::unspecified_bool_type	unspecified_bool_type;
+
+	operator unspecified_bool_type() const // throw()
+	{ return pool_; }
+
+	bool operator!() const // throw()
+	{ return ! pool_; }
+
+	void swap( static_pool & other) // throw()
+	{ pool_.swap( other.pool_); }
+};
+}
+
+template< typename Channel >
+void swap( task::static_pool< Channel > & l, task::static_pool< Channel > & r)
+{ return l.swap( r); }
+
+# if defined(BOOST_HAS_RVALUE_REFS)
+template< typename Channel >
+task::static_pool< Channel > && move( task::static_pool< Channel > && t)
+{ return t; }
+# else
+template< typename Channel >
+boost::detail::thread_move_t< task::static_pool< Channel > > move( task::static_pool< Channel > & t)
+{ return t; }
+# endif
+}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_STATIC_POOL_H
+
diff -urN boost/boost/task/task.hpp boost-altered/boost/task/task.hpp
--- boost/boost/task/task.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/task.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,330 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_TASK_H
+#define BOOST_TASK_TASK_H
+
+#include <boost/bind.hpp>
+#include <boost/config.hpp>
+#include <boost/preprocessor/repetition.hpp>
+#include <boost/thread.hpp>
+#include <boost/utility/enable_if.hpp>
+#include <boost/utility/result_of.hpp>
+
+#include <boost/task/future.hpp>
+#include <boost/task/exceptions.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+template< typename Channel >
+class static_pool;
+
+struct as_sub_task;
+
+namespace detail
+{
+template< typename R >
+class task_base
+{
+protected:
+	bool	done_;
+
+protected:
+	promise< R >	prom_;
+
+	virtual void do_run() = 0;
+
+public:
+	task_base()
+	: done_( false), prom_()
+	{}
+
+	virtual ~task_base() {}
+
+	void run()
+	{
+		if ( this->done_) throw task_already_executed();
+		do_run();
+		done_ = true;
+	}
+
+	unique_future< R > get_future()
+	{ return prom_.get_future(); }
+
+	template< typename Cb >
+	void set_wait_callback( Cb const& cb)
+	{ prom_.set_wait_callback( cb); }
+};
+
+template< typename R, typename Fn >
+class task_wrapper : public task_base< R >
+{
+private:
+	Fn		fn_;
+
+	void do_run()
+	{
+		try
+		{ this->prom_.set_value( fn_() ); }
+		catch ( promise_already_satisfied const&)
+		{ throw task_already_executed(); }
+		catch ( thread_interrupted const&)
+		{ this->prom_.set_exception( copy_exception( task_interrupted() ) ); }
+		catch ( boost::exception const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::ios_base::failure const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::domain_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::invalid_argument const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::length_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::out_of_range const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::logic_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::overflow_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::range_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::underflow_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::runtime_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::bad_alloc const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::bad_cast const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::bad_typeid const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::bad_exception const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch(...)
+		{ this->prom_.set_exception( current_exception() ); }
+	}
+
+public:
+	task_wrapper( Fn const& fn)
+	: task_base< R >(), fn_( fn)
+	{}
+};
+
+template< typename Fn >
+class task_wrapper< void, Fn > : public task_base< void >
+{
+private:
+	Fn		fn_;
+
+	void do_run()
+	{
+		try
+		{
+			fn_();
+			this->prom_.set_value();
+		}
+		catch ( promise_already_satisfied const&)
+		{ throw task_already_executed(); }
+		catch ( thread_interrupted const&)
+		{ this->prom_.set_exception( copy_exception( task_interrupted() ) ); }
+		catch ( boost::exception const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::ios_base::failure const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::domain_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::invalid_argument const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::length_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::out_of_range const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::logic_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::overflow_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::range_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::underflow_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::runtime_error const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::bad_alloc const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::bad_cast const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::bad_typeid const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch ( std::bad_exception const& e)
+		{ this->prom_.set_exception( copy_exception( e) ); }
+		catch(...)
+		{ this->prom_.set_exception( current_exception() ); }
+	}
+
+public:
+	task_wrapper( Fn const& fn)
+	: task_base< void >(), fn_( fn)
+	{}
+};
+}
+
+template< typename R >
+class task : private noncopyable
+{
+private:
+	template< typename Channel >
+	friend class static_pool;
+
+	friend struct as_sub_task;
+
+	struct dummy;
+
+	shared_ptr< detail::task_base< R > >	task_;
+
+public:
+	task()
+	: task_()
+	{}
+
+	explicit task( R( * fn)())
+	: task_( new detail::task_wrapper< R, R( *)() >( fn) )
+	{}
+
+# if defined(BOOST_HAS_RVALUE_REFS)
+	template< typename Fn >
+	task( Fn && fn)
+	: task_( new detail::task_wrapper< R, Fn >( fn) )
+	{}
+
+	task( task && other)
+	: task_()
+	{ task_.swap( other.task_); }
+
+	task & operator=( task && other)
+	{
+	    task tmp( static_cast< task && >( other) );
+	    swap( tmp);
+	    return * this;
+	}
+
+	task && move()
+	{ return static_cast< task && >( * this); }
+# else
+#ifdef BOOST_NO_SFINAE
+	template< typename Fn >
+	explicit task( Fn fn)
+	: task_( new detail::task_wrapper< R, Fn >( fn) )
+	{}
+#else
+	template< typename Fn >
+	explicit task( Fn fn, typename disable_if< boost::is_convertible< Fn &, boost::detail::thread_move_t< Fn > >, dummy * >::type = 0)
+	: task_( new detail::task_wrapper< R, Fn >( fn) )
+	{}
+#endif
+	template< typename Fn >
+	task( boost::detail::thread_move_t< Fn > fn)
+	: task_( new detail::task_wrapper< R, Fn >( fn) )
+	{}
+
+	task( boost::detail::thread_move_t< task > other)
+	: task_()
+	{ task_.swap( other->task_); }
+
+	task & operator=( boost::detail::thread_move_t< task > other)
+	{
+	    task tmp( other);
+	    swap( tmp);
+	    return * this;
+	}
+
+	boost::detail::thread_move_t< task > move()
+	{ return boost::detail::thread_move_t< task >( * this); }
+
+	operator boost::detail::thread_move_t< task >()
+	{ return boost::detail::thread_move_t< task >( * this); }
+# endif
+
+# ifndef BOOST_TASK_MAKE_TASK_MAX_ARITY
+#   define BOOST_TASK_MAKE_TASK_MAX_ARITY 10
+# endif
+
+# define BOOST_TASK_MAKE_TASK_FUNC_ARG(z, n, unused) \
+   BOOST_PP_CAT(A, n) BOOST_PP_CAT(a, n)
+# define BOOST_ENUM_TASK_MAKE_TASK_FUNC_ARGS(n) BOOST_PP_ENUM(n, BOOST_TASK_MAKE_TASK_FUNC_ARG, ~)
+
+# define BOOST_TASK_MAKE_TASK_FUNCTION(z, n, unused)	\
+template<												\
+	typename Fn,										\
+	BOOST_PP_ENUM_PARAMS(n, typename A)					\
+>														\
+explicit task( Fn fn, BOOST_ENUM_TASK_MAKE_TASK_FUNC_ARGS(n))	\
+	: task_( new detail::task_wrapper<							\
+			typename result_of< Fn( BOOST_PP_ENUM_PARAMS(n, A)) >::type,	\
+			function< typename result_of< Fn( BOOST_PP_ENUM_PARAMS(n, A)) >::type() >	\
+		>( bind( fn, BOOST_PP_ENUM_PARAMS(n, a)) ) )	\
+	{}
+
+BOOST_PP_REPEAT_FROM_TO( 1, BOOST_TASK_MAKE_TASK_MAX_ARITY, BOOST_TASK_MAKE_TASK_FUNCTION, ~)
+
+# undef BOOST_TASK_MAKE_TASK_FUNCTION
+# undef BOOST_TASK_MAKE_TASK_FUNC_ARG
+# undef BOOST_ENUM_TASK_MAKE_TASK_FUNC_ARGS
+
+	unique_future< R > get_future()
+	{
+		if ( ! task_)
+			throw task_moved();
+		return task_->get_future();
+	}
+
+	void operator()()
+	{
+		if ( ! task_)
+			throw task_moved();
+		task_->run();
+	}
+
+	template< typename Cb >
+	void set_wait_callback( Cb const& cb)
+	{
+		if ( ! task_)
+			throw task_moved();
+		task_->set_wait_callback( cb);
+	}
+
+	typedef typename shared_ptr< detail::task_base< R > >::unspecified_bool_type	unspecified_bool_type;
+
+	operator unspecified_bool_type() const // throw()
+	{ return task_; }
+
+	bool operator!() const // throw()
+	{ return ! task_; }
+
+	void swap( task & other) // throw()
+	{ task_.swap( other.task_); }
+};
+}
+
+template< typename R >
+void swap( task::task< R > & l, task::task< R > & r)
+{ return l.swap( r); }
+
+# if defined(BOOST_HAS_RVALUE_REFS)
+template< typename R >
+task::task< R > && move( task::task< R > && t)
+{ return t; }
+# else
+template< typename R >
+boost::detail::thread_move_t< task::task< R > > move( task::task< R > & t)
+{ return t; }
+# endif
+}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_TASK_H
diff -urN boost/boost/task/unbounded_channel.hpp boost-altered/boost/task/unbounded_channel.hpp
--- boost/boost/task/unbounded_channel.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/unbounded_channel.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,281 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_UNBOUNDED_CHANNEL_H
+#define BOOST_TASK_UNBOUNDED_CHANNEL_H
+
+#include <cstddef>
+#include <vector>
+
+#include <boost/assert.hpp>
+#include <boost/bind.hpp>
+#include <boost/foreach.hpp>
+#include <boost/function.hpp>
+#include <boost/thread/condition.hpp>
+#include <boost/thread/locks.hpp>
+#include <boost/thread/shared_mutex.hpp>
+
+#include <boost/task/detail/pool_callable.hpp>
+#include <boost/task/exceptions.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace task
+{
+template< typename SchedulingPolicy >
+class unbounded_channel
+{
+public:
+	typedef SchedulingPolicy					scheduler_type;
+	typedef typename scheduler_type::impl::item	item;
+
+private:
+	typedef typename scheduler_type::impl	queue;
+
+	enum channel_state
+	{
+		channel_active,
+		channel_deactive,
+		channel_deactive_now
+	};
+
+	channel_state	state_;
+	queue			queue_;
+	shared_mutex	mtx_;
+	condition		not_empty_cond_;
+
+	bool active_() const
+	{ return state_ == channel_active; }
+
+	bool deactive_() const
+	{ return state_ == channel_deactive; }
+
+	bool deactive_now_() const
+	{ return state_ == channel_deactive_now; }
+
+	void activate_()
+	{ state_ = channel_active; }
+
+	void clear_()
+	{
+		BOOST_ASSERT( ! active_() );
+		queue_.clear();
+		BOOST_ASSERT( empty_() );
+	}
+
+	void deactivate_()
+	{
+		if ( active_() )
+		{
+			state_ = channel_deactive;
+			not_empty_cond_.notify_all();
+		}
+
+		BOOST_ASSERT( deactive_() );
+	}
+
+	void deactivate_now_()
+	{
+		if ( active_() )
+		{
+			state_ = channel_deactive_now;
+			not_empty_cond_.notify_all();
+		}
+
+		BOOST_ASSERT( deactive_now_() );
+	}
+
+	const std::vector< detail::pool_callable > drain_()
+	{
+		BOOST_ASSERT( deactive_now_() );
+		std::vector< detail::pool_callable > unprocessed;
+		unprocessed.reserve( queue_.size() );
+		BOOST_FOREACH( detail::pool_callable ca, queue_)
+		{ unprocessed.push_back( ca); }
+		clear_();
+		BOOST_ASSERT( empty_() );
+		return unprocessed;
+	}
+
+	bool empty_() const
+	{ return queue_.empty(); }
+
+	std::size_t size_() const
+	{ return queue_.size(); }
+
+	void put_(
+		item const& itm,
+		unique_lock< shared_mutex > & lk)
+	{
+		if ( ! active_() )
+			throw task_rejected("channel is not active");
+		queue_.push( itm);
+		not_empty_cond_.notify_one();
+	}
+
+	bool take_(
+		detail::pool_callable & ca,
+		unique_lock< shared_mutex > & lk)
+	{
+		if ( deactive_now_() || ( deactive_() && empty_() ) )
+			return false;
+		try
+		{
+			not_empty_cond_.wait(
+				lk,
+				bind(
+					& unbounded_channel::consumers_activate_,
+					this) );
+		}
+		catch ( thread_interrupted const&)
+		{ return false; }
+		if ( deactive_now_() || ( deactive_() && empty_() ) )
+			return false;
+		ca = queue_.pop();
+		return ! ca.empty();
+	}
+
+	template< typename Duration >
+	bool take_(
+		detail::pool_callable & ca,
+		Duration const& rel_time,
+		unique_lock< shared_mutex > & lk)
+	{
+		if ( deactive_now_() || ( deactive_() && empty_() ) )
+			return false;
+		try
+		{
+			if ( ! not_empty_cond_.timed_wait(
+				lk,
+				rel_time,
+				bind(
+					& unbounded_channel::consumers_activate_,
+					this) ) )
+				return false;
+		}
+		catch ( thread_interrupted const&)
+		{ return false; }
+		if ( deactive_now_() || ( deactive_() && empty_() ) )
+			return false;
+		ca = queue_.pop();
+		return ! ca.empty();
+	}
+
+	bool try_take_( detail::pool_callable & ca)
+	{
+		if ( deactive_now_() || empty_() )
+			return false;
+		ca = queue_.pop();
+		return ! ca.empty();
+	}
+
+	bool consumers_activate_() const
+	{ return ! active_() || ! empty_(); }
+
+public:
+	unbounded_channel()
+	:
+	state_( channel_active),
+	queue_(),
+	mtx_(),
+	not_empty_cond_()
+	{}
+
+	bool active()
+	{
+		shared_lock< shared_mutex > lk( mtx_);
+		return active_();
+	}
+
+	void activate()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		activate_();
+	}
+
+	void clear()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		clear_();
+	}
+
+	bool deactive()
+	{ return ! active(); }
+
+	void deactivate()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		deactivate_();
+	}
+
+	void deactivate_now()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		deactivate_now_();
+	}
+
+	const std::vector< detail::pool_callable > drain()
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		return drain_();
+	}
+
+	bool empty()
+	{ 
+		shared_lock< shared_mutex > lk( mtx_);
+		return empty_();
+	}
+
+	bool full()
+	{ return false; }
+
+	std::size_t size()
+	{ 
+		shared_lock< shared_mutex > lk( mtx_);
+		return size_();
+	}
+
+	void put( item const& itm)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		put_( itm, lk);
+	}
+
+	template< typename Duration >
+	void put(
+		item & itm,
+		Duration const&)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		put_( itm, lk);
+	}
+
+	bool take( detail::pool_callable & ca)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		return take_( ca, lk);
+	}
+
+	template< typename Duration >
+	bool take(
+		detail::pool_callable & ca,
+		Duration const& rel_time)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		return take_( ca, rel_time, lk);
+	}
+
+	bool try_take( detail::pool_callable & ca)
+	{
+		unique_lock< shared_mutex > lk( mtx_);
+		return try_take_( ca);
+	}
+};
+} }
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_UNBOUNDED_CHANNEL_H
diff -urN boost/boost/task/utility.hpp boost-altered/boost/task/utility.hpp
--- boost/boost/task/utility.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/utility.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,125 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)txt)
+
+#ifndef BOOST_TASK_UTILITY_H
+#define BOOST_TASK_UTILITY_H
+
+#include <boost/assert.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/thread_time.hpp>
+
+#include <boost/task/detail/worker.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+namespace boost { namespace this_task
+{
+namespace detail
+{
+struct time_reached
+{
+	system_time	abs_time;
+
+	time_reached( system_time & abs_time_)
+	: abs_time( abs_time_)
+	{}
+
+	bool operator()()
+	{ return get_system_time() >= abs_time; }
+};
+
+class once_false
+{
+private:
+	bool	result_;
+
+public:
+	once_false()
+	: result_( false)
+	{}
+	
+	bool operator()()
+	{
+		if ( ! result_)
+		{
+			result_ = true;
+			return false;
+		}
+		else
+			return true;
+	}
+};
+}
+
+template< typename Pred >
+void reschedule_until( Pred const& pred)
+{
+	task::detail::worker * w( task::detail::worker::tss_get() );
+	BOOST_ASSERT( w);
+	w->reschedule_until( pred);
+}
+
+template< typename Pool >
+Pool & get_pool()
+{
+	task::detail::worker * w( task::detail::worker::tss_get() );
+	BOOST_ASSERT( w);
+	return w->get_pool< Pool >();
+}
+
+inline
+bool runs_in_pool()
+{ return task::detail::worker::tss_get() != 0; }
+
+inline
+thread::id worker_id()
+{
+	task::detail::worker * w( task::detail::worker::tss_get() );
+	BOOST_ASSERT( w);
+	return w->get_id();
+}
+
+inline
+void delay( system_time abs_time)
+{
+	if ( runs_in_pool() )
+	{
+		detail::time_reached t( abs_time);
+		reschedule_until( t);
+	}
+	else
+		this_thread::sleep( abs_time);
+}
+
+template< typename Duration >
+void delay( Duration const& rel_time)
+{ delay( get_system_time() + rel_time); }
+
+inline
+void yield()
+{
+	if ( runs_in_pool() )
+	{
+		detail::once_false t;
+		reschedule_until( t);
+	}
+	else
+		this_thread::yield();
+}
+
+inline
+void interrupt()
+{
+	task::detail::worker * w( task::detail::worker::tss_get() );
+	BOOST_ASSERT( w);
+	w->interrupt();
+	this_thread::interruption_point();
+}
+}}
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_UTILITY_H
diff -urN boost/boost/task/watermark.hpp boost-altered/boost/task/watermark.hpp
--- boost/boost/task/watermark.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task/watermark.hpp	2009-06-30 17:51:46.000000000 -0700
@@ -0,0 +1,52 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_WATER_MARK_H
+#define BOOST_TASK_WATER_MARK_H
+
+#include <cstddef>
+
+#include <boost/task/detail/config.hpp>
+
+#include <boost/config/abi_prefix.hpp>
+
+# if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable:4251 4275)
+# endif
+
+namespace boost { namespace task
+{
+class BOOST_TASK_DECL high_watermark
+{
+private:
+	std::size_t	value_;
+
+public:
+	explicit high_watermark( std::size_t value);
+
+	operator std::size_t () const;
+};
+
+class BOOST_TASK_DECL low_watermark
+{
+private:
+	std::size_t	value_;
+
+public:
+	explicit low_watermark( std::size_t value);
+
+	operator std::size_t () const;
+};
+}}
+
+# if defined(BOOST_MSVC)
+# pragma warning(pop)
+# endif
+
+#include <boost/config/abi_suffix.hpp>
+
+#endif // BOOST_TASK_WATER_MARK_H
diff -urN boost/boost/task.hpp boost-altered/boost/task.hpp
--- boost/boost/task.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/boost/task.hpp	2009-06-30 17:51:43.000000000 -0700
@@ -0,0 +1,32 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TASK_H
+#define BOOST_TASK_H
+
+#include <boost/task/as_sub_task.hpp>
+#include <boost/task/async.hpp>
+#include <boost/task/bounded_channel.hpp>
+#include <boost/task/exceptions.hpp>
+#include <boost/task/fifo.hpp>
+#include <boost/task/future.hpp>
+#include <boost/task/handle.hpp>
+#include <boost/task/meta.hpp>
+#include <boost/task/new_thread.hpp>
+#include <boost/task/own_thread.hpp>
+#include <boost/task/poolsize.hpp>
+#include <boost/task/priority.hpp>
+#include <boost/task/scanns.hpp>
+#include <boost/task/semaphore.hpp>
+#include <boost/task/static_pool.hpp>
+#include <boost/task/smart.hpp>
+#include <boost/task/task.hpp>
+#include <boost/task/unbounded_channel.hpp>
+#include <boost/task/utility.hpp>
+#include <boost/task/watermark.hpp>
+
+#endif // BOOST_TASK_H
+
Binary files boost/libs/task/boost.png and boost-altered/libs/task/boost.png differ
diff -urN boost/libs/task/build/Jamfile.v2 boost-altered/libs/task/build/Jamfile.v2
--- boost/libs/task/build/Jamfile.v2	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/build/Jamfile.v2	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,76 @@
+# Boost.Task Library Build Jamfile
+
+#          Copyright Oliver Kowalke 2009.
+# Distributed under the Boost Software License, Version 1.0.
+#    (See accompanying file LICENSE_1_0.txt or copy at
+#          http://www.boost.org/LICENSE_1_0.txt)
+
+import os ;
+import feature ;
+import indirect ;
+import path ;
+
+project boost/task
+    : source-location
+        ../src
+    : requirements
+        <library>/boost/system//boost_system
+        <library>/boost/thread//boost_thread
+        <link>static:<define>BOOST_TASK_BUILD_LIB=1
+        <link>shared:<define>BOOST_TASK_BUILD_DLL=1
+        <threading>multi
+    : default-build
+        <threading>multi
+    ;
+
+local rule default_taskapi ( )
+{
+    local api = posix ;
+    if [ os.name ] = "NT" { api = win32 ; }
+    return $(api) ;
+}
+
+feature.feature taskapi : posix win32 : propagated ;
+feature.set-default taskapi : [ default_taskapi ] ;
+
+alias task_sources
+    : ## win32 sources ##
+	guard.cpp
+	interrupter.cpp
+	pool_callable.cpp
+	poolsize.cpp
+	scanns.cpp
+	semaphore_windows.cpp
+	watermark.cpp
+	worker.cpp
+	worker_group.cpp
+	wsq.cpp
+    : ## requirements ##
+      <taskapi>win32
+    ;
+
+alias task_sources
+    : ## posix sources ##
+	guard.cpp
+	interrupter.cpp
+	pool_callable.cpp
+	poolsize.cpp
+	scanns.cpp
+	semaphore_posix.cpp
+	watermark.cpp
+	worker.cpp
+	worker_group.cpp
+	wsq.cpp
+    : ## requirements ##
+      <taskapi>posix
+    ;
+
+explicit task_sources ;
+
+lib boost_task
+    : task_sources
+    : <link>shared:<define>BOOST_TASK_USE_DLL=1
+      <link>static:<define>BOOST_TASK_USE_LIB=1
+   ;
+
+boost-install boost_task ;
diff -urN boost/libs/task/doc/acknowledgements.qbk boost-altered/libs/task/doc/acknowledgements.qbk
--- boost/libs/task/doc/acknowledgements.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/acknowledgements.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,14 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:acknowledgements Appendix B: Acknowledgments]
+
+I'd like to thank Vicente J. Botet Escriba for his comments and contributions (this_task::reschedule_until, this_task::delay, this_task::yield) as well Anthony Williams and Braddock Gaskill for their future libraries.
+
+
+[endsect]
diff -urN boost/libs/task/doc/appendices.qbk boost-altered/libs/task/doc/appendices.qbk
--- boost/libs/task/doc/appendices.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/appendices.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,19 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section Appendices]
+
+[/ [include rationale.qbk] ]
+[include todo.qbk]
+[include acknowledgements.qbk]
+
+
+[endsect]
+
+
+
diff -urN boost/libs/task/doc/as_sub_task.qbk boost-altered/libs/task/doc/as_sub_task.qbk
--- boost/libs/task/doc/as_sub_task.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/as_sub_task.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,28 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:as_sub_task Execute as sub-task]
+
+__as_sub_task__ is a convenient way to execute a __sub_task__. If the parent task is executed inside a __thread_pool__ the __sub_task__ is put into the local-queue of the
+__worker_thread__ in the other case the __sub_task__ will be executed in a new thread. __as_sub_task__ is used as default __ep__ for __fn_async__,
+
+
+``
+	boost::task::task< long > t( fibonacci, 10);
+
+	boost::task::handle< long > h(
+		boost::task::async(
+			boost::move( t),
+			boost::task::as_sub_task() ) );
+``
+
+
+[endsect] 
+ 
+ 
+ 
diff -urN boost/libs/task/doc/async_completion_token.qbk boost-altered/libs/task/doc/async_completion_token.qbk
--- boost/libs/task/doc/async_completion_token.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/async_completion_token.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,17 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:async_completion_token Asynchronous completion token]
+
+The __act__ dispatches processing actions (__tasks__) in response to the completion of asynchronous operations. __act__ uniquely identifies
+the task and state necessary to process the result of the operation [footnote see [@http://www.cs.wustl.edu/~schmidt/PDF/ACT.pdf 'Asynchronous Completion Token'], Douglas Schmidt]. 
+
+[include handle.qbk]
+
+
+[endsect] 
diff -urN boost/libs/task/doc/async.qbk boost-altered/libs/task/doc/async.qbk
--- boost/libs/task/doc/async.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/async.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,47 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:async Asynchronous execution] 
+
+Function __fn_async__ applies the moved __task__ to the __ep__ which executes the __task__ (for this purpose __ep__ is 
+required to provide `handle< R > operator()( task< R > && t)`).
+__fn_async__ accepts two arguments - the first is an __task__ object and the second an __ep__. For the second argument 
+__as_sub_task__ is used per default. The function returns a __handle__ which controls the submitted __task__.
+
+
+``
+	long fibonacci( long n)
+	{
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+		return k1;
+	}
+
+	void main()
+	{
+		// task computing fibonacci(10)
+		boost::task< long > t( fibonacci, 10);
+
+		// move the task to executor
+		boost::task::handle< long > h(
+			boost::task::async(
+				 boost::move( t) );
+
+		// access the result
+		std::cout << "fibonacci(10) == " << h.get() << std::endl;
+	}
+``
+
+[endsect]
Binary files boost/libs/task/doc/boost.png and boost-altered/libs/task/doc/boost.png differ
diff -urN boost/libs/task/doc/boost_task.qbk boost-altered/libs/task/doc/boost_task.qbk
--- boost/libs/task/doc/boost_task.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/boost_task.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,139 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[library Boost.Task
+    [quickbook 1.4]
+    [authors [Kowalke, Oliver]]
+    [copyright 2009 Oliver Kowalke]
+    [purpose C++ Library for asynchronous execution of tasks]
+    [category text]
+    [license
+        Distributed under the Boost Software License, Version 1.0.
+        (See accompanying file LICENSE_1_0.txt or copy at
+        [@http://www.boost.org/LICENSE_1_0.txt])
+    ]
+]
+
+[def __boost__ [*boost-1.39.0]]
+[def __boost_task__ [*Boost.Task]]
+[def __boost_thread__ [@http://www.boost.org/libs/thread [*Boost.Thread]]]
+[def __boost_future__ [@http://www.justsoftwaresolutions.co.uk/threading/updated-implementation-of-c++-futures-3.html [*Boost.Future]]]
+
+[template link_async[link_text] [link boost_task.async [link_text]]]
+[template link_channel[link_text] [link boost_task.pool.channel [link_text]]]
+[template link_forkjoin[link_text] [link boost_task.pool.forkjoin [link_text]]]
+[template link_handle[link_text] [link boost_task.handle [link_text]]]
+[template link_own_thread[link_text] [link boost_task.own_thread [link_text]]]
+[template link_pool[link_text] [link boost_task.pool [link_text]]]
+[template link_task[link_text] [link boost_task.task [link_text]]]
+[template link_work_stealing[link_text] [link boost_task.pool.work_stealing [link_text]]]
+
+[def __shared_future__ `boost::shared_future`]
+[def __thread__ `boost::thread`]
+[def __thread_id__ `boost::thread::id`]
+
+[def __hardware_concurrency__ `boost::thread::hardware_concurrency()`]
+
+[def __as_sub_task__ `boost::task::as_sub_task`]
+[def __attribute_type__ `boost::task::attribute_type`]
+[def __bounded_channel__ `boost::task::bounded_channel`]
+[def __dynamic_pool__ `boost::task::dynamic_pool`]
+[def __handle__ `boost::task::handle`]
+[def __has_attribute__ `boost::task::has_attribute`]
+[def __hwm__ `boost::task::high_watermark`]
+[def __lwm__ `boost::task::low_watermark`]
+[def __new_thread__ `boost::task::new_thread`]
+[def __own_thread__ `boost::task::own_thread`]
+[def __pool_size__ `boost::task::poolsize`]
+[def __priority__ `boost::task::priority`]
+[def __replace_oldest__ `boost::task::replace_oldest`]
+[def __static_pool__ `boost::task::static_pool`]
+[def __system_time__ `boost::task::system_time`]
+[def __take_oldest__ `boost::task::take_oldest`]
+[def __task__ `boost::task::task`]
+[def __task_interrupted__ `boost::task::task_interrupted`]
+[def __unbounded_channel__ `boost::task::unbounded_channel`]
+
+[def __waitfor_all__ `boost::task::waitfor_all()`]
+[def __waitfor_any__ `boost::task::waitfor_any()`]
+
+[def __fn_delay__ `boost::this_task::delay()`]
+[def __fn_get_pool__ `boost::this_task::get_pool()`]
+[def __fn_tt_interrupt__ `boost::this_task::interrupt()`]
+[def __fn_interruption_requested__ `boost::this_thread::interruption_requested()`]
+[def __fn_make_task__ `boost::task::make_task()`]
+[def __fn_reschedule_until__ `boost::this_task::reschedule_until()`]
+[def __fn_runs_in_pool__ `boost::this_task::runs_in_pool()`]
+[def __fn_worker_id__ `boost::this_task::worker_id()`]
+[def __fn_yield__ `boost::this_task::yield()`]
+
+[def __fn_async__ `boost::task::async()`]
+
+[def __fn_active__ `active()`]
+[def __fn_bind_to_processors__ `bind_to_processors()`]
+[def __fn_closed__ `close()`]
+[def __fn_clear__ `clear()`]
+[def __fn_empty__ `empty()`]
+[def __fn_get__ `get()`]
+[def __fn_get_future__ `get_future()`]
+[def __fn_has_value__ `has_value()`]
+[def __fn_has_exception__ `has_exception()`]
+[def __fn_idle__ `idle()`]
+[def __fn_interrupt__ `interrupt()`]
+[def __fn_interrupt_and_wait__ `interrupt_and_wait()`]
+[def __fn_interrupt_and_wait_for__ `interrupt_and_wait_for()`]
+[def __fn_interrupt_and_wait_until__ `interrupt_and_wait_until()`]
+[def __fn_interruption_requested__ `interruption_requested()`]
+[def __fn_is_ready__ `is_ready()`]
+[def __fn_operator__ `operator()()`]
+[def __fn_pending__ `pending()`]
+[def __fn_size__ `size()`]
+[def __fn_shutdown__ `shutdown()`]
+[def __fn_shutdown_now__ `shutdown_now()`]
+[def __fn_wait__ `wait()`]
+[def __fn_wait_for__ `wait_for()`]
+[def __fn_wait_until__ `wait_until()`]
+
+
+[def __act__ ['asynchronous-completion-token]]
+[def __ep__ ['execution-policy]]
+[def __eps__ ['execution-policies]]
+[def __blocked__ ['blocked]]
+[def __callable__ ['callable]]
+[def __channel__ ['channel]]
+[def __coop_task__ ['cooperative task]]
+[def __duration__ ['Duration]]
+[def __fork_join__ ['fork/join]]
+[def __interruption_point__ ['interruption-point]]
+[def __interruption_points__ ['interruption-points]]
+[def __task_id__ ['task-id]]
+[def __thread_pool__ ['thread-pool]]
+[def __thread_pools__ ['thread-pools]]
+[def __sub_task__ ['sub-task]]
+[def __sub_tasks__ ['sub-tasks]]
+[def __work_item__ ['work-item]]
+[def __work_items__ ['work-items]]
+[def __work_stealing__ ['work-stealing]]
+[def __worker_queue__ ['worker-queue]]
+[def __worker_thread__ ['worker-thread]]
+[def __worker_threads__ ['worker-threads]]
+
+
+[include overview.qbk]
+[include introduction.qbk]
+[include task.qbk]
+[include handle.qbk]
+[include async.qbk]
+[include own_thread.qbk]
+[include new_thread.qbk]
+[include pool.qbk]
+[include as_sub_task.qbk]
+[include utilities.qbk]
+[include meta_functions.qbk]
+[include reference.qbk]
+[include appendices.qbk]
diff -urN boost/libs/task/doc/boost_task.xml boost-altered/libs/task/doc/boost_task.xml
--- boost/libs/task/doc/boost_task.xml	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/boost_task.xml	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,5459 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN" "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
+<library id="boost_task" name="Boost.Task" dirname="boost_task" last-revision="$Date: 2009/06/23 18:15:41 $"
+ xmlns:xi="http://www.w3.org/2001/XInclude">
+  <libraryinfo>
+    <authorgroup>
+    <author>
+      <firstname>Oliver</firstname> <surname>Kowalke</surname>
+    </author>
+    </authorgroup>
+    <copyright>
+      <year>2009</year> <holder>Oliver Kowalke</holder>
+    </copyright>
+    <legalnotice>
+      <para>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
+      </para>
+    </legalnotice>
+    <librarypurpose>
+      C++ Library for asynchronous execution of tasks
+    </librarypurpose>
+    <librarycategory name="category:text"></librarycategory>
+  </libraryinfo>
+  <title>Boost.Task</title>
+  <section id="boost_task.overview">
+    <title><link linkend="boost_task.overview"> Overview</link></title>
+    <para>
+      <emphasis role="bold">Boost.Task</emphasis> provides a framework for parallel
+      execution of tasks (a task is a small unit of code that can be executed independently).
+    </para>
+    <itemizedlist>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase></code>, a <emphasis>callable</emphasis> representing
+        a fine-grained work-item:
+        <itemizedlist>
+          <listitem>
+            <code><phrase role="keyword">operator</phrase><phrase role="special">()()</phrase></code>
+            to execute the fine-grained work-item
+          </listitem>
+          <listitem>
+            <code><phrase role="identifier">get_future</phrase><phrase role="special">()</phrase></code>
+            providing an <emphasis>asynchronous-completion-token</emphasis> in order
+            to pass the result (values, exceptions) back to initiator
+          </listitem>
+        </itemizedlist>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">handle</phrase></code>, works as a <emphasis>asynchronous-completion-token</emphasis>
+        of executed task:
+        <itemizedlist>
+          <listitem>
+            <code><phrase role="identifier">interrupt</phrase><phrase role="special">()</phrase></code>,
+            <code><phrase role="identifier">interrupt_and_wait</phrase><phrase role="special">()</phrase></code>,
+            ... allow to cancel an cooperative task
+          </listitem>
+          <listitem>
+            interface of the <emphasis>asynchronous-completion-token</emphasis>:
+            <itemizedlist>
+              <listitem>
+                <code><phrase role="identifier">get</phrase><phrase role="special">()</phrase></code>
+                retrieve value or exception of task execution
+              </listitem>
+              <listitem>
+                <code><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase></code>
+                test if task was executed
+              </listitem>
+              <listitem>
+                <code><phrase role="identifier">wait</phrase><phrase role="special">()</phrase></code>,
+                <code><phrase role="identifier">wait_for</phrase><phrase role="special">()</phrase></code>
+                and <code><phrase role="identifier">wait_until</phrase><phrase role="special">()</phrase></code>
+                block until task is executed and the result is set
+              </listitem>
+            </itemizedlist>
+          </listitem>
+          <listitem>
+            <code><phrase role="identifier">get_future</phrase><phrase role="special">()</phrase></code>
+            returns reference to internal <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">shared_future</phrase></code>
+          </listitem>
+          <listitem>
+            functions <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">waitfor_all</phrase><phrase role="special">()</phrase></code>/<code><phrase
+            role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">waitfor_any</phrase><phrase role="special">()</phrase></code>
+            to wait for all or any handles
+          </listitem>
+        </itemizedlist>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">async</phrase><phrase role="special">()</phrase></code>,
+        executes a task by means of <emphasis>execution-policies</emphasis>
+      </listitem>
+      <listitem>
+        <emphasis>execution-policy</emphasis> models:
+        <itemizedlist>
+          <listitem>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">own_thread</phrase></code>: executes task in current
+            thread
+          </listitem>
+          <listitem>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">new_thread</phrase></code>: executes task in a newly-created
+            thread (thread will be destroyed after completion)
+          </listitem>
+          <listitem>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">as_sub_task</phrase></code>: executes task in newly-created
+            thread or in a pool of <emphasis>worker-threads</emphasis> depending
+            on whether the parent-task is already executed in a <emphasis>thread-pool</emphasis>
+          </listitem>
+          <listitem>
+            <emphasis>thread-pool</emphasis>: task gets executed by a <emphasis>worker-thread</emphasis>
+            of a custom <emphasis>thread-pool</emphasis> (for instance with priority
+            or smart scheduling)
+          </listitem>
+        </itemizedlist>
+      </listitem>
+      <listitem>
+        <emphasis>thread-pools</emphasis> with work-stealing algorithm and for/join
+        semantics
+      </listitem>
+      <listitem>
+        support of forking and joining sub-tasks
+        <itemizedlist>
+          <listitem>
+            better performance
+          </listitem>
+          <listitem>
+            no deadlock because of inline-execution of sub-tasks
+          </listitem>
+          <listitem>
+            detects if parent-task runs in a <emphasis>thread-pool</emphasis> - the
+            appropriate mechanism for executing the sub-tasks is choosen
+          </listitem>
+        </itemizedlist>
+      </listitem>
+    </itemizedlist>
+    <para>
+      In order to use the classes and functions described here, you can either include
+      the specific headers specified by the descriptions of each class or function,
+      or include the master library header:
+    </para>
+    <para>
+      
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+</programlisting>
+    </para>
+    <para>
+      which includes all the other headers in turn.
+    </para>
+    <para>
+      Used namespaces are:
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase>
+<phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_task</phrase>
+</programlisting>
+    </para>
+    <anchor id="boost_task.overview.example"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.overview.example">Example</link>
+    </bridgehead>
+    <para>
+      
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// create a thread-pool
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">fifo</phrase>
+		<phrase role="special">&gt;</phrase>
+	<phrase role="special">&gt;</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">5</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// create two tasks, computing fibonacci numbers
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">,</phrase> <phrase role="number">5</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// execute tasks in thread-pool
+</phrase>	<phrase role="comment">// move tasks ownership to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">);</phrase>
+
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;h1: is ready == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;h2: is ready == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+
+	<phrase role="comment">// wait for completion of both tasks
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">h1</phrase><phrase role="special">,</phrase> <phrase role="identifier">h2</phrase><phrase role="special">);</phrase>
+
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;h1: is ready == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;h2: is ready == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;h1: has value == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">has_value</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;h2: has value == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">has_value</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;h1: has exception == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">has_exception</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;h2: has exception == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">has_exception</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+
+	<phrase role="comment">// get results
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(5) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <anchor id="boost_task.overview.references"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.overview.references">References</link>
+    </bridgehead>
+    <itemizedlist>
+      <listitem>
+        N2185: Proposed Text for Parallel Task Execution <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2185.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2185.html</ulink>
+        written by Peter Dimov.
+      </listitem>
+      <listitem>
+        N2276: Thread Pools and Futures <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2276.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2276.html</ulink>
+        written by Anthony Williams.
+      </listitem>
+      <listitem>
+        N2802: A plea to reconsider detach-on-destruction for thread objects <ulink
+        url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html</ulink>
+        written by Hans-J. Boehm.
+      </listitem>
+      <listitem>
+        N2880: C++ object lifetime interactions with the threads API <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2880.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2880.html</ulink>
+        written by Hans-J. Boehm and Lawrence Crowl.
+      </listitem>
+      <listitem>
+        <ulink url="http://herbsutter.wordpress.com">'Sutters Mill'</ulink> by
+        Herb Sutter
+      </listitem>
+      <listitem>
+        mailing list of C++ standard committee's Library Working Group
+      </listitem>
+    </itemizedlist>
+    <note>
+      <para>
+        <emphasis role="bold">Boost.Task</emphasis> uses <ulink url="http://www.justsoftwaresolutions.co.uk/threading/updated-implementation-of-c++-futures-3.html"><emphasis
+        role="bold">Boost.Future</emphasis></ulink> from Anthony Williams (will be
+        integrated in some of the next releases of <ulink url="http://www.boost.org/libs/thread"><emphasis
+        role="bold">Boost.Thread</emphasis></ulink>).
+      </para>
+    </note>
+    <note>
+      <para>
+        Please note that <emphasis role="bold">Boost.Task</emphasis> is not optimized
+        yet.
+      </para>
+    </note>
+    <anchor id="boost_task.overview.tested_platforms"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.overview.tested_platforms">Tested Platforms</link>
+    </bridgehead>
+    <para>
+      <emphasis role="bold">Boost.Task</emphasis> has been tested on the following
+      platforms and compilers:
+    </para>
+    <itemizedlist>
+      <listitem>
+        Debian GNU/Linux 2.6.29.2 (x86_64), GCC 4.3.3
+      </listitem>
+      <listitem>
+        Ubuntu GNU/Linux 2.6.28.11 (x86), GCC 4.3.3
+      </listitem>
+      <listitem>
+        FreeBSD 7.2 (x86), GCC 4.2.1
+      </listitem>
+      <listitem>
+        OpenSolaris 2009.06 (x86_64), GCC 4.3.2
+      </listitem>
+      <listitem>
+        Windows XP Professional (x86), MSVC 9.0
+      </listitem>
+    </itemizedlist>
+    <anchor id="boost_task.overview.how_to_build_and_install"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.overview.how_to_build_and_install">How to build and
+      install</link>
+    </bridgehead>
+    <itemizedlist>
+      <listitem>
+        download the sources form <ulink url="http://www.boost-consulting.com/vault/index.php?directory=Concurrent%20Programming">Boost
+        Vault</ulink> or the latest development version from <ulink url="https://svn.boost.org/svn/boost/sandbox/task/">boost-sandbox</ulink>
+      </listitem>
+      <listitem>
+        extract the archive into the boost-source directory
+      </listitem>
+      <listitem>
+        call <emphasis>'bjam toolset=&lt;compiler-name&gt; --with-task install'</emphasis>
+        in order to build and install <emphasis role="bold">Boost.Task</emphasis>
+      </listitem>
+    </itemizedlist>
+  </section>
+  <section id="boost_task.motivation">
+    <title><link linkend="boost_task.motivation"> Motivation</link></title>
+    <para>
+      To speed-up computer-bound work and/or increase the computation-throughput
+      is a common motivation for parallelizing a program. Especially for interactive
+      applications that have to process user input while performing some background
+      tasks responsivness is very important. Parallelizing a program requires partitioning
+      the program into smaller chunks that can run in parallel. The code can scale
+      as the hardware gets better without changing the code.
+    </para>
+    <para>
+      The evolution from one-core to many-core architectures and the usage of threads
+      (of course processes fit too) support this paradigm.
+    </para>
+    <note>
+      <para>
+        <quote>You can have multithreading on a single core machine, but you can
+        only have parallelism on a multi core machine ... .</quote> -- Daniel Moth
+        <footnote>
+          <para>
+            more to read at Daniel's <ulink url="http://www.danielmoth.com/Blog/2008/11/threadingconcurrency-vs-parallelism.html">blog</ulink>
+          </para>
+        </footnote>
+      </para>
+    </note>
+    <para>
+      <emphasis role="bold">Boost.Task</emphasis> provides a framework to utilize
+      the available hardware and provide a way for efficient asynchronous processing
+      of time consuming operations. The framework provides some <emphasis>execution-policies</emphasis>,
+      like <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase></code>,
+      in order to execute the task asynchronously in another execution context (<emphasis
+      role="bold">Boost.Task</emphasis> uses preemptible threads for this purpose).
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">print</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase> <phrase role="identifier">printf</phrase><phrase role="special">(</phrase><phrase role="string">&quot;%s\n&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">msg</phrase><phrase role="special">.</phrase><phrase role="identifier">c_str</phrase><phrase role="special">()</phrase> <phrase role="special">);</phrase> <phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// task, to be executed asynchronously
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">void</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">print</phrase><phrase role="special">,</phrase> <phrase role="string">&quot;Hello World!&quot;</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// execute task in newly-created thread
+</phrase>	<phrase role="comment">// move task ownership to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <para>
+      In order to manage the task <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">async</phrase><phrase role="special">()</phrase></code> returns
+      a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase></code>
+      (associated with the submitted task). It functions as a <emphasis>asynchronous-completion-token</emphasis>
+      - that means it transfers the result of the execution back to the caller thread.
+    </para>
+    <para>
+      
+<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">echo</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// task returning the submitted string
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">echo</phrase><phrase role="special">,</phrase> <phrase role="string">&quot;Hello World!&quot;</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// execute task in newly-created thread
+</phrase>	<phrase role="comment">// move task ownership to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// wait until task has finished and return the result
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <para>
+      The task can also be interrupted via <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">handle</phrase></code> if it is a so-called <link linkend="boost_task.task"><emphasis>cooperative
+      task</emphasis></link>.
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">long_running</phrase><phrase role="special">(</phrase>  <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">time_duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">rel_time</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase role="identifier">sleep</phrase><phrase role="special">(</phrase> <phrase role="identifier">rel_time</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// create a long runing task
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">void</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">long_running</phrase><phrase role="special">,</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">millisec</phrase><phrase role="special">(</phrase> <phrase role="number">500</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// execute task in newly-created thread
+</phrase>	<phrase role="comment">// move task ownership to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// requests interruption of task
+</phrase>	<phrase role="comment">// returns immediately
+</phrase>	<phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">interrupt</phrase><phrase role="special">();</phrase>
+
+	<phrase role="comment">// access the result
+</phrase>	<phrase role="comment">// task_interrupted exeception will be thrown
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>		
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <para>
+      Beside <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase></code>
+      (which creates a new task for each submitted task - the thread will be joined
+      by <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase></code>)
+      <emphasis role="bold">Boost.Task</emphasis> provides <link linkend="boost_task.pool"><emphasis>thread-pools</emphasis></link>
+      to prevent the overhead of thread creation and destruction of threads for each
+      task (<emphasis>thread-pools</emphasis> can be customized).
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">&lt;</phrase> <phrase role="number">2</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">else</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">+</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">long</phrase> <phrase role="identifier">parallel_fib</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">,</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">cutof</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">cutof</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">else</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="comment">// create a sub-task calculating fibonacci(n-1)
+</phrase>		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">cutof</phrase><phrase role="special">);</phrase>
+		<phrase role="comment">// create a sub-task calculating fibonacci(n-2)
+</phrase>		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">2</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">cutof</phrase><phrase role="special">);</phrase>
+
+		<phrase role="comment">// fork two sub-tasks
+</phrase>		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+				<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">),</phrase>
+				<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_task</phrase><phrase role="special">::</phrase><phrase role="identifier">get_pool</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+				<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">),</phrase>
+				<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_task</phrase><phrase role="special">::</phrase><phrase role="identifier">get_pool</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+		<phrase role="comment">// join the results of both sub-tasks
+</phrase>		<phrase role="keyword">return</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">+</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">();</phrase>
+	<phrase role="special">}</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// create a thread-pool with five worker-threads
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">fifo</phrase>
+		<phrase role="special">&gt;</phrase>
+	<phrase role="special">&gt;</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">5</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// create task computing fibonacci-number for 10
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+		<phrase role="number">10</phrase><phrase role="special">,</phrase>
+		<phrase role="number">5</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// execute task in a thread-pool
+</phrase>	<phrase role="comment">// move task ownership to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// access the result
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <para>
+      With function <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">this_task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">runs_in_pool</phrase><phrase role="special">()</phrase></code>
+      a task can detect if it is executed inside a <emphasis>thread-pool</emphasis>.
+      <emphasis>sub-tasks</emphasis> arecreated by <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">as_sub_task</phrase></code>. Where the <emphasis>sub-task</emphasis>
+      is executed by a new thread if the parent task is not executed inside a <emphasis>thread-pool</emphasis>.
+      In the other case the <emphasis>sub-task</emphasis> is put into the local
+      <emphasis>worker-queue</emphasis> which enables <link linkend="boost_task.pool.work_stealing"><emphasis>work-stealing</emphasis></link>
+      and <link linkend="boost_task.pool.forkjoin">inline execution</link> of tasks.
+    </para>
+    <para>
+      
+<programlisting><phrase role="comment">// create a long runing task
+</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase>
+	<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+	<phrase role="number">10</phrase><phrase role="special">,</phrase>
+	<phrase role="number">5</phrase><phrase role="special">);</phrase>
+
+<phrase role="comment">// move task ownership to executor
+</phrase><phrase role="comment">// sub-task executed in a new thread or inside the thread-pool
+</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">as_sub_task</phrase><phrase role="special">()</phrase> <phrase role="special">);</phrase>
+</programlisting>
+    </para>
+  </section>
+  <section id="boost_task.task">
+    <title><link linkend="boost_task.task"> Task</link></title>
+    <para>
+      A task is a chunk of code that can be executed independently.
+    </para>
+    <para>
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase></code>
+      represents a <emphasis>callable</emphasis> (provides <code><phrase role="keyword">operator</phrase><phrase
+      role="special">()()</phrase></code>) object containing the unit of code to
+      be execute by a <emphasis>execution-policy</emphasis>. Function <code><phrase
+      role="identifier">get_future</phrase><phrase role="special">()</phrase></code>
+      returns a <emphasis>asynchronous-completion-token</emphasis> allowing to wait
+      for the completion of the computation of the task, for getting the result of
+      a computation or for transfering exceptions. <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code> supports move semantics (moving ownership).
+    </para>
+    <anchor id="boost_task.task.cooperative_task_and_interruption"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.task.cooperative_task_and_interruption">Cooperative
+      task and interruption</link>
+    </bridgehead>
+    <para>
+      Sometimes it is desired to stop a running task if it is no longer needed. In
+      this case the thread is not killed - it stops only at well-defined points (<emphasis>interruption-points</emphasis>)
+      its execution. In the context of task-interruption a task is known as cooperative
+      if it checks for an interruption request between two <emphasis>interruption-points</emphasis>
+      via <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">interruption_requested</phrase><phrase role="special">()</phrase></code>
+      <footnote>
+        <para>
+          see <ulink url="http://www.ddj.com/architect/207100682">'Interrupt Politely'</ulink>,
+          Herb Sutter
+        </para>
+      </footnote>
+      .
+    </para>
+    <para>
+      <emphasis>interruption-points</emphasis> are:
+    </para>
+    <itemizedlist>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">thread</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">join</phrase><phrase role="special">()</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">thread</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">timed_join</phrase><phrase role="special">()</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">condition_variable</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">wait</phrase><phrase role="special">()</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">condition_variable</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">timed_wait</phrase><phrase role="special">()</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">condition_variable_any</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">wait</phrase><phrase role="special">()</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">condition_variable_any</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">timed_wait</phrase><phrase role="special">()</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">thread</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">sleep</phrase><phrase role="special">()</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">sleep</phrase><phrase role="special">()</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">interruption_point</phrase><phrase role="special">()</phrase></code>
+      </listitem>
+    </itemizedlist>
+    <para>
+      A <emphasis>interruption-point</emphasis> throws <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task_interrupted</phrase></code> if an interruption was requested.
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">cooperative</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// interruption point
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase role="identifier">interruption_point</phrase><phrase role="special">();</phrase>
+	
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="comment">// check if interruption was requested
+</phrase>		<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase role="identifier">interruption_requested</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase>
+			<phrase role="keyword">return</phrase><phrase role="special">;</phrase>
+			
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+	
+	<phrase role="comment">// interruption point
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase role="identifier">interruption_point</phrase><phrase role="special">();</phrase>
+	
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// task for computing fibonacci-number
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">cooperative</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// execute task in new thread
+</phrase>	<phrase role="comment">// move task ownership to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// interrupt task an wait until
+</phrase>	<phrase role="comment">// the task is removed by the worker-thread
+</phrase>	<phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">interrupt_and_wait</phrase><phrase role="special">();</phrase>
+
+	<phrase role="comment">// access the result
+</phrase>	<phrase role="comment">// throws boost::task::task_interrupted
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <anchor id="boost_task.task.exceptions"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.task.exceptions">Exceptions</link>
+    </bridgehead>
+    <para>
+      Exceptions thrown by <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code> are transported by the <emphasis>asynchronous-completion-token</emphasis>.
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">throwing</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="special">...</phrase>
+	<phrase role="keyword">throw</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">domain_error</phrase><phrase role="special">(</phrase><phrase role="string">&quot;domain error&quot;</phrase><phrase role="special">);</phrase>
+	<phrase role="special">...</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// create task throwing std::domain_error
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase> <phrase role="keyword">void</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">throwing</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// execute task asynchron
+</phrase>	<phrase role="comment">// move task ownership to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">void</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// wait for task completion
+</phrase>	<phrase role="comment">// throws std::domain_error
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">wait</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <para>
+      Exceptions rethrown by type are:
+    </para>
+    <itemizedlist>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">bad_alloc</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">bad_cast</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">bad_exception</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">bad_typeid</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">domain_error</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">invalid_argument</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">ios_base</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">failure</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">length_error</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">logic_error</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">out_of_range</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">overflow_error</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">range_error</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">runtime_error</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">underflow_error</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">exception</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">future_already_set</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">future_cancel</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">invalid_thread_argument</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">lock_error</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">broken_task</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">pool_moved</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task_already_executed</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task_interrupted</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task_moved</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task_interrupted</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task_task_rejected</phrase></code>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task_unitialized</phrase></code>
+      </listitem>
+    </itemizedlist>
+    <anchor id="boost_task.task.parent_task"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.task.parent_task">Parent task</link>
+    </bridgehead>
+    <para>
+      Top-level tasks have no parent. A parent task can create child tasks when it
+      creates another task by using <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">as_sub_task</phrase></code> as <emphasis>execution-policy</emphasis>.
+      These children are implicitly treated as <emphasis>sub-tasks</emphasis> of
+      the larger task. It is assumed that that <emphasis>sub-tasks</emphasis> can
+      be executed in any order because only overall operation speed matters (enabling
+      strategies for fast execution of unordered <emphasis>work-items</emphasis>
+      as <link linkend="boost_task.pool.work_stealing"><emphasis>work-stealing</emphasis></link>).
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">&lt;</phrase> <phrase role="number">2</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">else</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">+</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">long</phrase> <phrase role="identifier">parallel_fib</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">,</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">cutof</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">cutof</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">else</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="comment">// sub-task for computing fibonacci(n-1)
+</phrase>		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">cutof</phrase><phrase role="special">);</phrase>
+		<phrase role="comment">// sub-task for computing fibonacci(n-2)
+</phrase>		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">2</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">cutof</phrase><phrase role="special">);</phrase>
+
+		<phrase role="comment">// submit a sub-tasks to thread-pool
+</phrase>		<phrase role="comment">// move task ownership to executor
+</phrase>		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+				<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+				<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+		<phrase role="comment">// computing fibonacci(n) by
+</phrase>		<phrase role="comment">// joining results of both sub-tasks
+</phrase>		<phrase role="keyword">return</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">+</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">();</phrase>
+	<phrase role="special">}</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// create thread-pool with five worker-threads
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">fifo</phrase>
+		<phrase role="special">&gt;</phrase>
+	<phrase role="special">&gt;</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">5</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// create task computing fibonacci-number for 10
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+		<phrase role="number">10</phrase><phrase role="special">,</phrase>
+		<phrase role="number">5</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// execute task asynchron in thread-pool
+</phrase>	<phrase role="comment">// move task ownership to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// access result
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+  </section>
+  <section id="boost_task.handle">
+    <title><link linkend="boost_task.handle"> Handle</link></title>
+    <para>
+      The <emphasis>asynchronous-completion-token</emphasis> dispatches tasks in
+      response to the completion of asynchronous operations. <emphasis>asynchronous-completion-token</emphasis>
+      uniquely identifies the task and state necessary to process the result of the
+      operation
+      <footnote>
+        <para>
+          see <ulink url="http://www.cs.wustl.edu/~schmidt/PDF/ACT.pdf">'Asynchronous
+          Completion Token'</ulink>, Douglas Schmidt
+        </para>
+      </footnote>
+      .
+    </para>
+    <para>
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase></code>
+      represents an <emphasis>asynchronous-completion-token</emphasis>. It will be
+      returned by <link linkend="boost_task.async"><code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">async</phrase><phrase role="special">()</phrase></code></link>
+      and is associated with the submitted <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code>.
+    </para>
+    <anchor id="boost_task.handle.asynchronous_completion_token_interface"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.handle.asynchronous_completion_token_interface">Asynchronous
+      completion token interface</link>
+    </bridgehead>
+    <para>
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase></code>
+      implements an interface in order to check the state of computation and to transfer
+      the result.
+    </para>
+    <itemizedlist>
+      <listitem>
+        <code><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase></code>:
+        test if result is set
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">has_value</phrase><phrase role="special">()</phrase></code>:
+        test if value-result is set
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">has_exception</phrase><phrase role="special">()</phrase></code>:
+        test if exception-result is set
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">get</phrase><phrase role="special">()</phrase></code>:
+        return value-result or throw the exception-result
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">wait</phrase><phrase role="special">()</phrase></code>:
+        wait until result is set
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">wait_for</phrase><phrase role="special">()</phrase></code>:
+        wait until result is set or time-duration has elapsed
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">wait_until</phrase><phrase role="special">()</phrase></code>:
+        wait until result ist set or time-point has elapsed
+      </listitem>
+    </itemizedlist>
+    <para>
+      
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// create task
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// move task ownership to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;is ready == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+
+	<phrase role="comment">// wait for task completion
+</phrase>	<phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">wait</phrase><phrase role="special">();</phrase>
+
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;has value == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">has_value</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;has exception == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">has_exception</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+
+	<phrase role="comment">// return result
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <anchor id="boost_task.handle.task_interruption"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.handle.task_interruption">Task interruption</link>
+    </bridgehead>
+    <para>
+      Each invokation of <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase
+      role="special">()</phrase></code> returns an <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">handle</phrase></code> which allows to control the associated
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase></code>
+      (passed to <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase
+      role="special">()</phrase></code>). This includes the ability to interrupt
+      an <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase></code>
+      if it is cooperative. Cooperative means that the <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code> contains <emphasis>interruption-points</emphasis>
+      or checks for interruption requests
+      <footnote>
+        <para>
+          see <ulink url="http://www.ddj.com/architect/207100682">'Interrupt Politely'</ulink>,
+          Herb Sutter
+        </para>
+      </footnote>
+      .
+    </para>
+    <itemizedlist>
+      <listitem>
+        <code><phrase role="identifier">interrupt</phrase><phrase role="special">()</phrase></code>:
+        interrupt <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase></code> and return immediately
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">interrupt_and_wait</phrase><phrase role="special">()</phrase></code>:
+        interrupt and wait until <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase></code>
+        was removed from <emphasis>worker-thread</emphasis>
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">interrupt_and_wait_for</phrase><phrase role="special">()</phrase></code>:
+        interrupt and wait until <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase></code>
+        was removed from <emphasis>worker-thread</emphasis> or time duration has
+        elapsed
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">interrupt_and_wait_until</phrase><phrase
+        role="special">()</phrase></code>: interrupt and wait until <code><phrase
+        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase></code> was removed from <emphasis>worker-thread</emphasis>
+        or time point has reached
+      </listitem>
+      <listitem>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">interruption_requested</phrase><phrase role="special">()</phrase></code>:
+        return bool if interruption was requested
+      </listitem>
+    </itemizedlist>
+    <para>
+      
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">cooperative</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase role="identifier">interruption_point</phrase><phrase role="special">();</phrase> <phrase role="comment">// interruption point
+</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase role="identifier">interruption_requested</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase>	<phrase role="comment">// check if interruption was requested
+</phrase>			<phrase role="keyword">return</phrase><phrase role="special">;</phrase>
+
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_thread</phrase><phrase role="special">::</phrase><phrase role="identifier">interruption_point</phrase><phrase role="special">();</phrase>  <phrase role="comment">// interruption point
+</phrase>
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// task, to be executed asynchronously
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">cooperative</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// move task to async. executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// interrupt task and wait until task is removed by worker-thread
+</phrase>	<phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">interrupt_and_wait</phrase><phrase role="special">();</phrase>
+
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;is ready == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;has value == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">has_value</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;has exception == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">has_exception</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+
+	<phrase role="comment">// access result
+</phrase>	<phrase role="comment">// throws boost::task::task_interrupted
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <note>
+      <para>
+        If the task is still pending (not executed yet) when an interruption is requested
+        - the task is not removed from the queue, it is marked to be interrupted
+        instead.
+      </para>
+    </note>
+    <anchor id="boost_task.handle.waiting_for_handles"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.handle.waiting_for_handles">Waiting for handles</link>
+    </bridgehead>
+    <para>
+      <emphasis role="bold">Boost.Task</emphasis> provides function <code><phrase
+      role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">waitfor_all</phrase><phrase
+      role="special">()</phrase></code> waits for all handles passed to this function
+      to become ready
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase> <phrase role="identifier">handles</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">results</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">results</phrase><phrase role="special">.</phrase><phrase role="identifier">reserve</phrase><phrase role="special">(</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="number">10</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">,</phrase> <phrase role="identifier">i</phrase><phrase role="special">);</phrase>
+
+		<phrase role="identifier">results</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+				<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+	<phrase role="special">}</phrase>
+
+	<phrase role="comment">// wait until all tasks are ready
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">results</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase> <phrase role="identifier">results</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">()</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="keyword">int</phrase> <phrase role="identifier">k</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">e</phrase><phrase role="special">(</phrase> <phrase role="identifier">results</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">()</phrase> <phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase>
+		<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">iterator</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="identifier">results</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">()</phrase> <phrase role="special">);</phrase>
+		<phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">e</phrase><phrase role="special">;</phrase>
+		<phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+		<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(&quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">k</phrase><phrase role="special">++</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">i</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <para>
+      and <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">waitfor_any</phrase><phrase
+      role="special">()</phrase></code> which returns if at least one of the passed
+      handles becomes ready.
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase> <phrase role="identifier">cooperative</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase> <phrase role="identifier">cooperative</phrase><phrase role="special">,</phrase> <phrase role="number">7</phrase><phrase role="special">);</phrase>
+	 <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t3</phrase><phrase role="special">(</phrase> <phrase role="identifier">cooperative</phrase><phrase role="special">,</phrase> <phrase role="number">5</phrase><phrase role="special">);</phrase>
+
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h3</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t3</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// wait for any task becomes ready
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">waitfor_any</phrase><phrase role="special">(</phrase> <phrase role="identifier">h1</phrase><phrase role="special">,</phrase> <phrase role="identifier">h2</phrase><phrase role="special">,</phrase> <phrase role="identifier">h3</phrase><phrase role="special">);</phrase>
+
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase>
+		<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase>
+		<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(7) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">h3</phrase><phrase role="special">.</phrase><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase>
+		<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(5) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h3</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+  </section>
+  <section id="boost_task.async">
+    <title><link linkend="boost_task.async"> Asynchronous execution</link></title>
+    <para>
+      Function <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase
+      role="special">()</phrase></code> applies the moved <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code> to the <emphasis>execution-policy</emphasis>
+      which executes the <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase></code>
+      (for this purpose <emphasis>execution-policy</emphasis> is required to provide
+      <code><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase>
+      <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+      <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase>
+      <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+      <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+      <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase
+      role="special">)</phrase></code>). <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">async</phrase><phrase role="special">()</phrase></code> accepts
+      two arguments - the first is an <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code> object and the second an <emphasis>execution-policy</emphasis>.
+      For the second argument <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">as_sub_task</phrase></code> is used per default. The function
+      returns a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase></code>
+      which controls the submitted <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code>.
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// task computing fibonacci(10)
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// move the task to executor
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			 <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// access the result
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+  </section>
+  <section id="boost_task.own_thread">
+    <title><link linkend="boost_task.own_thread"> Execute in own thread</link></title>
+    <para>
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">own_thread</phrase></code>
+      executes the task in the current thread (synchronous execution - concerns of
+      <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html">N2802</ulink>
+      do not aply).
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">own_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+  </section>
+  <section id="boost_task.new_thread">
+    <title><link linkend="boost_task.new_thread"> Execute in new thread</link></title>
+    <para>
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase></code>
+      creates a new <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">thread</phrase></code> and executes the task in this thread
+      (asynchronous). The created thread gets joined by handle (so <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html">N2802</ulink>
+      should be addressed). The returned <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">handle</phrase></code> joins the thread in its destructor
+      (if the last reference gets out of scope) .
+    </para>
+    <para>
+      
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <caution>
+      <para>
+        Always store the returned <emphasis>asynchronous-completion-token</emphasis>
+        in a variable because <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">handle</phrase></code>
+        joins the thread in its destructor (if the last reference gets out of scope).
+      </para>
+    </caution>
+    <para>
+      In the example below both <code><phrase role="identifier">a_function</phrase><phrase
+      role="special">()</phrase></code> and <code><phrase role="identifier">another_function</phrase><phrase
+      role="special">()</phrase></code> are executed synchron because the returned
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase></code>
+      is not stored in a variable. Thatswhy the <emphasis>worker-thread</emphasis>
+      is joined after return from <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">async</phrase><phrase role="special">()</phrase></code>!
+    </para>
+    <para>
+      
+<programlisting><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">void</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase> <phrase role="identifier">a_function</phrase><phrase role="special">);</phrase>
+<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">void</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase> <phrase role="identifier">another_function</phrase><phrase role="special">);</phrase>
+
+<phrase role="comment">// handles are not retrieved
+</phrase><phrase role="comment">// both task executed in sequence
+</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">),</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">),</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">new_thread</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+</programlisting>
+    </para>
+  </section>
+  <section id="boost_task.pool">
+    <title><link linkend="boost_task.pool"> Thread-pool</link></title>
+    <para>
+      Instead of creating a new thread and quickly throwing it away after the task
+      is done, the overhead related to thread creation and destruction can be avoided
+      by running the <emphasis>work-items</emphasis> on a <emphasis>thread-pool</emphasis>
+      (reusing an existing <emphasis>worker-thread</emphasis> instead).
+    </para>
+    <para>
+      A <emphasis>thread-pool</emphasis> maintains a queue (or queues) of <emphasis>work-items</emphasis>
+      to be done, and a pool of <emphasis>worker-threads</emphasis> which execute
+      <emphasis>work-items</emphasis> from the queue(s).
+    </para>
+    <para>
+      <emphasis role="bold">Boost.Task</emphasis> provides <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">async</phrase><phrase role="special">()</phrase></code> with
+      support of executing an <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code> in <emphasis>thread-pool</emphasis>:
+    </para>
+    <para>
+      
+<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">echo</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="comment">// create a thread-pool with
+</phrase>	<phrase role="comment">// five worker-threads
+</phrase>	<phrase role="comment">// FIFO schduling of queued tasks
+</phrase>	<phrase role="comment">// and unlimited size of internal queue
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">fifo</phrase>
+		<phrase role="special">&gt;</phrase>
+	<phrase role="special">&gt;</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">5</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// create task
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">echo</phrase><phrase role="special">,</phrase> <phrase role="string">&quot;Hello World!&quot;</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// move task to executor
+</phrase>	<phrase role="comment">// let the task be executed by the thread-pool
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// access the result
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+    </para>
+    <important>
+      <para>
+        Tasks should not be too small (performance overhead dominates) and avoid
+        blocking tasks
+        <footnote>
+          <para>
+            see <ulink url="http://www.ddj.com/go-parallel/article/showArticle.jhtml?articleID=216500409">'Use
+            Thread Pools Correctly'</ulink>, Herb Sutter
+          </para>
+        </footnote>
+        .
+      </para>
+    </important>
+    <section id="boost_task.pool.static_pool">
+      <title><link linkend="boost_task.pool.static_pool"> Static thread-pool</link></title>
+      <para>
+        <emphasis role="bold">Boost.Task</emphasis> provides <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">static_pool</phrase></code>
+        - which contains an fixed set of pre-forked <emphasis>worker-threads</emphasis>
+        (the size of the pool doesn't change during its lifetime). <code><phrase
+        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">static_pool</phrase></code> supports move semantics.
+      </para>
+      <para>
+        
+<programlisting><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">_static_pool</phrase><phrase role="special">&lt;</phrase>               <phrase role="comment">// pool type
+</phrase>        <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>  <phrase role="comment">// queuing policy (unbounded_channel, bounded_channel)
+</phrase>               <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">fifo</phrase>        <phrase role="comment">// scheduling policy (fifo, priority, smart)
+</phrase>        <phrase role="special">&gt;</phrase>
+<phrase role="special">&gt;</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase>
+        <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">6</phrase><phrase role="special">),</phrase>                         <phrase role="comment">// pool with 6 pre-forked worker-threads
+</phrase>        <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">milliseconds</phrase><phrase role="special">(</phrase> <phrase role="number">50</phrase><phrase role="special">),</phrase>  <phrase role="comment">// time to sleep if no work-item available
+</phrase>        <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="number">10</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>                        <phrase role="comment">// iterations over local-queues before sleep
+</phrase></programlisting>
+      </para>
+      <para>
+        The first argument of the constructor specifies how many <emphasis>worker-threads</emphasis>
+        the pool will contain. The second and third argument are used by the <link
+        linkend="boost_task.pool.work_stealing"><emphasis>work-stealing</emphasis></link>
+        algorithm.
+      </para>
+      <note>
+        <para>
+          If <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+          role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+          role="identifier">bounded_channel</phrase></code> is used as queuing policy
+          the constructor has two additional arguments .
+        </para>
+      </note>
+      <para>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">static_pool</phrase></code> provides functionality to check
+        the status of the pool - <code><phrase role="identifier">close</phrase><phrase
+        role="special">()</phrase></code> returns true when the pool was shutdown
+        and <code><phrase role="identifier">active</phrase><phrase role="special">()</phrase></code>
+        as well as <code><phrase role="identifier">idle</phrase><phrase role="special">()</phrase></code>
+        returning how many <emphasis>worker-threads</emphasis> are active (executing
+        a task) or idle. The size of the pool can be accessed over <code><phrase
+        role="identifier">size</phrase><phrase role="special">()</phrase></code>.
+      </para>
+      <para>
+        For informational pruposes <code><phrase role="identifier">empty</phrase><phrase
+        role="special">()</phrase></code> and <code><phrase role="identifier">pending</phrase><phrase
+        role="special">()</phrase></code> can be used in order to know if the global
+        task-queue is empty or how many tasks are waiting for execution. With <code><phrase
+        role="identifier">clear</phrase><phrase role="special">()</phrase></code>
+        all tasks are removed from the global-queue.
+      </para>
+      <note>
+        <para>
+          <code><phrase role="identifier">pending</phrase><phrase role="special">()</phrase></code>
+          does not count tasks in the local-queues of the <emphasis>worker-threads</emphasis>.
+        </para>
+      </note>
+    </section>
+    <section id="boost_task.pool.channel">
+      <title><link linkend="boost_task.pool.channel"> Channel</link></title>
+      <para>
+        The channel synchronizes the access between non-pool threads (application
+        threads) and <emphasis>worker-threads</emphasis> and implements a queuing
+        policy (limitation of queued tasks).
+      </para>
+      <anchor id="boost_task.pool.channel._code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__task__phrase__phrase_role__special______phrase__phrase_role__identifier__bounded_channel__phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.pool.channel._code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__task__phrase__phrase_role__special______phrase__phrase_role__identifier__bounded_channel__phrase___code_"><code><phrase
+        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">bounded_channel</phrase></code></link>
+      </bridgehead>
+      <para>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">bounded_channel</phrase></code> contains a single lock
+        in order to synchronize access to the queue. The number of pending tasks
+        is limited in order to prevent resource exhaustion. For this purpose a high-
+        and low-watermark has to be passed at construction. <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">high_watermark</phrase></code>
+        sets the maximum of pending tasks. If this limited is reached all threads
+        which submit a task will be set to sleep (blocked). If it is equal to <code><phrase
+        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">low_watermark</phrase></code> everytime a sleeping producer
+        thread will be woken up and puts its task if one worker thread has taken
+        a task from the channel. <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">low_watermark</phrase></code>
+        sets the threshold when blocked threads get woken up. If it is less than
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">high_watermark</phrase></code> all sleeping producer threads
+        will be woken up if the amount of pending tasks reaches <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">low_watermark</phrase></code>.
+      </para>
+      <anchor id="boost_task.pool.channel._code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__task__phrase__phrase_role__special______phrase__phrase_role__identifier__unbounded_channel__phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.pool.channel._code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__task__phrase__phrase_role__special______phrase__phrase_role__identifier__unbounded_channel__phrase___code_"><code><phrase
+        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">unbounded_channel</phrase></code></link>
+      </bridgehead>
+      <para>
+        <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">unbounded_channel</phrase></code> contains a single lock
+        in order to synchronize access to the queue. An unlimited number of tasks
+        can be queued into this channel. The insertion of an <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase></code>
+        will never block. If the channel becomes empty <emphasis>worker-threads</emphasis>
+        will be set to sleep until new tasks are enqueued.
+      </para>
+    </section>
+    <section id="boost_task.pool.scheduling">
+      <title><link linkend="boost_task.pool.scheduling"> Scheduling</link></title>
+      <para>
+        The scheduling policy determines how tasks are scheduled inside the <emphasis>channel</emphasis>.
+      </para>
+      <anchor id="boost_task.pool.scheduling.fifo"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.pool.scheduling.fifo">fifo</link>
+      </bridgehead>
+      <para>
+        First inserted pending <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase></code>
+        gets taken first.
+      </para>
+      <anchor id="boost_task.pool.scheduling.priority"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.pool.scheduling.priority">priority</link>
+      </bridgehead>
+      <para>
+        Each <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase></code> is submitted to the pool with a priority
+        attribute. The type and ordering of the priority is user-defined.
+      </para>
+      <para>
+        
+<programlisting><phrase role="comment">// thread-pool with priority scheduling
+</phrase><phrase role="comment">// tasks with higher priority are
+</phrase><phrase role="comment">// scheduled first
+</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">priority</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="special">&gt;</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">5</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">void</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase> <phrase role="identifier">some_fn</phrase><phrase role="special">);</phrase>
+<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">void</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase> <phrase role="identifier">another_fn</phrase><phrase role="special">);</phrase>
+
+<phrase role="comment">// move task t1 with priority 5 to thread-pool
+</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">),</phrase>
+	<phrase role="number">5</phrase><phrase role="special">,</phrase>
+	<phrase role="identifier">pool</phrase><phrase role="special">);</phrase>
+
+<phrase role="comment">// move task t2 with priority 3 to thread-pool
+</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">),</phrase>
+	<phrase role="number">3</phrase><phrase role="special">,</phrase>
+	<phrase role="identifier">pool</phrase><phrase role="special">);</phrase>
+</programlisting>
+      </para>
+      <para>
+        In this example the tasks get scheduled by the assigned integer (third argument
+        of <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">async</phrase><phrase role="special">()</phrase></code>).
+        The <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase></code> with the lowest priority gets scheduled
+        first (taken by a <emphasis>worker-thread</emphasis>). The ordering can be
+        changed by the second argument of <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">priority</phrase></code>
+        (the default is <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">greater</phrase><phrase role="special">&lt;</phrase> <phrase
+        role="identifier">Attr</phrase> <phrase role="special">&gt;</phrase></code>).
+      </para>
+      <para>
+        
+<programlisting><phrase role="comment">// thread-pool with priority scheduling
+</phrase><phrase role="comment">// tasks with lower priority are
+</phrase><phrase role="comment">// scheduled first
+</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">priority</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">less</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="special">&gt;</phrase>
+<phrase role="special">&gt;</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">5</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.pool.scheduling.smart"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.pool.scheduling.smart">smart</link>
+      </bridgehead>
+      <para>
+        Each inserted <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase></code> is associated with an attribute. The
+        scheduler gets an put- and take-policy as template arguments. The corresponding
+        policy gets applied for each insertion and removal.
+      </para>
+      <para>
+        <emphasis role="bold">Boost.Task</emphasis> provides <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">replace_oldest</phrase></code>
+        as put- policy and <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">take_oldest</phrase></code>
+        as take-policy. Both policies allow the replacement of older (pending) tasks
+        in the scheduler by new ones.
+      </para>
+      <para>
+        
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">fibonacci_fn</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">smart</phrase><phrase role="special">&lt;</phrase>
+			<phrase role="keyword">int</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">less</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;,</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">replace_oldest</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">take_oldest</phrase>
+		<phrase role="special">&gt;</phrase>
+	<phrase role="special">&gt;</phrase>
+<phrase role="special">&gt;</phrase> <phrase role="identifier">pool_type</phrase><phrase role="special">;</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">pool_type</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="special">...</phrase>
+
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">bind</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci_fn</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">bind</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci_fn</phrase><phrase role="special">,</phrase> <phrase role="number">5</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// replaced by later task with same attribute == 2
+</phrase>	<phrase role="comment">// if still pending in pool
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">),</phrase>
+		<phrase role="number">2</phrase><phrase role="special">,</phrase>
+		<phrase role="identifier">pool</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// will replace previous pending task with attribute == 2
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">),</phrase>
+		<phrase role="number">2</phrase><phrase role="special">,</phrase>
+		<phrase role="identifier">pool</phrase><phrase role="special">);</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+      </para>
+    </section>
+    <section id="boost_task.pool.pool_shutdown">
+      <title><link linkend="boost_task.pool.pool_shutdown"> Pool shutdown</link></title>
+      <para>
+        <emphasis role="bold">Boost.Task</emphasis> allows to shutdown a <emphasis>thread-pool</emphasis>
+        explicitly via functions <code><phrase role="identifier">shutdown</phrase><phrase
+        role="special">()</phrase></code> and <code><phrase role="identifier">shutdown_now</phrase><phrase
+        role="special">()</phrase></code>. The destructor of the pool calls <code><phrase
+        role="identifier">shutdown</phrase><phrase role="special">()</phrase></code>
+        if not already done so that all <emphasis>worker-threads</emphasis> are joined
+        and the topic of <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html">N2802</ulink>
+        should be addressed.
+      </para>
+      <anchor id="boost_task.pool.pool_shutdown.shutdown"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.pool.pool_shutdown.shutdown">Shutdown</link>
+      </bridgehead>
+      <para>
+        If <code><phrase role="identifier">shutdown</phrase><phrase role="special">()</phrase></code>
+        is called - the the pool is set the closed state and all <emphasis>worker-threads</emphasis>
+        are joined until all pending tasks are processed. No futher tasks can be
+        submitted.
+      </para>
+      <para>
+        
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">fibonacci_fn</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">fifo</phrase>
+	<phrase role="special">&gt;</phrase>
+<phrase role="special">&gt;</phrase> <phrase role="identifier">pool_type</phrase><phrase role="special">;</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">pool_type</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="special">...</phrase>
+
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci_fn</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci_fn</phrase><phrase role="special">,</phrase> <phrase role="number">5</phrase><phrase role="special">);</phrase>
+
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// waits until all pending tasks are finished
+</phrase>	<phrase role="identifier">pool</phrase><phrase role="special">.</phrase><phrase role="identifier">shutdown</phrase><phrase role="special">();</phrase>
+
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(5) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+      </para>
+      <note>
+        <para>
+          The deconstructor calls <code><phrase role="identifier">shutdown</phrase><phrase
+          role="special">()</phrase></code> if the pool was not shutdown yet.
+        </para>
+      </note>
+      <anchor id="boost_task.pool.pool_shutdown.shutdown_immediatly"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.pool.pool_shutdown.shutdown_immediatly">Shutdown
+        immediatly</link>
+      </bridgehead>
+      <para>
+        The function <code><phrase role="identifier">shutdown_now</phrase><phrase
+        role="special">()</phrase></code> closes the pool, interrupts and then joins
+        all <emphasis>worker-threads</emphasis>. Pending tasks are unprocessed.
+      </para>
+      <para>
+        
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">fibonacci_fn</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">0</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">==</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">long</phrase> <phrase role="identifier">k1</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">),</phrase> <phrase role="identifier">k2</phrase><phrase role="special">(</phrase> <phrase role="number">0</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">for</phrase> <phrase role="special">(</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase><phrase role="special">(</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;=</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="keyword">long</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">(</phrase> <phrase role="identifier">k1</phrase><phrase role="special">);</phrase>
+		<phrase role="identifier">k1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">k1</phrase> <phrase role="special">+</phrase> <phrase role="identifier">k2</phrase><phrase role="special">;</phrase>
+		<phrase role="identifier">k2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
+	<phrase role="special">}</phrase>
+	<phrase role="keyword">return</phrase> <phrase role="identifier">k1</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">fifo</phrase>
+	<phrase role="special">&gt;</phrase>
+<phrase role="special">&gt;</phrase> <phrase role="identifier">pool_type</phrase><phrase role="special">;</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">pool_type</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="special">...</phrase>
+
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci_fn</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci_fn</phrase><phrase role="special">,</phrase> <phrase role="number">5</phrase><phrase role="special">);</phrase>
+
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// requests task interruption and
+</phrase>	<phrase role="comment">// joins all worker-threads
+</phrase>	<phrase role="identifier">pool</phrase><phrase role="special">.</phrase><phrase role="identifier">shutdown_now</phrase><phrase role="special">();</phrase>
+
+	<phrase role="comment">// accessing the result may throw task_interrupted
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(5) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+      </para>
+    </section>
+    <section id="boost_task.pool.processor_binding">
+      <title><link linkend="boost_task.pool.processor_binding"> Processor binding</link></title>
+      <para>
+        For some applications it is convenient to bind the <emphasis>worker-threads</emphasis>
+        to processors/cores of the system. For this purpose <code><phrase role="identifier">bind_to_processors</phrase><phrase
+        role="special">()</phrase></code> must be given to constructor instead <code><phrase
+        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">poolsize</phrase></code> so that a <emphasis>worker-thread</emphasis>
+        is created an bound the the core.
+      </para>
+      <para>
+        
+<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">tp</phrase><phrase role="special">::</phrase><phrase role="identifier">fifo</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="special">&gt;</phrase> <phrase role="identifier">pool_type</phrase><phrase role="special">;</phrase>
+
+<phrase role="comment">// constructs thread-pool with worker-threads as
+</phrase><phrase role="comment">// CPUs/Cores are available on the system
+</phrase><phrase role="identifier">pool_type</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">pool_type</phrase><phrase role="special">::</phrase><phrase role="identifier">bind_to_processors</phrase><phrase role="special">()</phrase> <phrase role="special">);</phrase>
+</programlisting>
+      </para>
+      <para>
+        The constructor takes additional arguments for the <link linkend="boost_task.pool.work_stealing">work-stealing
+        algorithm</link> and <link linkend="boost_task.pool.channel">high-</link>
+        and <link linkend="boost_task.pool.channel">low-watermark</link> too.
+      </para>
+      <note>
+        <para>
+          <emphasis role="bold">Boost.Task</emphasis> does provide this feature only
+          for Windows, Linux, AIX, HP-UX, Solaris and FreeBSD.
+        </para>
+      </note>
+    </section>
+    <section id="boost_task.pool.work_stealing">
+      <title><link linkend="boost_task.pool.work_stealing"> Work-Stealing</link></title>
+      <para>
+        Traditional <emphasis>thread-pools</emphasis> do not scale because they use
+        a single global-queue protected by a global-lock. The frequency at which
+        <emphasis>worker-threads</emphasis> aquire the global-lock becomes a limiting
+        factor for the throughput if:
+      </para>
+      <itemizedlist>
+        <listitem>
+          the tasks become smaller
+        </listitem>
+        <listitem>
+          more processors are added
+        </listitem>
+      </itemizedlist>
+      <para>
+        A <emphasis>work-stealing</emphasis> algorithm can be used to solve this
+        problem. It uses a special kind of queue which has two ends, and allows lock-free
+        pushes and pops from the <emphasis>private end</emphasis> (accessed by the
+        <emphasis>worker-thread</emphasis> owning the queue), but requires synchronization
+        from the <emphasis>public end</emphasis> (accessed by the other <emphasis>worker-threads</emphasis>).
+        Synchronization is necessary when the queue is sufficiently small that private
+        and public operations could conflict.
+      </para>
+      <para>
+        The pool contains one global-queue (<code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">bounded_channel</phrase></code>
+        or <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">unbounded_channel</phrase></code>) protected by a global-lock
+        and each <emphasis>worker-thread</emphasis> has its own private local worker-queue.
+        If work is enqueued by a <emphasis>worker-thread</emphasis> the <code><phrase
+        role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+        role="identifier">task</phrase></code> is stored in the worker queue. If
+        the work is enqueued by a application thread it goes into the global queue.
+        When <emphasis>worker-threads</emphasis> are looking for work, they have
+        following search order:
+      </para>
+      <itemizedlist>
+        <listitem>
+          look into the private worker-queue - tasks can be dequeued without locks
+        </listitem>
+        <listitem>
+          look in the global-queue - locks are used for synchronization
+        </listitem>
+        <listitem>
+          check other worker-queues ('stealing' tasks from private worker queues
+          of other <emphasis>worker-threads</emphasis>) - requires locks
+        </listitem>
+      </itemizedlist>
+      <para>
+        For a lot of recursively queued tasks (so called <emphasis>sub-tasks</emphasis>),
+        the use of a worker-queue per thread substantially reduces the synchronization
+        necessary to complete the work. There are also fewer cache effects due to
+        sharing of the global-queue information.
+      </para>
+      <para>
+        Operations on the private worker queue are executed in LIFO order and operations
+        on worker queues of other <emphasis>worker-threads</emphasis> in FIFO order
+        (steals).
+      </para>
+      <itemizedlist>
+        <listitem>
+          There are chances that memory is still hot in the cache, if the tasks are
+          pushed in LIFO order into the private worker queue.
+        </listitem>
+        <listitem>
+          If a <emphasis>worker-thread</emphasis> steals work in FIFO order, increases
+          the chances that a larger 'chunk' of work will be stolen (the need for
+          other steals will be possibly reduced). Because the <emphasis>sub-tasks</emphasis>
+          are stored in LIFO order, the oldest items are closer to the <emphasis>public
+          end</emphasis> of the queue (forming a tree). Stealing such an older <code><phrase
+          role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+          role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+          role="identifier">task</phrase></code> also steals a (probably) larger
+          subtree of tasks unfolded if the stolen work item get executed. Since a
+          <emphasis>sub-task</emphasis> is just part of a larger <code><phrase role="identifier">boost</phrase><phrase
+          role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+          role="special">::</phrase><phrase role="identifier">task</phrase></code>,
+          we dont need to worry about execution order.
+        </listitem>
+      </itemizedlist>
+    </section>
+    <para>
+      / Copyright Oliver Kowalke 2009. Distributed under the Boost Software License,
+      Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
+      ]
+    </para>
+    <section id="boost_task.pool.forkjoin">
+      <title><link linkend="boost_task.pool.forkjoin"> Fork/Join</link></title>
+      <para>
+        Fork/Join algorithms are recursive divide-and-conquer algorithms which repeatedly
+        splitt into sub-tasks until they become small enough to solve using simple,
+        short sequential methods, so that they run in parallel on multiple cores.
+      </para>
+      <para>
+        The fork operation creates new <emphasis>sub-tasks</emphasis> which can run
+        in parallel. The current <code><phrase role="identifier">boost</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">task</phrase></code>
+        is not proceeded in the join operation until the forked <emphasis>sub-tasks</emphasis>
+        have completed. In the meantime the <emphasis>worker-thread</emphasis> executes
+        other tasks from its local <emphasis>worker-queue</emphasis>.
+      </para>
+      <para>
+        
+<programlisting><phrase role="keyword">long</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">&lt;</phrase> <phrase role="number">2</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">n</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">else</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">+</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">2</phrase><phrase role="special">);</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">long</phrase> <phrase role="identifier">parallel_fib</phrase><phrase role="special">(</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">n</phrase><phrase role="special">,</phrase> <phrase role="keyword">long</phrase> <phrase role="identifier">cutof</phrase><phrase role="special">)</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">if</phrase> <phrase role="special">(</phrase> <phrase role="identifier">n</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">cutof</phrase><phrase role="special">)</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">serial_fib</phrase><phrase role="special">(</phrase> <phrase role="identifier">n</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">else</phrase>
+	<phrase role="special">{</phrase>
+		<phrase role="comment">// create a sub-task calculating fibonacci(n-1)
+</phrase>		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">cutof</phrase><phrase role="special">);</phrase>
+		<phrase role="comment">// create a sub-task calculating fibonacci(n-2)
+</phrase>		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">n</phrase> <phrase role="special">-</phrase> <phrase role="number">2</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">cutof</phrase><phrase role="special">);</phrase>
+
+		<phrase role="comment">// fork both sub-tasks by moving the task
+</phrase>		<phrase role="comment">// ownership to the thread-pool
+</phrase>		<phrase role="identifier">h1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t1</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+		<phrase role="identifier">h2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t2</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+		<phrase role="comment">// join the results of both sub-tasks
+</phrase>		<phrase role="comment">// if one of the both sub-tasks is not ready
+</phrase>		<phrase role="comment">// the worker-thread does not block, it executes other
+</phrase>		<phrase role="comment">// task from its local-queue
+</phrase>		<phrase role="keyword">return</phrase> <phrase role="identifier">h1</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">+</phrase> <phrase role="identifier">h2</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">();</phrase>
+	<phrase role="special">}</phrase>
+<phrase role="special">}</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">fifo</phrase>
+		<phrase role="special">&gt;</phrase>
+	<phrase role="special">&gt;</phrase> <phrase role="identifier">pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="number">5</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// compute fibonacci-number 10
+</phrase>	<phrase role="comment">// for numbers &lt; 5 do inline calculation
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">parallel_fib</phrase><phrase role="special">,</phrase>
+		<phrase role="number">10</phrase><phrase role="special">,</phrase>
+		<phrase role="number">5</phrase><phrase role="special">);</phrase>
+
+	<phrase role="comment">// move task ownership to thread-pool
+</phrase>	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">pool</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+	<phrase role="comment">// access result
+</phrase>	<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;fibonacci(10) == &quot;</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+<phrase role="special">}</phrase>
+</programlisting>
+      </para>
+    </section>
+  </section>
+  <section id="boost_task.as_sub_task">
+    <title><link linkend="boost_task.as_sub_task"> Execute as sub-task</link></title>
+    <para>
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">as_sub_task</phrase></code>
+      is a convenient way to execute a <emphasis>sub-task</emphasis>. If the parent
+      task is executed inside a <emphasis>thread-pool</emphasis> the <emphasis>sub-task</emphasis>
+      is put into the local-queue of the <emphasis>worker-thread</emphasis> in the
+      other case the <emphasis>sub-task</emphasis> will be executed in a new thread.
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">as_sub_task</phrase></code>
+      is used as default <emphasis>execution-policy</emphasis> for <code><phrase
+      role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">()</phrase></code>,
+    </para>
+    <para>
+      
+<programlisting><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">t</phrase><phrase role="special">(</phrase> <phrase role="identifier">fibonacci</phrase><phrase role="special">,</phrase> <phrase role="number">10</phrase><phrase role="special">);</phrase>
+
+<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">long</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">h</phrase><phrase role="special">(</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">async</phrase><phrase role="special">(</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase> <phrase role="identifier">t</phrase><phrase role="special">),</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">as_sub_task</phrase><phrase role="special">()</phrase> <phrase role="special">)</phrase> <phrase role="special">);</phrase>
+</programlisting>
+    </para>
+  </section>
+  <section id="boost_task.utilities">
+    <title><link linkend="boost_task.utilities"> Utilities</link></title>
+    <para>
+      <emphasis role="bold">Boost.Task</emphasis> provides some free-functions which
+      can be used inside a <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code> to access some informations (like if
+      the <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase></code>
+      runs in a <emphasis>thread-pool</emphasis>).
+    </para>
+    <anchor id="boost_task.utilities.reschedule_until"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.utilities.reschedule_until">reschedule_until</link>
+    </bridgehead>
+    <para>
+      In the function <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">this_task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">reschedule_until</phrase><phrase role="special">(</phrase>
+      <phrase role="identifier">Pred</phrase> <phrase role="keyword">const</phrase><phrase
+      role="special">&amp;)</phrase></code> allows to synchronize the task with other
+      asynchronous events without blocking the <emphasis>worker-threads</emphasis>
+      (bool Pred::operator()() must not block). The current task will be rescheduled
+      until the passed predicate becomes true.
+    </para>
+    <anchor id="boost_task.utilities.get_pool"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.utilities.get_pool">get_pool</link>
+    </bridgehead>
+    <para>
+      The pool in which the current code (<code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code>) is executed can be accessed via <code><phrase
+      role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_task</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">get_pool</phrase><phrase
+      role="special">()</phrase></code>. If hte code is not executed by a <emphasis>worker-thread</emphasis>
+      an assertion is raised.
+    </para>
+    <anchor id="boost_task.utilities.runs_in_pool"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.utilities.runs_in_pool">runs_in_pool</link>
+    </bridgehead>
+    <para>
+      In order to check if the current code is executed in a <emphasis>thread-pool</emphasis>
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">this_task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">runs_in_pool</phrase><phrase role="special">()</phrase></code>
+      should be used.
+    </para>
+    <anchor id="boost_task.utilities.worker_id"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.utilities.worker_id">worker_id</link>
+    </bridgehead>
+    <para>
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">this_task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">worker_id</phrase><phrase role="special">()</phrase></code>
+      returns the <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">thread</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">id</phrase></code> of the <emphasis>worker-thread</emphasis>
+      executing the current <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase></code>.
+    </para>
+    <anchor id="boost_task.utilities.delay"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.utilities.delay">delay</link>
+    </bridgehead>
+    <para>
+      The execution of a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase></code>
+      can be delayed for a time-duration or until a specific time-point with <code><phrase
+      role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">this_task</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">delay</phrase><phrase role="special">()</phrase></code>.
+    </para>
+    <anchor id="boost_task.utilities.yield"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.utilities.yield">yield</link>
+    </bridgehead>
+    <para>
+      If a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase></code>
+      detects that it would bould block it can yield itself with <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">this_task</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">yield</phrase><phrase role="special">()</phrase></code>
+      so that the <emphasis>worker-thread</emphasis> can execute another <code><phrase
+      role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">task</phrase></code> in
+      the meantime.
+    </para>
+    <anchor id="boost_task.utilities.interrupt"/>
+    <bridgehead renderas="sect3">
+      <link linkend="boost_task.utilities.interrupt">interrupt</link>
+    </bridgehead>
+    <para>
+      A <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase></code>
+      can interrupt itself via <code><phrase role="identifier">boost</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">this_task</phrase><phrase
+      role="special">::</phrase><phrase role="identifier">interrupt</phrase><phrase
+      role="special">()</phrase></code>.
+    </para>
+  </section>
+  <section id="boost_task.meta_functions">
+    <title><link linkend="boost_task.meta_functions"> Meta functions</link></title>
+    <para>
+      If the <emphasis>thread-pool</emphasis> supports attributes (like priorities)
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">has_attribute</phrase></code>
+      evaluates to <code><phrase role="keyword">true</phrase></code> at compile-time
+      (derived from boost::mpl::bool_). The type of the attribute is determined by
+      <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+      role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">attribute_type</phrase></code>.
+    </para>
+    <para>
+      
+<programlisting><phrase role="comment">// thread-pool with priority scheduling
+</phrase><phrase role="comment">// type of priority is int
+</phrase><phrase role="identifier">typdef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">&lt;</phrase>
+	<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">unbounded_channel</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">priority</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">int</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="special">&gt;</phrase>
+<phrase role="special">&gt;</phrase> <phrase role="identifier">pool_type</phrase><phrase role="special">;</phrase>
+
+<phrase role="comment">// test if thread-pool supports priorities at compile time
+</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">boolalpha</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">has_attribute</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">pool_type</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">value</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="string">&quot;\n&quot;</phrase><phrase role="special">;</phrase>
+
+<phrase role="comment">// access the type used for priority
+</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="keyword">typeid</phrase><phrase role="special">(</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">task</phrase><phrase role="special">::</phrase><phrase role="identifier">attribute_type</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">pool_type</phrase> <phrase role="special">&gt;::</phrase><phrase role="identifier">type</phrase><phrase role="special">).</phrase><phrase role="identifier">name</phrase><phrase role="special">()</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
+</programlisting>
+    </para>
+  </section>
+  <section id="boost_task.reference">
+    <title><link linkend="boost_task.reference"> Reference</link></title>
+    <section id="boost_task.reference.task">
+      <title><link linkend="boost_task.reference.task"> Class template <code><phrase
+      role="identifier">task</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">class</phrase> <phrase role="identifier">task</phrase> <phrase role="special">:</phrase> <phrase role="keyword">private</phrase> <phrase role="identifier">noncopyable</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">task</phrase><phrase role="special">();</phrase>
+
+	<phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">R</phrase><phrase role="special">(</phrase> <phrase role="special">*</phrase> <phrase role="identifier">fn</phrase><phrase role="special">)());</phrase>
+
+	<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Fn</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">Fn</phrase> <phrase role="identifier">fn</phrase><phrase role="special">);</phrase>
+
+	<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Fn</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">A0</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">Fn</phrase> <phrase role="identifier">fn</phrase><phrase role="special">,</phrase> <phrase role="identifier">A0</phrase> <phrase role="identifier">a0</phrase><phrase role="special">);</phrase>
+	<phrase role="special">...</phrase>
+	<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Fn</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">A0</phrase><phrase role="special">,</phrase> <phrase role="special">...,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">A9</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">Fn</phrase> <phrase role="identifier">fn</phrase><phrase role="special">,</phrase> <phrase role="identifier">A0</phrase> <phrase role="identifier">a0</phrase><phrase role="special">,</phrase> <phrase role="special">...,</phrase> <phrase role="identifier">A9</phrase> <phrase role="identifier">a9</phrase><phrase role="special">);</phrase>
+
+	<phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">);</phrase>
+	<phrase role="identifier">task</phrase> <phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase> <phrase role="identifier">task</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">);</phrase>
+	<phrase role="identifier">task</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">move</phrase><phrase role="special">();</phrase>
+
+	<phrase role="identifier">shared_future</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">get_future</phrase><phrase role="special">();</phrase>
+
+	<phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()();</phrase>
+
+	<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Cb</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="keyword">void</phrase> <phrase role="identifier">set_wait_callback</phrase><phrase role="special">(</phrase> <phrase role="identifier">Cb</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">cb</phrase><phrase role="special">);</phrase>
+
+	<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">other</phrase><phrase role="special">);</phrase>
+
+	<phrase role="keyword">operator</phrase> <phrase role="identifier">unspecified_bool_type</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.task.default_constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.default_constructor">Default constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs an unitialized <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase
+            role="special">&gt;</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.constructor__function_pointer_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.constructor__function_pointer_">Constructor
+        (function pointer)</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">R</phrase><phrase role="special">(</phrase> <phrase role="special">*</phrase> <phrase role="identifier">fn</phrase><phrase role="special">)());</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+            <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase></code>
+            from a function pointer
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.constructor__functor_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.constructor__functor_">Constructor
+        (functor)</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Fn</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">Fn</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">fn</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+            <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase></code>
+            from a function object
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.constructor__functor_with_arguments_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.constructor__functor_with_arguments_">Constructor
+        (functor with arguments)</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Fn</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">A0</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">Fn</phrase> <phrase role="identifier">fn</phrase><phrase role="special">,</phrase> <phrase role="identifier">A0</phrase> <phrase role="identifier">a0</phrase><phrase role="special">);</phrase>
+<phrase role="special">...</phrase>
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Fn</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">A0</phrase><phrase role="special">,</phrase> <phrase role="special">...,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">A9</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">Fn</phrase> <phrase role="identifier">fn</phrase><phrase role="special">,</phrase> <phrase role="identifier">A0</phrase> <phrase role="identifier">a0</phrase><phrase role="special">,</phrase> <phrase role="special">...,</phrase> <phrase role="identifier">A9</phrase> <phrase role="identifier">a9</phrase><phrase role="special">);</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+            <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase></code>
+            from a function object and its arguments
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.move_copy_constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.move_copy_constructor">Move-copy
+        constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase> <phrase role="special">&amp;&amp;)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+            <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase></code>
+            from another task taking over the ownership
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.move_assignment_operator"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.move_assignment_operator">Move-assignment
+        operator</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task</phrase> <phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase> <phrase role="identifier">task</phrase> <phrase role="special">&amp;&amp;)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+            <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase></code>
+            from another task taking over the ownership
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.member_function__code__phrase_role__identifier__move__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.member_function__code__phrase_role__identifier__move__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">move</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">move</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            moves task releasing the ownership
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.member_function__code__phrase_role__identifier__get_future__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.member_function__code__phrase_role__identifier__get_future__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">get_future</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">shared_future</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">get_future</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns a future assiciated with the task
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special________phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special________phrase___code_">Member
+        function <code><phrase role="keyword">operator</phrase><phrase role="special">()()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            executes task's internal function object
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.member_template_function__code__phrase_role__identifier__set_wait_callback__phrase__phrase_role__special_____phrase___phrase_role__identifier__cb__phrase___phrase_role__identifier__cons__phrase__phrase_role__special___amp____phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.member_template_function__code__phrase_role__identifier__set_wait_callback__phrase__phrase_role__special_____phrase___phrase_role__identifier__cb__phrase___phrase_role__identifier__cons__phrase__phrase_role__special___amp____phrase___code_">Member
+        template-function <code><phrase role="identifier">set_wait_callback</phrase><phrase
+        role="special">(</phrase> <phrase role="identifier">Cb</phrase> <phrase role="identifier">cons</phrase><phrase
+        role="special">&amp;)</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Cb</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">void</phrase> <phrase role="identifier">set_wait_callback</phrase><phrase role="special">(</phrase> <phrase role="identifier">Cb</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">cb</phrase><phrase role="special">&amp;);</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            stores callback function object which will be called if task would block
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.member_function__code__phrase_role__identifier__swap__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp____phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.member_function__code__phrase_role__identifier__swap__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp____phrase___code_">Member
+        function <code><phrase role="identifier">swap</phrase><phrase role="special">(</phrase>
+        <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+        <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+        <phrase role="special">&amp;)</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">other</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            swaps the task
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.operator__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__unspecified_bool_type__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.operator__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__unspecified_bool_type__phrase__phrase_role__special______phrase___code_">operator
+        <code><phrase role="keyword">operator</phrase> <phrase role="identifier">unspecified_bool_type</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">operator</phrase> <phrase role="identifier">unspecified_bool_type</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            is task valid == does task own ownership
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.task.operator__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task.operator__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___code_">operator
+        <code><phrase role="keyword">operator</phrase><phrase role="special">!()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!()</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            is task invalid == task does not have ownership
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.handle">
+      <title><link linkend="boost_task.reference.handle"> Class template <code><phrase
+      role="identifier">handle</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">handle</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">class</phrase> <phrase role="identifier">handle</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="identifier">handle</phrase><phrase role="special">();</phrase>
+
+	<phrase role="keyword">void</phrase> <phrase role="identifier">interrupt</phrase><phrase role="special">();</phrase>
+	<phrase role="keyword">void</phrase> <phrase role="identifier">interrupt_and_wait</phrase><phrase role="special">();</phrase>
+	<phrase role="keyword">void</phrase> <phrase role="identifier">interrupt_and_wait_until</phrase><phrase role="special">(</phrase> <phrase role="identifier">system_time</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">abs_time</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Duration</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="keyword">void</phrase> <phrase role="identifier">interrupt_and_wait_for</phrase><phrase role="special">(</phrase> <phrase role="identifier">Duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">rel_time</phrase><phrase role="special">);</phrase>
+	<phrase role="keyword">bool</phrase> <phrase role="identifier">interruption_requested</phrase><phrase role="special">();</phrase>
+
+	<phrase role="identifier">R</phrase> <phrase role="identifier">get</phrase><phrase role="special">();</phrase>
+	<phrase role="keyword">bool</phrase> <phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">bool</phrase> <phrase role="identifier">has_value</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">bool</phrase> <phrase role="identifier">has_exception</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+	<phrase role="keyword">void</phrase> <phrase role="identifier">wait</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+
+	<phrase role="identifier">shared_future</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">get_future</phrase><phrase role="special">();</phrase>
+
+	<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">other</phrase><phrase role="special">);</phrase>
+<phrase role="special">};</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">friend</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="identifier">begin</phrase><phrase role="special">,</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="identifier">end</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">friend</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">);</phrase>
+<phrase role="special">...</phrase>
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T3</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T4</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T5</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">friend</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t3</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T4</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t4</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T5</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t5</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">friend</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="identifier">waitfor_any</phrase><phrase role="special">(</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="identifier">begin</phrase><phrase role="special">,</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="identifier">end</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">friend</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">waitfor_any</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">);</phrase>
+<phrase role="special">...</phrase>
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T3</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T4</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T5</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">friend</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">waitfor_any</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t3</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T4</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t4</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T5</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t5</phrase><phrase role="special">);</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.handle.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">handle</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs an empty (invalid) handle
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__interruption_requested__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__interruption_requested__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">interruption_requested</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="identifier">interruption_requested</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            checks if interruption is already requested
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">interrupt</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">interrupt</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            requests task interruption; doesn not block (immediatly returns)
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">interrupt_and_wait</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">interrupt_and_wait</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            requests task interruption and blocks until worker-thread stops task
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_resource_error</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait_until__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait_until__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">interrupt_and_wait_until</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="identifier">interrupt_and_wait_until</phrase><phrase role="special">(</phrase> <phrase role="identifier">system_time</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">abs_time</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            requests task interruption and blocks until worker-thread stops task
+            or time-point elapsed
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Returns:</term>
+        <listitem>
+          <para>
+            false if the the time specified by abs_time was reached, true otherwise
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_resource_error</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait_for__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait_for__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">interrupt_and_wait_for</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Duration</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">bool</phrase> <phrase role="identifier">interrupt_and_wait_for</phrase><phrase role="special">(</phrase> <phrase role="identifier">Duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">rel_time</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            requests task interruption and blocks until worker-thread stops task
+            or time-duration elapsed
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Returns:</term>
+        <listitem>
+          <para>
+            false if the the time specified by rel_time was reached, true otherwise
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_resource_error</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__get__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__get__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">get</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">R</phrase> <phrase role="identifier">get</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            requests the result
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_interrupted</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task_uninialized</phrase></code>,
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_rejected</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">broken_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__wait__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__wait__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">wait</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">wait</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            blocks caller until task is done
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_interrupted</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task_uninialized</phrase></code>,
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_rejected</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">broken_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__wait_for__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__wait_for__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">wait_for</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Duration</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">bool</phrase> <phrase role="identifier">wait_for</phrase><phrase role="special">(</phrase> <phrase role="identifier">Duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">rel_time</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            blocks caller until task is done
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_interrupted</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task_uninialized</phrase></code>,
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_rejected</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">broken_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__wait_until__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__wait_until__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">wait_until</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="identifier">wait_until</phrase><phrase role="special">(</phrase> <phrase role="identifier">system_time</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">abs_time</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            blocks caller until task is done
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_interrupted</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task_uninialized</phrase></code>,
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_rejected</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">broken_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__is_ready__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__is_ready__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="identifier">is_ready</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            checks if task is done
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__has_value__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__has_value__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">has_value</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="identifier">has_value</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            checks if task is done and a result value is set
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__has_exception__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__has_exception__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">has_exception</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="identifier">has_exception</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            checks if task is done and an exception is set
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__get_future__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__get_future__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">get_future</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">shared_future</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">get_future</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns a reference to the internal shared_future&lt; R &gt;
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.member_function__code__phrase_role__identifier__swap__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.member_function__code__phrase_role__identifier__swap__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">swap</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">other</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            swapps handle
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.non_member_function__code__phrase_role__identifier__wait_for_all__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.non_member_function__code__phrase_role__identifier__wait_for_all__phrase__phrase_role__special______phrase___code_">Non-member
+        function <code><phrase role="identifier">wait_for_all</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">void</phrase> <phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="identifier">begin</phrase><phrase role="special">,</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="identifier">end</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">void</phrase> <phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">void</phrase> <phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t3</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T3</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T4</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">void</phrase> <phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t3</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T4</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t4</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T3</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T4</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T5</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">void</phrase> <phrase role="identifier">waitfor_all</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t3</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T4</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t4</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T5</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t5</phrase><phrase role="special">);</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            waits for all handles to become ready
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_interrupted</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task_rejected</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.handle.non_member_function__code__phrase_role__identifier__wait_for_any__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.handle.non_member_function__code__phrase_role__identifier__wait_for_any__phrase__phrase_role__special______phrase___code_">Non-member
+        function <code><phrase role="identifier">wait_for_any</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">Iterator</phrase> <phrase role="identifier">waitfor_any</phrase><phrase role="special">(</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="identifier">begin</phrase><phrase role="special">,</phrase> <phrase role="identifier">Iterator</phrase> <phrase role="identifier">end</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">waitfor_any</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">waitfor_any</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t3</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T3</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T4</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">waitfor_any</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t3</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T4</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t4</phrase><phrase role="special">);</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T1</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T2</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T3</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T4</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">T5</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">waitfor_any</phrase><phrase role="special">(</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T1</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t1</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T2</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t2</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T3</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t3</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T4</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t4</phrase><phrase role="special">,</phrase> <phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">T5</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">t5</phrase><phrase role="special">);</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            waits for any handle to become ready
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_interrupted</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task_rejected</phrase></code>,
+            <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">bad_alloc</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.async">
+      <title><link linkend="boost_task.reference.async"> Non-member function <code><phrase
+      role="identifier">async</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase
+      role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+      <phrase role="special">&amp;&amp;,</phrase> <phrase role="identifier">EP</phrase><phrase
+      role="special">)</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">async</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">EP</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">async</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">,</phrase> <phrase role="identifier">EP</phrase> <phrase role="identifier">ep</phrase><phrase role="special">);</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            moves task to an asyncrounous executer and returns a handle associated
+            with the task
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_resource_error</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.async1">
+      <title><link linkend="boost_task.reference.async1"> Non-member function <code><phrase
+      role="identifier">async</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase
+      role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+      <phrase role="special">&amp;&amp;,</phrase> <phrase role="identifier">pool</phrase><phrase
+      role="special">&lt;</phrase> <phrase role="identifier">Channel</phrase> <phrase
+      role="special">&gt;</phrase> <phrase role="special">&amp;)</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">async</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Channel</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">async</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">,</phrase> <phrase role="identifier">pool</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">Channel</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">ep</phrase><phrase role="special">);</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            moves task into a thread-pool and returns a handle associated with the
+            task
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_rejected</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.async2">
+      <title><link linkend="boost_task.reference.async2"> Non-member function <code><phrase
+      role="identifier">async</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase
+      role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+      <phrase role="special">&amp;&amp;,</phrase> <phrase role="identifier">Attr</phrase><phrase
+      role="special">,</phrase> <phrase role="identifier">pool</phrase><phrase role="special">&lt;</phrase>
+      <phrase role="identifier">Channel</phrase> <phrase role="special">&gt;</phrase>
+      <phrase role="special">&amp;)</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">async</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Channel</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Attr</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">async</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Attr</phrase> <phrase role="identifier">attr</phrase><phrase role="special">,</phrase> <phrase role="identifier">pool</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">Channel</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">ep</phrase><phrase role="special">);</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            moves attributed task into a thread-pool and returns a handle associated
+            with the task
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_rejected</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.own_thread">
+      <title><link linkend="boost_task.reference.own_thread"> Class <code><phrase
+      role="identifier">own_thread</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">async</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">struct</phrase> <phrase role="identifier">own_thread</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">);</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.own_thread.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.own_thread.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_">Member
+        function <code><phrase role="keyword">operator</phrase><phrase role="special">()(</phrase>
+        <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+        <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+        <phrase role="special">&amp;&amp;)</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            moves task in the current thread an returns an handle associated with
+            the task
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.new_thread">
+      <title><link linkend="boost_task.reference.new_thread"> Class <code><phrase
+      role="identifier">new_thread</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">async</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">struct</phrase> <phrase role="identifier">new_thread</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;);</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.new_thread.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.new_thread.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_">Member
+        function <code><phrase role="keyword">operator</phrase><phrase role="special">()(</phrase>
+        <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+        <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+        <phrase role="special">&amp;&amp;)</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">()(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            moves task in a new thread an returns an handle associated with the task
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_resource_error</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.static_pool">
+      <title><link linkend="boost_task.reference.static_pool"> Class template <code><phrase
+      role="identifier">static_pool</phrase></code></link></title>
+      <para>
+        
+<programlisting>	<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+	<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Channel</phrase> <phrase role="special">&gt;</phrase>
+	<phrase role="keyword">class</phrase> <phrase role="identifier">static_pool</phrase> <phrase role="special">:</phrase> <phrase role="keyword">private</phrase> <phrase role="identifier">noncopyable</phrase>
+	<phrase role="special">{</phrase>
+	<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+		<phrase role="identifier">static_pool</phrase><phrase role="special">();</phrase>
+
+		<phrase role="keyword">explicit</phrase> <phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">poolsize</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">psize</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">time_duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">asleep</phrase> <phrase role="special">=</phrase> <phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">microseconds</phrase><phrase role="special">(</phrase> <phrase role="number">10</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">scanns</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">scns</phrase> <phrase role="special">=</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="number">20</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+		<phrase role="keyword">explicit</phrase> <phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase>
+			<phrase role="identifier">poolsize</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">psize</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">high_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">hwm</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">low_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">lwm</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">time_duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">asleep</phrase> <phrase role="special">=</phrase> <phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">milliseconds</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">scanns</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">scns</phrase> <phrase role="special">=</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="number">20</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+		<phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">static_pool</phrase> <phrase role="special">&amp;&amp;);</phrase>
+
+		<phrase role="identifier">static_pool</phrase> <phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase> <phrase role="identifier">static_pool</phrase> <phrase role="special">&amp;&amp;);</phrase>
+
+<phrase role="preprocessor"># if</phrase> <phrase role="identifier">defined</phrase><phrase role="special">(</phrase><phrase role="identifier">BOOST_HAS_PROCESSOR_BINDINGS</phrase><phrase role="special">)</phrase>
+		<phrase role="keyword">explicit</phrase> <phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase>
+			<phrase role="special">&lt;&lt;</phrase><phrase role="identifier">unspec</phrase><phrase role="special">-</phrase><phrase role="identifier">type</phrase><phrase role="special">&gt;&gt;,</phrase>
+			<phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">time_duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">asleep</phrase> <phrase role="special">=</phrase> <phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">microseconds</phrase><phrase role="special">(</phrase> <phrase role="number">10</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">scanns</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">scns</phrase> <phrase role="special">=</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="number">20</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+
+		<phrase role="keyword">explicit</phrase> <phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase>
+			<phrase role="special">&lt;&lt;</phrase><phrase role="identifier">unspec</phrase><phrase role="special">-</phrase><phrase role="identifier">type</phrase><phrase role="special">&gt;&gt;,</phrase>
+			<phrase role="identifier">high_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">hwm</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">low_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">lwm</phrase><phrase role="special">,</phrase>
+			<phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">time_duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">asleep</phrase> <phrase role="special">=</phrase> <phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">milliseconds</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase><phrase role="special">),</phrase>
+			<phrase role="identifier">scanns</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">scns</phrase> <phrase role="special">=</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="number">20</phrase><phrase role="special">)</phrase> <phrase role="special">);</phrase>
+			
+		<phrase role="keyword">static</phrase> <phrase role="special">&lt;&lt;</phrase><phrase role="identifier">unspec</phrase><phrase role="special">-</phrase><phrase role="identifier">type</phrase><phrase role="special">&gt;&gt;</phrase> <phrase role="identifier">bind_to_processors</phrase><phrase role="special">();</phrase>
+<phrase role="preprocessor"># endif</phrase>
+
+		<phrase role="special">~</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">();</phrase>
+
+		<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">size</phrase><phrase role="special">();</phrase>
+		<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">active</phrase><phrase role="special">();</phrase>
+		<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">idle</phrase><phrase role="special">();</phrase>
+
+		<phrase role="keyword">void</phrase> <phrase role="identifier">shutdown</phrase><phrase role="special">();</phrase>
+		<phrase role="keyword">void</phrase> <phrase role="identifier">shutdown_now</phrase><phrase role="special">();</phrase>
+
+		<phrase role="keyword">void</phrase> <phrase role="identifier">interrupt_all_worker</phrase><phrase role="special">();</phrase>
+
+		<phrase role="keyword">bool</phrase> <phrase role="identifier">closed</phrase><phrase role="special">();</phrase>
+		<phrase role="keyword">void</phrase> <phrase role="identifier">clear</phrase><phrase role="special">();</phrase>
+		<phrase role="keyword">bool</phrase> <phrase role="identifier">empty</phrase><phrase role="special">();</phrase>
+		<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">pending</phrase><phrase role="special">();</phrase>
+
+		<phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">();</phrase>
+		<phrase role="keyword">void</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase> <phrase role="identifier">high_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">hwm</phrase><phrase role="special">);</phrase>
+		<phrase role="keyword">const</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">();</phrase>
+		<phrase role="keyword">void</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase> <phrase role="identifier">low_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">lwm</phrase><phrase role="special">);</phrase>
+
+		<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+		<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">submit</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">);</phrase>
+
+		<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Attr</phrase> <phrase role="special">&gt;</phrase>
+		<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">submit</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Attr</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">attr</phrase><phrase role="special">);</phrase>
+
+		<phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase> <phrase role="identifier">static_pool</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">other</phrase><phrase role="special">);</phrase>
+
+		<phrase role="keyword">operator</phrase> <phrase role="identifier">unspecified_bool_type</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+		<phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+	<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.static_pool.default_constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.default_constructor">Default
+        constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">static_pool</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs an unitialized pool
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.constructor__unbounded_channel_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.constructor__unbounded_channel_">Constructor
+        (unbounded channel)</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">explicit</phrase> <phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase>
+	<phrase role="special">&lt;&lt;</phrase><phrase role="identifier">unspec</phrase><phrase role="special">-</phrase><phrase role="identifier">type</phrase><phrase role="special">&gt;&gt;,</phrase>
+	<phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">time_duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">asleep</phrase> <phrase role="special">=</phrase> <phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">microseconds</phrase><phrase role="special">(</phrase> <phrase role="number">10</phrase><phrase role="special">),</phrase>
+	<phrase role="identifier">scanns</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">scns</phrase> <phrase role="special">=</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="number">20</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            operating system provides functionality for processor binding
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a pool - for each processor a worker-thread is created and
+            bound to one processor - global-queue can queue an unlimited number of
+            tasks
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_resource_error</phrase></code>, <code><phrase
+            role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_scanns</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">invalid_timeduration</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            constructor has to be called if a unbounded-channel is used and <code><phrase
+            role="identifier">bind_to_processors</phrase><phrase role="special">()</phrase></code>
+            must be set as first argument
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.constructor__unbounded_channel_poolsize_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.constructor__unbounded_channel_poolsize_">Constructor
+        (unbounded channel/poolsize)</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">explicit</phrase> <phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase>
+	<phrase role="identifier">poolsize</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">psize</phrase><phrase role="special">,</phrase>
+	<phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">time_duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">asleep</phrase> <phrase role="special">=</phrase> <phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">microseconds</phrase><phrase role="special">(</phrase> <phrase role="number">10</phrase><phrase role="special">),</phrase>
+	<phrase role="identifier">scanns</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">scns</phrase> <phrase role="special">=</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="number">20</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a pool containing psize worker-threads - global-queue can
+            queue an unlimited number of tasks
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_resource_error</phrase></code>, <code><phrase
+            role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_scanns</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">invalid_timeduration</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            constructor has to be called if a unbounded-channel is used
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.constructor__bounded_channel_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.constructor__bounded_channel_">Constructor
+        (bounded channel)</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">explicit</phrase> <phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase>
+	<phrase role="special">&lt;&lt;</phrase><phrase role="identifier">unspec</phrase><phrase role="special">-</phrase><phrase role="identifier">type</phrase><phrase role="special">&gt;&gt;,</phrase>
+	<phrase role="identifier">high_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">hwm</phrase><phrase role="special">,</phrase>
+	<phrase role="identifier">low_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">lwm</phrase><phrase role="special">,</phrase>
+	<phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">time_duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">asleep</phrase> <phrase role="special">=</phrase> <phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">milliseconds</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase><phrase role="special">),</phrase>
+	<phrase role="identifier">scanns</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">scns</phrase> <phrase role="special">=</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="number">20</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            operating system provides functionality for processor binding
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a pool - for each processor a worker-thread is created and
+            bound to one processor - global-queue can only queue a limited number
+            of tasks
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_resource_error</phrase></code>, <code><phrase
+            role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_scanns</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">invalid_timeduration</phrase></code>,
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_watermark</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            constructor has to be called if a bounded-channel is used and <code><phrase
+            role="identifier">bind_to_processors</phrase><phrase role="special">()</phrase></code>
+            must be set as first argument
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.constructor__bounded_channel_poolsize_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.constructor__bounded_channel_poolsize_">Constructor
+        (bounded channel/poolsize)</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">explicit</phrase> <phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase>
+	<phrase role="identifier">poolsize</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">psize</phrase><phrase role="special">,</phrase>
+	<phrase role="identifier">high_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">hwm</phrase><phrase role="special">,</phrase>
+	<phrase role="identifier">low_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">lwm</phrase><phrase role="special">,</phrase>
+	<phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">time_duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">asleep</phrase> <phrase role="special">=</phrase> <phrase role="identifier">posix_time</phrase><phrase role="special">::</phrase><phrase role="identifier">milliseconds</phrase><phrase role="special">(</phrase> <phrase role="number">100</phrase><phrase role="special">),</phrase>
+	<phrase role="identifier">scanns</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">scns</phrase> <phrase role="special">=</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="number">20</phrase><phrase role="special">)</phrase> <phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a pool containing psize worker-threads - global-queue can
+            only queue a limited number of tasks
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_resource_error</phrase></code>, <code><phrase
+            role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_scanns</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">invalid_timeduration</phrase></code>,
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_watermark</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            constructor has to be called if a bounded-channel is used
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.move_copy_constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.move_copy_constructor">Move-copy
+        constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">static_pool</phrase><phrase role="special">(</phrase> <phrase role="identifier">static_pool</phrase> <phrase role="special">&amp;&amp;)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            creates an pool out of another one which gets zeroed out
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.move_assigment_constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.move_assigment_constructor">Move-assigment
+        constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">static_pool</phrase> <phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase> <phrase role="identifier">static_pool</phrase> <phrase role="special">&amp;&amp;)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            creates an pool out of another one which gets zeroed out
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.destructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.destructor">Destructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="special">~</phrase><phrase role="identifier">static_pool</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            calls <code><phrase role="identifier">shutdown</phrase><phrase role="special">()</phrase></code>
+            if not already called
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.static_member_function__code__phrase_role__identifier__bind_to_processors__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.static_member_function__code__phrase_role__identifier__bind_to_processors__phrase__phrase_role__special______phrase___code_">Static
+        member function <code><phrase role="identifier">bind_to_processors</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">unspec</phrase><phrase role="special">-</phrase><phrase role="identifier">type</phrase><phrase role="special">&gt;&gt;</phrase> <phrase role="identifier">bind_to_processors</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            used in order to let the pool create worker-threads as cores are available
+            and bound the threads to the cores
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__size__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__size__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">size</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns how many worker-threads are running in the pool
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__active__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__active__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">active</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">active</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns how many worker-threads are active (executing an task)
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__idle__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__idle__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">idle</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">idle</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns how many worker-threads are idle (not executing an task).
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            the value is the difference of <code><phrase role="identifier">size</phrase><phrase
+            role="special">()</phrase></code> and <code><phrase role="identifier">active</phrase><phrase
+            role="special">()</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__shutdown__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__shutdown__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">shutdown</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">shutdown</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            deactivates the channel and joins all worker-threads - the pool is closed
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_interrupted</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">system</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">system_error</phrase></code>,
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            all pending tasks are processed
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__shutdown_now__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__shutdown_now__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">shutdown_now</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">shutdown_now</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            deactivates the channel, send interruption request to all worker-threads
+            and joins them - the pool is closed
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_interrupted</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">system</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">system_error</phrase></code>,
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            pending tasks are not processed but returned
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__interrupt_all_worker__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__interrupt_all_worker__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">interrupt_all_worker</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">interrupt_all_worker</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            interrupts all worker-threads without invalidating the pool
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__closed__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__closed__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">closed</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="identifier">closed</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            queries if the pool is closed (pool is shutdown)
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__clear__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__clear__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">clear</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">clear</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            removes all pending tasks from the channel
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__empty__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__empty__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">empty</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="identifier">empty</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            queries if the channel is empty
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__pending__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__pending__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">pending</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">pending</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            queries how many tasks are pending (still unprocessed) in the global-queue
+            (channel)
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__upper_bound__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__upper_bound__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">upper_bound</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            channel is of type bounded-channel
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns the upper bound of the bounded-channel
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            can only be used if a bounded-channel is used
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__upper_bound__phrase__phrase_role__special_____phrase___phrase_role__identifier__high_watermark__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__hwm__phrase__phrase_role__special_____phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__upper_bound__phrase__phrase_role__special_____phrase___phrase_role__identifier__high_watermark__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__hwm__phrase__phrase_role__special_____phrase___code_">Member
+        function <code><phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase>
+        <phrase role="identifier">high_watermark</phrase> <phrase role="keyword">const</phrase><phrase
+        role="special">&amp;</phrase> <phrase role="identifier">hwm</phrase><phrase
+        role="special">)</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">upper_bound</phrase><phrase role="special">(</phrase> <phrase role="identifier">high_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">hwm</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            channel is of type bounded-channel
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            sets the upper bound of the bounded-channel
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Postconditions:</term>
+        <listitem>
+          <para>
+            <code><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase
+            role="identifier">upper_bound</phrase><phrase role="special">()</phrase>
+            <phrase role="special">==</phrase> <phrase role="identifier">hwm</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_watermark</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            can only be used if a bounded-channel is used
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__lower_bound__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__lower_bound__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="identifier">lower_bound</phrase><phrase role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">();</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            channel is of type bounded-channel
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns the lower bound of the bounded-channel
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            can only be used if a bounded-channel is used
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__lower_bound__phrase__phrase_role__special_____phrase___phrase_role__identifier__low_watermark__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__lwm__phrase__phrase_role__special_____phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__lower_bound__phrase__phrase_role__special_____phrase___phrase_role__identifier__low_watermark__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__lwm__phrase__phrase_role__special_____phrase___code_">Member
+        function <code><phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase>
+        <phrase role="identifier">low_watermark</phrase> <phrase role="keyword">const</phrase><phrase
+        role="special">&amp;</phrase> <phrase role="identifier">lwm</phrase><phrase
+        role="special">)</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">lower_bound</phrase><phrase role="special">(</phrase> <phrase role="identifier">low_watermark</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">lwm</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            channel is of type bounded-channel
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            sets the lower bound of the bounded-channel
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Postconditions:</term>
+        <listitem>
+          <para>
+            <code><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase
+            role="identifier">lower_bound</phrase><phrase role="special">()</phrase>
+            <phrase role="special">==</phrase> <phrase role="identifier">lwm</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_watermark</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Notes:</term>
+        <listitem>
+          <para>
+            can only be used if a bounded-channel is used
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__submit__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__submit__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_">Member
+        function <code><phrase role="identifier">submit</phrase><phrase role="special">(</phrase>
+        <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+        <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+        <phrase role="special">&amp;&amp;)</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">submit</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            has_attribute&lt; pool &gt;::value == false &amp;&amp; ! closed()
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            moves an task to the pool and returns an associated handle
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_rejected</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__submit__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___phrase_role__identifier__attr__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__attr__phrase__phrase_role__special_____phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__submit__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___phrase_role__identifier__attr__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__attr__phrase__phrase_role__special_____phrase___code_">Member
+        function <code><phrase role="identifier">submit</phrase><phrase role="special">(</phrase>
+        <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase>
+        <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase>
+        <phrase role="special">&amp;&amp;,</phrase> <phrase role="identifier">Attr</phrase>
+        <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase>
+        <phrase role="identifier">attr</phrase><phrase role="special">)</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">R</phrase><phrase role="special">,</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Attr</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">handle</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">submit</phrase><phrase role="special">(</phrase> <phrase role="identifier">task</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">R</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&amp;&amp;</phrase> <phrase role="identifier">t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Attr</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">attr</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            has_attribute&lt; pool &gt;::value == true &amp;&amp; ! closed()
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            moves an task to the pool and returns an associated handle - task is
+            scheduled by the attribute
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_rejected</phrase></code>, <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">task</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">pool_moved</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.member_function_swap__static_pool__amp___"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.member_function_swap__static_pool__amp___">Member
+        function swap( static_pool &amp;)`</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">swap</phrase><phrase role="special">(</phrase> <phrase role="identifier">static_pool</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">other</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            swaps pool
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.operator__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__unspecified_bool_type__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.operator__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__unspecified_bool_type__phrase__phrase_role__special______phrase___code_">operator
+        <code><phrase role="keyword">operator</phrase> <phrase role="identifier">unspecified_bool_type</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">operator</phrase> <phrase role="identifier">unspecified_bool_type</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            is static_pool valid == does static_pool own ownership
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.static_pool.operator__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.static_pool.operator__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___code_">operator
+        <code><phrase role="keyword">operator</phrase><phrase role="special">!()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">bool</phrase> <phrase role="keyword">operator</phrase><phrase role="special">!()</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            is static_pool invalid == static_pool does not have ownership
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.reschedule_until">
+      <title><link linkend="boost_task.reference.reschedule_until"> Non-member function
+      <code><phrase role="identifier">reschedule_until</phrase><phrase role="special">()</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">utility</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Pred</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">void</phrase> <phrase role="identifier">reschedule_until</phrase><phrase role="special">(</phrase> <phrase role="identifier">Pred</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;)</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            reschedules current task until passed callable predicate becomes ready
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">thread_interrupted</phrase></code>,<code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">system</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">system_error</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Note:</term>
+        <listitem>
+          <para>
+            this function resides in namespace <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">this_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.get_pool">
+      <title><link linkend="boost_task.reference.get_pool"> Non-member function
+      <code><phrase role="identifier">get_pool</phrase><phrase role="special">()</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">utility</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Pool</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="identifier">Pool</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">get_pool</phrase><phrase role="special">()</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns reference to the thread-pool where the current worker thread
+            is executed
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Note:</term>
+        <listitem>
+          <para>
+            this function resides in namespace <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">this_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.runs_in_pool">
+      <title><link linkend="boost_task.reference.runs_in_pool"> Non-member function
+      <code><phrase role="identifier">runs_in_pool</phrase><phrase role="special">()</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">utility</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">bool</phrase> <phrase role="identifier">runs_in_pool</phrase><phrase role="special">()</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns true if the current task is executed in a thread-pool
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Note:</term>
+        <listitem>
+          <para>
+            this function resides in namespace <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">this_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.worker_id">
+      <title><link linkend="boost_task.reference.worker_id"> Non-member function
+      <code><phrase role="identifier">worker_id</phrase><phrase role="special">()</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">utility</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="identifier">id</phrase> <phrase role="identifier">worker_id</phrase><phrase role="special">()</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns returns the thread-id of the worker-thread
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Note:</term>
+        <listitem>
+          <para>
+            this function resides in namespace <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">this_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.delay">
+      <title><link linkend="boost_task.reference.delay"> Non-member function <code><phrase
+      role="identifier">delay</phrase><phrase role="special">()</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">utility</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">delay</phrase><phrase role="special">(</phrase> <phrase role="identifier">system_time</phrase> <phrase role="identifier">abs_time</phrase><phrase role="special">)</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Duration</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">void</phrase> <phrase role="identifier">delay</phrase><phrase role="special">(</phrase> <phrase role="identifier">Duration</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">rel_time</phrase><phrase role="special">)</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            delays the execution of the current task so that the worker-thread can
+            process another task in the meantime
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Note:</term>
+        <listitem>
+          <para>
+            this function resides in namespace <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">this_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.yield">
+      <title><link linkend="boost_task.reference.yield"> Non-member function <code><phrase
+      role="identifier">yield</phrase><phrase role="special">()</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">utility</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">yield</phrase><phrase role="special">()</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            yields the current task so that the worker-threadcan process another
+            task in the meantime
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Note:</term>
+        <listitem>
+          <para>
+            this function resides in namespace <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">this_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.interrupt">
+      <title><link linkend="boost_task.reference.interrupt"> Non-member function
+      <code><phrase role="identifier">interrupt</phrase><phrase role="special">()</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">utility</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">void</phrase> <phrase role="identifier">interrupt</phrase><phrase role="special">()</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            task can request interruption for itself
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Note:</term>
+        <listitem>
+          <para>
+            this function resides in namespace <code><phrase role="identifier">boost</phrase><phrase
+            role="special">::</phrase><phrase role="identifier">this_task</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.has_attribute">
+      <title><link linkend="boost_task.reference.has_attribute"> Meta function <code><phrase
+      role="identifier">has_attribute</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">meta</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Pool</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">struct</phrase> <phrase role="identifier">has_attribute</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">mpl</phrase><phrase role="special">::</phrase><phrase role="identifier">bool_</phrase><phrase role="special">&lt;</phrase>
+	<phrase role="identifier">is_same</phrase><phrase role="special">&lt;</phrase>
+		<phrase role="identifier">detail</phrase><phrase role="special">::</phrase><phrase role="identifier">has_priority</phrase><phrase role="special">,</phrase>
+		<phrase role="keyword">typename</phrase> <phrase role="identifier">Pool</phrase><phrase role="special">::</phrase><phrase role="identifier">scheduler_type</phrase><phrase role="special">::</phrase><phrase role="identifier">priority_tag_type</phrase>
+	<phrase role="special">&gt;::</phrase><phrase role="identifier">value</phrase>
+<phrase role="special">&gt;</phrase>
+<phrase role="special">{};</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns true if Pool supports attributes (priority-scheduling)
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.attribute_type">
+      <title><link linkend="boost_task.reference.attribute_type"> Meta function
+      <code><phrase role="identifier">attribute_type</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">meta</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Pool</phrase> <phrase role="special">&gt;</phrase>
+<phrase role="keyword">struct</phrase> <phrase role="identifier">attribute_type</phrase>
+<phrase role="special">{</phrase>
+	<phrase role="keyword">typedef</phrase> <phrase role="keyword">typename</phrase> <phrase role="identifier">Pool</phrase><phrase role="special">::</phrase><phrase role="identifier">scheduler_type</phrase><phrase role="special">::</phrase><phrase role="identifier">attribute_type</phrase>   <phrase role="identifier">type</phrase><phrase role="special">;</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns type of attribute
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.poolsize">
+      <title><link linkend="boost_task.reference.poolsize"> Class <code><phrase role="identifier">poolsize</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">poolsize</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">poolsize</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="keyword">explicit</phrase> <phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">value</phrase><phrase role="special">);</phrase>
+
+	<phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.poolsize.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.poolsize.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">explicit</phrase> <phrase role="identifier">poolsize</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">value</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            value &gt; 0
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">poolsize</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Postconditions:</term>
+        <listitem>
+          <para>
+            operator std::size_t () &gt; 0
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_poolsize</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.poolsize.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.poolsize.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">size_t</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="special">()</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns the value
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.high_watermark">
+      <title><link linkend="boost_task.reference.high_watermark"> Class <code><phrase
+      role="identifier">high_watermark</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">watermark</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">high_watermark</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="keyword">explicit</phrase> <phrase role="identifier">high_watermark</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">value</phrase><phrase role="special">);</phrase>
+
+	<phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.high_watermark.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.high_watermark.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">explicit</phrase> <phrase role="identifier">high_watermark</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">value</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">tp</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">high_watermark</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_watermark</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.high_watermark.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.high_watermark.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">size_t</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="special">()</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns high watermark
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.low_watermark">
+      <title><link linkend="boost_task.reference.low_watermark"> Class <code><phrase
+      role="identifier">low_watermark</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">watermark</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">low_watermark</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="keyword">explicit</phrase> <phrase role="identifier">low_watermark</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">value</phrase><phrase role="special">);</phrase>
+
+	<phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.low_watermark.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.low_watermark.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">explicit</phrase> <phrase role="identifier">low_watermark</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">value</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">low_watermark</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_watermark</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.low_watermark.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.low_watermark.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">size_t</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="special">()</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns low watermark
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.scanns">
+      <title><link linkend="boost_task.reference.scanns"> Class <code><phrase role="identifier">scanns</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">scanns</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">scanns</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="keyword">explicit</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">value</phrase><phrase role="special">);</phrase>
+
+	<phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.scanns.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.scanns.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">explicit</phrase> <phrase role="identifier">scanns</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">value</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Preconditions:</term>
+        <listitem>
+          <para>
+            value &gt; 0
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">scanns</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Postconditions:</term>
+        <listitem>
+          <para>
+            operator std::size_t () &gt; 0
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_poolsize</phrase></code>
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+      <anchor id="boost_task.reference.scanns.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.scanns.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_">Member
+        function <code><phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase
+        role="special">::</phrase><phrase role="identifier">size_t</phrase><phrase
+        role="special">()</phrase></code></link>
+      </bridgehead>
+      
+<programlisting><phrase role="keyword">operator</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="special">()</phrase> <phrase role="keyword">const</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            returns the value
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            Nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.invalid_poolsize">
+      <title><link linkend="boost_task.reference.invalid_poolsize"> Class <code><phrase
+      role="identifier">invalid_poolsize</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">invalid_poolsize</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">invalid_argument</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">invalid_poolsize</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">);</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.invalid_poolsize.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.invalid_poolsize.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">invalid_poolsize</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">);</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_poolsize</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.invalid_scanns">
+      <title><link linkend="boost_task.reference.invalid_scanns"> Class <code><phrase
+      role="identifier">invalid_scanns</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">invalid_scanns</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">invalid_argument</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">invalid_scanns</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">);</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.invalid_scanns.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.invalid_scanns.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">invalid_scanns</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_scanns</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.invalid_timeduration">
+      <title><link linkend="boost_task.reference.invalid_timeduration"> Class <code><phrase
+      role="identifier">invalid_timeduration</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">invalid_timeduration</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">invalid_argument</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">invalid_timeduration</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">);</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.invalid_timeduration.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.invalid_timeduration.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">invalid_timeduration</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_timeduration</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.invalid_watermark">
+      <title><link linkend="boost_task.reference.invalid_watermark"> Class <code><phrase
+      role="identifier">invalid_watermark</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">invalid_watermark</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">invalid_argument</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">invalid_watermark</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">);</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.invalid_watermark.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.invalid_watermark.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">invalid_watermark</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">invalid_watermark</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.task_rejected">
+      <title><link linkend="boost_task.reference.task_rejected"> Class <code><phrase
+      role="identifier">task_rejected</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">task_rejected</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">runtime_error</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">task_rejected</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">);</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.task_rejected.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task_rejected.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task_rejected</phrase><phrase role="special">(</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_rejected</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.task_unitialized">
+      <title><link linkend="boost_task.reference.task_unitialized"> Class <code><phrase
+      role="identifier">task_unitialized</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">task_unitialized</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">logic_error</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">task_unitialized</phrase><phrase role="special">();</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.task_unitialized.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task_unitialized.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task_unitialized</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_unitialized</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.task_already_executed">
+      <title><link linkend="boost_task.reference.task_already_executed"> Class <code><phrase
+      role="identifier">task_already_executed</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">task_already_executed</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">logic_error</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">task_already_executed</phrase><phrase role="special">();</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.task_already_executed.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task_already_executed.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task_already_executed</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_already_executed</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.task_moved">
+      <title><link linkend="boost_task.reference.task_moved"> Class <code><phrase
+      role="identifier">task_moved</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">task_moved</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">logic_error</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">task_moved</phrase><phrase role="special">();</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.task_moved.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task_moved.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task_moved</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_moved</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.broken_task">
+      <title><link linkend="boost_task.reference.broken_task"> Class <code><phrase
+      role="identifier">broken_task</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">broken_task</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">logic_error</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">broken_task</phrase><phrase role="special">();</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.broken_task.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.broken_task.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">broken_task</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">broken_task</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.task_interrupted">
+      <title><link linkend="boost_task.reference.task_interrupted"> Class <code><phrase
+      role="identifier">task_interrupted</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">task_interrupted</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">runtime_error</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">task_interrupted</phrase><phrase role="special">();</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.task_interrupted.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.task_interrupted.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">task_interrupted</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task_interrupted</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+    <section id="boost_task.reference.pool_moved">
+      <title><link linkend="boost_task.reference.pool_moved"> Class <code><phrase
+      role="identifier">pool_moved</phrase></code></link></title>
+      <para>
+        
+<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">task</phrase><phrase role="special">/</phrase><phrase role="identifier">exceptions</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
+
+<phrase role="keyword">class</phrase> <phrase role="identifier">pool_moved</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">logic_error</phrase>
+<phrase role="special">{</phrase>
+<phrase role="keyword">public</phrase><phrase role="special">:</phrase>
+	<phrase role="identifier">pool_moved</phrase><phrase role="special">();</phrase>
+<phrase role="special">};</phrase>
+</programlisting>
+      </para>
+      <anchor id="boost_task.reference.pool_moved.constructor"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.reference.pool_moved.constructor">Constructor</link>
+      </bridgehead>
+      
+<programlisting><phrase role="identifier">pool_moved</phrase><phrase role="special">()</phrase>
+</programlisting>
+      <variablelist>
+        <title></title> <varlistentry><term>Effects:</term>
+        <listitem>
+          <para>
+            constructs a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+            role="identifier">pool_moved</phrase></code> instance
+          </para>
+        </listitem>
+        </varlistentry> <varlistentry><term>Throws:</term>
+        <listitem>
+          <para>
+            nothing
+          </para>
+        </listitem>
+        </varlistentry>
+      </variablelist>
+    </section>
+  </section>
+  <section id="boost_task.appendices">
+    <title><link linkend="boost_task.appendices">Appendices</link></title>
+    <section id="boost_task.appendices.todo">
+      <title><link linkend="boost_task.appendices.todo"> Appendix A: Future development</link></title>
+      <anchor id="boost_task.appendices.todo.dynamic_thread_pool"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.appendices.todo.dynamic_thread_pool">Dynamic thread-pool</link>
+      </bridgehead>
+      <itemizedlist>
+        <listitem>
+          <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
+          role="identifier">task</phrase><phrase role="special">::</phrase><phrase
+          role="identifier">dynamic_pool</phrase></code> adds or removes <emphasis>worker-threads</emphasis>
+          from the <emphasis>thread-pool</emphasis> depending on the work-load (undersubscription/
+          oversubscription).
+        </listitem>
+      </itemizedlist>
+      <anchor id="boost_task.appendices.todo.communication_and_synchronisation_abstractions"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.appendices.todo.communication_and_synchronisation_abstractions">Communication
+        and synchronisation abstractions</link>
+      </bridgehead>
+      <itemizedlist>
+        <listitem>
+          <emphasis role="bold">Event variable</emphasis>: A event variable is a
+          bivalued variable (up/down) on which a task can wait for an event to be
+          set or reset. The calling task will be suspended until the state of the
+          event variable is that required by the caller.
+        </listitem>
+        <listitem>
+          <emphasis role="bold">Buffer</emphasis>: A bounded/unbounded buffer is
+          shared between several tasks. The data must be placed in, and retrieved
+          from, the buffer under mutual exclusion. Condition synchronisation is required
+          because a calling task attempting to place data into the buffer. When the
+          buffer is full, the task must be suspended until there is space int the
+          buffer. Also a retrieving task must be suspended when the buffer is empty.
+          The data, once read, is destroyed.
+        </listitem>
+        <listitem>
+          <emphasis role="bold">Multicast</emphasis>: The data is sent to a specific
+          group of tasks and all tasks in the group should receive the data. Only
+          when all tasks have received one item of data then another item is allowed
+          to be transmitted.
+        </listitem>
+        <listitem>
+          <emphasis role="bold">Rendezvous</emphasis>: A rendezvous uses direct naming
+          and synchronous communication between tasks. One task that executes its
+          command first will be delayed until the other tasks is ready to rendezvous.
+        </listitem>
+        <listitem>
+          <emphasis role="bold">Protected resource</emphasis>: A protected resource
+          is a passive entity that controls access to the internal states (to the
+          controled real resources).
+        </listitem>
+        <listitem>
+          <emphasis role="bold">Task groups</emphasis>: A task group defines a graph
+          of interdependent tasks that can mostly be run in parallel. The tasks in
+          the group have dependencies or communicate with each other.
+        </listitem>
+      </itemizedlist>
+      <anchor id="boost_task.appendices.todo.interdepended_task"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.appendices.todo.interdepended_task">Interdepended
+        task</link>
+      </bridgehead>
+      <itemizedlist>
+        <listitem>
+          With special support of concurrence and synchronisation abstractions interdepended
+          tasks work in <emphasis>thread-pools</emphasis> without deadlocking the
+          pool.
+        </listitem>
+      </itemizedlist>
+      <anchor id="boost_task.appendices.todo.optimizations"/>
+      <bridgehead renderas="sect4">
+        <link linkend="boost_task.appendices.todo.optimizations">Optimizations</link>
+      </bridgehead>
+      <itemizedlist>
+        <listitem>
+          two-lock-queue as global queue in <emphasis>thread-pool</emphasis>
+        </listitem>
+        <listitem>
+          maybe lock-free-queue as global queue too (how to provide the scheduling
+          policies fifo, priority, smart?)
+        </listitem>
+      </itemizedlist>
+    </section>
+    <section id="boost_task.appendices.acknowledgements">
+      <title><link linkend="boost_task.appendices.acknowledgements"> Appendix B:
+      Acknowledgments</link></title>
+      <para>
+        I'd like to thank Vicente J. Botet Escriba for his comments and contributions
+        (this_task::reschedule_until, this_task::delay, this_task::yield) as well
+        Anthony Williams and Braddock Gaskill for their future libraries.
+      </para>
+    </section>
+  </section>
+</library>
diff -urN boost/libs/task/doc/channel.qbk boost-altered/libs/task/doc/channel.qbk
--- boost/libs/task/doc/channel.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/channel.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,31 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:channel Channel]
+
+The channel synchronizes the access between non-pool threads (application threads)  and __worker_threads__ and implements
+a queuing policy (limitation of queued tasks).
+
+
+[heading __bounded_channel__]
+
+__bounded_channel__ contains a single lock in order to synchronize access to the queue. The number of pending tasks is limited in order to prevent resource exhaustion.
+For this purpose a high- and low-watermark has to be passed at construction.
+__hwm__ sets the maximum of pending tasks. If this limited is reached all threads which submit a task will be set to sleep (blocked). If it is equal to __lwm__ everytime a 
+sleeping producer thread will be woken up and puts its task if one worker thread has taken a task from the channel.
+__lwm__ sets the threshold when blocked threads get woken up. If it is less than __hwm__ all sleeping producer threads will be woken up if
+the amount of pending tasks reaches __lwm__.
+
+
+[heading __unbounded_channel__]
+
+__unbounded_channel__ contains a single lock in order to synchronize access to the queue. An unlimited number of tasks can be queued into this channel.
+The insertion of an __task__ will never block. If the channel becomes empty __worker_threads__ will be set to sleep until new tasks are enqueued.
+
+
+[endsect]
diff -urN boost/libs/task/doc/.directory boost-altered/libs/task/doc/.directory
--- boost/libs/task/doc/.directory	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/.directory	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,5 @@
+[Dolphin]
+AdditionalInfo=35
+Sorting=6
+Timestamp=2009,6,19,17,21,50
+ViewMode=1
diff -urN boost/libs/task/doc/execution_policy.qbk boost-altered/libs/task/doc/execution_policy.qbk
--- boost/libs/task/doc/execution_policy.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/execution_policy.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,22 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:execution_policy Execution policy]
+
+In contrast to synchronous methods asynchronous methods do not block the program flow when a time consuming operation is executed.
+The application continues executing the current context and when the result of the asynchronous method is required the __act__ can be used.
+
+A __ep__ describes how a __task__ gets asynchronously executed and provides a link_handle(__act__) to manage the __task__.
+
+[include own_thread.qbk]
+[include new_thread.qbk]
+[include pool.qbk]
+[include as_sub_task.qbk]
+
+
+[endsect] 
diff -urN boost/libs/task/doc/fork_join.qbk boost-altered/libs/task/doc/fork_join.qbk
--- boost/libs/task/doc/fork_join.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/fork_join.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,80 @@
+/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:forkjoin Fork/Join]
+
+Fork/Join algorithms are recursive divide-and-conquer algorithms which repeatedly splitt into sub-tasks until they become small
+enough to solve using simple, short sequential methods, so that they run in parallel on multiple cores.
+
+The fork operation creates new __sub_tasks__ which can run in parallel. The current __task__ is not proceeded in the join operation
+until the forked __sub_tasks__ have completed. In the meantime the __worker_thread__ executes other tasks from its local __worker_queue__.
+
+``
+	long serial_fib( long n)
+	{
+		if( n < 2) return n;
+		else return serial_fib( n - 1) + serial_fib( n - 2);
+	}
+
+	long parallel_fib( long n, long cutof)
+	{
+		if ( n < cutof) return serial_fib( n);
+		else
+		{
+			// create a sub-task calculating fibonacci(n-1)
+			boost::task::task< long > t1(
+				parallel_fib,
+				n - 1,
+				cutof);
+			// create a sub-task calculating fibonacci(n-2)
+			boost::task< long > t2(
+				parallel_fib,
+				n - 2,
+				cutof);
+
+			// fork both sub-tasks by moving the task
+			// ownership to the thread-pool
+			h1 = boost::task::async( boost::move( t1) );
+			h2 = boost::task::async( boost::move( t2) );
+
+			// join the results of both sub-tasks
+			// if one of the both sub-tasks is not ready
+			// the worker-thread does not block, it executes other
+			// task from its local-queue
+			return h1.get() + h2.get();
+		}
+	}
+
+	void main()
+	{
+		boost::task::static_pool<
+			boost::task::unbounded_channel<
+				boost::task::fifo
+			>
+		> pool( boost::task::poolsize( 5) );
+
+		// compute fibonacci-number 10
+		// for numbers < 5 do inline calculation
+		boost::task::task< long > t(
+			parallel_fib,
+			10,
+			5);
+
+		// move task ownership to thread-pool
+		boost::task::handle< long > h(
+			boost::task::async(
+				boost::move( t),
+				pool) );
+
+		// access result
+		std::cout << "fibonacci(10) == " << h.get() << std::endl;
+	}
+``
+
+
+[endsect]
diff -urN boost/libs/task/doc/handle.qbk boost-altered/libs/task/doc/handle.qbk
--- boost/libs/task/doc/handle.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/handle.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,209 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:handle Handle] 
+
+The __act__ dispatches tasks in response to the completion of asynchronous operations. __act__ uniquely identifies
+the task and state necessary to process the result of the operation [footnote see [@http://www.cs.wustl.edu/~schmidt/PDF/ACT.pdf
+'Asynchronous Completion Token'], Douglas Schmidt]. 
+
+__handle__ represents an __act__. It will be returned by [link_async __fn_async__] and is associated with the submitted __task__.
+
+
+[heading Asynchronous completion token interface]
+
+__handle__ implements an interface in order to check the state of computation and to transfer the result.
+
+* __fn_is_ready__: test if result is set
+
+* __fn_has_value__: test if value-result is set
+
+* __fn_has_exception__: test if exception-result is set
+
+* __fn_get__: return value-result or throw the exception-result
+
+* __fn_wait__: wait until result is set
+
+* __fn_wait_for__: wait until result is set or time-duration has elapsed
+
+* __fn_wait_until__: wait until result ist set or time-point has elapsed
+
+``
+	long fibonacci( long n)
+	{
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+		return k1;
+	}
+
+	void main()
+	{
+		// create task
+		boost::task::task< long > t( fibonacci, 10);
+
+		// move task ownership to executor
+		boost::task::handle< long > h(
+			boost::task::async(
+				boost::move( t),
+				boost::task::new_thread() ) );
+
+		std::cout << "is ready == " << std::boolalpha << h.is_ready() << "\n";
+
+		// wait for task completion
+		h.wait();
+
+		std::cout << "has value == " << std::boolalpha << h.has_value() << "\n";
+		std::cout << "has exception == " << std::boolalpha << h.has_exception() << "\n";
+
+		// return result
+		std::cout << "fibonacci(10) == " << h.get() << std::endl;
+	}
+``
+
+
+[heading Task interruption]
+
+Each invokation of __fn_async__ returns an __handle__ which allows to control the associated __task__ (passed to __fn_async__). This includes
+the ability to interrupt an __task__ if it is cooperative. Cooperative means that the __task__ contains __interruption_points__ or checks for
+interruption requests [footnote see [@http://www.ddj.com/architect/207100682 'Interrupt Politely'], Herb Sutter].
+
+* __fn_interrupt__: interrupt __task__ and return immediately
+
+* __fn_interrupt_and_wait__: interrupt and wait until __task__ was removed from __worker_thread__
+
+* __fn_interrupt_and_wait_for__: interrupt and wait until __task__ was removed from __worker_thread__ or time duration has elapsed
+
+* __fn_interrupt_and_wait_until__: interrupt and wait until __task__ was removed from __worker_thread__ or time point has reached
+
+* __fn_interruption_requested__: return bool if interruption was requested
+
+``
+	long cooperative( long n)
+	{
+		boost::this_thread::interruption_point(); // interruption point
+
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			if ( boost::this_thread::interruption_requested() )	// check if interruption was requested
+				return;
+
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+
+		boost::this_thread::interruption_point();  // interruption point
+
+		return k1;
+	}
+
+	void main()
+	{
+		// task, to be executed asynchronously
+		boost::task::task< long > t( cooperative, 10);
+
+		// move task to async. executor
+		boost::task::handle< long > h(
+			boost::task::async(
+				boost::move( t),
+				boost::task::new_thread() ) );
+
+		// interrupt task and wait until task is removed by worker-thread
+		h.interrupt_and_wait();
+
+		std::cout << "is ready == " << std::boolalpha << h.is_ready() << "\n";
+		std::cout << "has value == " << std::boolalpha << h.has_value() << "\n";
+		std::cout << "has exception == " << std::boolalpha << h.has_exception() << "\n";
+
+		// access result
+		// throws boost::task::task_interrupted
+		std::cout << h.get() << std::endl;
+	}
+``
+
+[note If the task is still pending (not executed yet) when an interruption is requested - the task is not removed from the queue, it is marked to be interrupted instead.]
+
+
+[heading Waiting for handles]
+
+__boost_task__ provides function __waitfor_all__ waits for all handles passed to this function to become ready
+
+
+``
+	void main()
+	{
+		std::vector handles< boost::task::handle< long > > results;
+		results.reserve( 10);
+
+		for ( int i = 0; i < 10; ++i)
+		{
+			boost::task::task< long > t( fibonacci, i);
+
+			results.push_back(
+				boost::task::async(
+					boost::move( t) ) );
+		}
+
+		// wait until all tasks are ready
+		boost::task::waitfor_all( results.begin(), results.end() );
+
+		int k = 0;
+		std::vector< boost::task::handle< long > >::iterator e( results.end() );
+		for (
+			std::vector< boost::task::handle< long > >::iterator i( results.begin() );
+			i != e;
+			++i)
+			std::cout << "fibonacci(" << k++ << ") == " << i->get() << std::endl;
+	}
+``
+
+
+and __waitfor_any__ which returns if at least one of the passed handles becomes ready.
+
+
+``
+	void main()
+	{
+		boost::task::task< long > t1( cooperative, 10);
+		boost::task::task< long > t2( cooperative, 7);
+		 boost::task::task< long > t3( cooperative, 5);
+
+		boost::task::handle< long > h1(
+			boost::task::async(
+				boost::move( t1) ) );
+		boost::task::handle< long > h2(
+			boost::task::async(
+				boost::move( t2) ) );
+		boost::task::handle< long > h3(
+			boost::task::async(
+				boost::move( t3) ) );
+
+		// wait for any task becomes ready
+		boost::task::waitfor_any( h1, h2, h3);
+
+		if ( h1.is_ready() )
+			std::cout << "fibonacci(10) == " << h1.get() << std::endl;
+		if ( h2.is_ready() )
+			std::cout << "fibonacci(7) == " << h2.get() << std::endl;
+		if ( h3.is_ready() )
+			std::cout << "fibonacci(5) == " << h3.get() << std::endl;
+	}
+``
+
+
+[endsect]
diff -urN boost/libs/task/doc/html/boostbook.css boost-altered/libs/task/doc/html/boostbook.css
--- boost/libs/task/doc/html/boostbook.css	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boostbook.css	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,594 @@
+/*=============================================================================
+    Copyright (c) 2004 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Distributed under the Boost Software License, Version 1.0. (See accompany-
+    ing file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+
+/*=============================================================================
+    Body defaults
+=============================================================================*/
+
+    body
+    {
+        margin: 1em;
+        font-family: sans-serif;
+    }
+
+/*=============================================================================
+    Paragraphs
+=============================================================================*/
+
+    p
+    {
+        text-align: left;
+        font-size: 10pt;
+        line-height: 1.15;
+    }
+
+/*=============================================================================
+    Program listings
+=============================================================================*/
+
+    /* Code on paragraphs */
+    p tt.computeroutput
+    {
+        font-size: 9pt;
+    }
+
+    pre.synopsis
+    {
+        font-size: 90%;
+        margin: 1pc 4% 0pc 4%;
+        padding: 0.5pc 0.5pc 0.5pc 0.5pc;
+    }
+
+    .programlisting,
+    .screen
+    {
+        font-size: 9pt;
+        display: block;
+        margin: 1pc 4% 0pc 4%;
+        padding: 0.5pc 0.5pc 0.5pc 0.5pc;
+    }
+
+    /* Program listings in tables don't get borders */
+    td .programlisting,
+    td .screen
+    {
+        margin: 0pc 0pc 0pc 0pc;
+        padding:  0pc 0pc 0pc 0pc;
+    }
+
+/*=============================================================================
+    Headings
+=============================================================================*/
+
+    h1, h2, h3, h4, h5, h6
+    {
+        text-align: left;
+        margin: 1em 0em 0.5em 0em;
+        font-weight: bold;
+    }
+
+    h1 { font: 140% }
+    h2 { font: bold 140% }
+    h3 { font: bold 130% }
+    h4 { font: bold 120% }
+    h5 { font: italic 110% }
+    h6 { font: italic 100% }
+
+    /* Top page titles */
+    title,
+    h1.title,
+    h2.title
+    h3.title,
+    h4.title,
+    h5.title,
+    h6.title,
+    .refentrytitle
+    {
+        font-weight: bold;
+        margin-bottom: 1pc;
+    }
+
+    h1.title { font-size: 140% }
+    h2.title { font-size: 140% }
+    h3.title { font-size: 130% }
+    h4.title { font-size: 120% }
+    h5.title { font-size: 110% }
+    h6.title { font-size: 100% }
+
+    .section h1
+    {
+        margin: 0em 0em 0.5em 0em;
+        font-size: 140%;
+    }
+
+    .section h2 { font-size: 140% }
+    .section h3 { font-size: 130% }
+    .section h4 { font-size: 120% }
+    .section h5 { font-size: 110% }
+    .section h6 { font-size: 100% }
+
+    /* Code on titles */
+    h1 tt.computeroutput { font-size: 140% }
+    h2 tt.computeroutput { font-size: 140% }
+    h3 tt.computeroutput { font-size: 130% }
+    h4 tt.computeroutput { font-size: 120% }
+    h5 tt.computeroutput { font-size: 110% }
+    h6 tt.computeroutput { font-size: 100% }
+
+/*=============================================================================
+    Author
+=============================================================================*/
+
+    h3.author
+    {
+        font-size: 100%
+    }
+
+/*=============================================================================
+    Lists
+=============================================================================*/
+
+    li
+    {
+        font-size: 10pt;
+        line-height: 1.3;
+    }
+
+    /* Unordered lists */
+    ul
+    {
+        text-align: left;
+    }
+
+    /* Ordered lists */
+    ol
+    {
+        text-align: left;
+    }
+
+/*=============================================================================
+    Links
+=============================================================================*/
+
+    a
+    {
+        text-decoration: none; /* no underline */
+    }
+
+    a:hover
+    {
+        text-decoration: underline;
+    }
+
+/*=============================================================================
+    Spirit style navigation
+=============================================================================*/
+
+    .spirit-nav
+    {
+        text-align: right;
+    }
+
+    .spirit-nav a
+    {
+        color: white;
+        padding-left: 0.5em;
+    }
+
+    .spirit-nav img
+    {
+        border-width: 0px;
+    }
+
+/*=============================================================================
+    Copyright footer
+=============================================================================*/
+    .copyright-footer
+    {
+        text-align: right;
+        font-size: 70%;
+    }
+
+    .copyright-footer p
+    {
+        text-align: right;
+        font-size: 80%;
+    }
+
+/*=============================================================================
+    Table of contents
+=============================================================================*/
+
+    .toc
+    {
+       margin: 1pc 4% 0pc 4%;
+       padding: 0.1pc 1pc 0.1pc 1pc;
+       font-size: 80%;
+       line-height: 1.15;
+    }
+
+    .boost-toc
+    {
+       float: right;
+       padding: 0.5pc;
+    }
+
+/*=============================================================================
+    Tables
+=============================================================================*/
+
+    .table-title,
+    div.table p.title
+    {
+        margin-left: 4%;
+        padding-right: 0.5em;
+        padding-left: 0.5em;
+    }
+
+    .informaltable table,
+    .table table
+    {
+        width: 92%;
+        margin-left: 4%;
+        margin-right: 4%;
+    }
+
+    div.informaltable table,
+    div.table table
+    {
+        padding: 4px;
+    }
+
+    /* Table Cells */
+    div.informaltable table tr td,
+    div.table table tr td
+    {
+        padding: 0.5em;
+        text-align: left;
+        font-size: 9pt;
+    }
+
+    div.informaltable table tr th,
+    div.table table tr th
+    {
+        padding: 0.5em 0.5em 0.5em 0.5em;
+        border: 1pt solid white;
+        font-size: 80%;
+    }
+
+    table.simplelist
+    {
+        width: auto !important;
+        margin: 0em !important;
+        padding: 0em !important;
+        border: none !important;
+    }
+    table.simplelist td
+    {
+        margin: 0em !important;
+        padding: 0em !important;
+        text-align: left !important;
+        font-size: 9pt !important;
+        border: none !important;
+    }
+
+/*=============================================================================
+    Blurbs
+=============================================================================*/
+
+    div.note,
+    div.tip,
+    div.important,
+    div.caution,
+    div.warning,
+    p.blurb
+    {
+        font-size: 9pt; /* A little bit smaller than the main text */
+        line-height: 1.2;
+        display: block;
+        margin: 1pc 4% 0pc 4%;
+        padding: 0.5pc 0.5pc 0.5pc 0.5pc;
+    }
+
+    p.blurb img
+    {
+        padding: 1pt;
+    }
+
+/*=============================================================================
+    Variable Lists
+=============================================================================*/
+
+    div.variablelist
+    {
+        margin: 1em 0;
+    }
+
+    /* Make the terms in definition lists bold */
+    div.variablelist dl dt,
+    span.term
+    {
+        font-weight: bold;
+        font-size: 10pt;
+    }
+
+    div.variablelist table tbody tr td
+    {
+        text-align: left;
+        vertical-align: top;
+        padding: 0em 2em 0em 0em;
+        font-size: 10pt;
+        margin: 0em 0em 0.5em 0em;
+        line-height: 1;
+    }
+
+    div.variablelist dl dt
+    {
+        margin-bottom: 0.2em;
+    }
+
+    div.variablelist dl dd
+    {
+        margin: 0em 0em 0.5em 2em;
+        font-size: 10pt;
+    }
+
+    div.variablelist table tbody tr td p,
+    div.variablelist dl dd p
+    {
+        margin: 0em 0em 0.5em 0em;
+        line-height: 1;
+    }
+
+/*=============================================================================
+    Misc
+=============================================================================*/
+
+    /* Title of books and articles in bibliographies */
+    span.title
+    {
+        font-style: italic;
+    }
+
+    span.underline
+    {
+        text-decoration: underline;
+    }
+
+    span.strikethrough
+    {
+        text-decoration: line-through;
+    }
+
+    /* Copyright, Legal Notice */
+    div div.legalnotice p
+    {
+        text-align: left
+    }
+
+/*=============================================================================
+    Colors
+=============================================================================*/
+
+    @media screen
+    {
+        body {
+            background-color: #FFFFFF;
+            color: #000000;
+        }
+        
+    /* Links */
+        a
+        {
+            color: #005a9c;
+        }
+
+        a:visited
+        {
+            color: #9c5a9c;
+        }
+
+        h1 a, h2 a, h3 a, h4 a, h5 a, h6 a,
+        h1 a:hover, h2 a:hover, h3 a:hover, h4 a:hover, h5 a:hover, h6 a:hover,
+        h1 a:visited, h2 a:visited, h3 a:visited, h4 a:visited, h5 a:visited, h6 a:visited
+        {
+            text-decoration: none; /* no underline */
+            color: #000000;
+        }
+
+    /* Syntax Highlighting */
+        .keyword        { color: #0000AA; }
+        .identifier     { color: #000000; }
+        .special        { color: #707070; }
+        .preprocessor   { color: #402080; }
+        .char           { color: teal; }
+        .comment        { color: #800000; }
+        .string         { color: teal; }
+        .number         { color: teal; }
+        .white_bkd      { background-color: #FFFFFF; }
+        .dk_grey_bkd    { background-color: #999999; }
+
+    /* Copyright, Legal Notice */
+        .copyright
+        {
+            color: #666666;
+            font-size: small;
+        }
+
+        div div.legalnotice p
+        {
+            color: #666666;
+        }
+
+    /* Program listing */
+        pre.synopsis
+        {
+            border: 1px solid #DCDCDC;
+        }
+
+        .programlisting,
+        .screen
+        {
+            border: 1px solid #DCDCDC;
+        }
+
+        td .programlisting,
+        td .screen
+        {
+            border: 0px solid #DCDCDC;
+        }
+
+    /* Blurbs */
+        div.note,
+        div.tip,
+        div.important,
+        div.caution,
+        div.warning,
+        p.blurb
+        {
+            border: 1px solid #DCDCDC;
+        }
+
+    /* Table of contents */
+        .toc
+        {
+            border: 1px solid #DCDCDC;
+        }
+
+    /* Tables */
+        div.informaltable table tr td,
+        div.table table tr td
+        {
+            border: 1px solid #DCDCDC;
+        }
+
+        div.informaltable table tr th,
+        div.table table tr th
+        {
+            background-color: #F0F0F0;
+            border: 1px solid #DCDCDC;
+        }
+
+        .copyright-footer
+        {
+            color: #8F8F8F;
+        }
+
+    /* Misc */
+        span.highlight
+        {
+            color: #00A000;
+        }
+    }
+
+    @media print
+    {
+    /* Links */
+        a
+        {
+            color: black;
+        }
+
+        a:visited
+        {
+            color: black;
+        }
+
+        .spirit-nav
+        {
+            display: none;
+        }
+
+    /* Program listing */
+        pre.synopsis
+        {
+            border: 1px solid gray;
+        }
+
+        .programlisting,
+        .screen
+        {
+            border: 1px solid gray;
+        }
+
+        td .programlisting,
+        td .screen
+        {
+            border: 0px solid #DCDCDC;
+        }
+
+    /* Table of contents */
+        .toc
+        {
+            border: 1px solid gray;
+        }
+
+        .informaltable table,
+        .table table
+        {
+            border: 1px solid gray;
+            border-collapse: collapse;
+        }
+
+    /* Tables */
+        div.informaltable table tr td,
+        div.table table tr td
+        {
+            border: 1px solid gray;
+        }
+
+        div.informaltable table tr th,
+        div.table table tr th
+        {
+            border: 1px solid gray;
+        }
+
+        table.simplelist tr td
+        {
+            border: none !important;
+        }
+
+    /* Misc */
+        span.highlight
+        {
+            font-weight: bold;
+        }
+    }
+
+/*=============================================================================
+    Images
+=============================================================================*/
+
+    span.inlinemediaobject img
+    {
+        vertical-align: middle;
+    }
+
+/*==============================================================================
+    Super and Subscript: style so that line spacing isn't effected, see
+    http://www.adobe.com/cfusion/communityengine/index.cfm?event=showdetails&productId=1&postId=5341
+==============================================================================*/
+
+sup,
+sub {
+	height: 0;
+	line-height: 1;
+	vertical-align: baseline;
+	_vertical-align: bottom;
+	position: relative;
+	
+}
+
+sup {
+	bottom: 1ex;
+}
+
+sub {
+	top: .5ex;
+}
+
diff -urN boost/libs/task/doc/html/boost_task/appendices.html boost-altered/libs/task/doc/html/boost_task/appendices.html
--- boost/libs/task/doc/html/boost_task/appendices.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/appendices.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,138 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Appendices</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="reference.html" title="Reference">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="reference.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a>
+</div>
+<div class="section" title="Appendices">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.appendices"></a><a class="link" href="appendices.html" title="Appendices">Appendices</a>
+</h2></div></div></div>
+<div class="toc"><dl>
+<dt><span class="section"><a href="appendices.html#boost_task.appendices.todo"> Appendix A: Future development</a></span></dt>
+<dt><span class="section"><a href="appendices.html#boost_task.appendices.acknowledgements"> Appendix B:
+      Acknowledgments</a></span></dt>
+</dl></div>
+<div class="section" title="Appendix A: Future development">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.appendices.todo"></a><a class="link" href="appendices.html#boost_task.appendices.todo" title="Appendix A: Future development"> Appendix A: Future development</a>
+</h3></div></div></div>
+<a name="boost_task.appendices.todo.dynamic_thread_pool"></a><h5>
+<a name="id687757"></a>
+        <a class="link" href="appendices.html#boost_task.appendices.todo.dynamic_thread_pool">Dynamic thread-pool</a>
+      </h5>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
+<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">dynamic_pool</span></code> adds or removes <span class="emphasis"><em>worker-threads</em></span>
+          from the <span class="emphasis"><em>thread-pool</em></span> depending on the work-load (undersubscription/
+          oversubscription).
+        </li></ul></div>
+<a name="boost_task.appendices.todo.communication_and_synchronisation_abstractions"></a><h5>
+<a name="id687821"></a>
+        <a class="link" href="appendices.html#boost_task.appendices.todo.communication_and_synchronisation_abstractions">Communication
+        and synchronisation abstractions</a>
+      </h5>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+<span class="bold"><strong>Event variable</strong></span>: A event variable is a
+          bivalued variable (up/down) on which a task can wait for an event to be
+          set or reset. The calling task will be suspended until the state of the
+          event variable is that required by the caller.
+        </li>
+<li class="listitem">
+<span class="bold"><strong>Buffer</strong></span>: A bounded/unbounded buffer is
+          shared between several tasks. The data must be placed in, and retrieved
+          from, the buffer under mutual exclusion. Condition synchronisation is required
+          because a calling task attempting to place data into the buffer. When the
+          buffer is full, the task must be suspended until there is space int the
+          buffer. Also a retrieving task must be suspended when the buffer is empty.
+          The data, once read, is destroyed.
+        </li>
+<li class="listitem">
+<span class="bold"><strong>Multicast</strong></span>: The data is sent to a specific
+          group of tasks and all tasks in the group should receive the data. Only
+          when all tasks have received one item of data then another item is allowed
+          to be transmitted.
+        </li>
+<li class="listitem">
+<span class="bold"><strong>Rendezvous</strong></span>: A rendezvous uses direct naming
+          and synchronous communication between tasks. One task that executes its
+          command first will be delayed until the other tasks is ready to rendezvous.
+        </li>
+<li class="listitem">
+<span class="bold"><strong>Protected resource</strong></span>: A protected resource
+          is a passive entity that controls access to the internal states (to the
+          controled real resources).
+        </li>
+<li class="listitem">
+<span class="bold"><strong>Task groups</strong></span>: A task group defines a graph
+          of interdependent tasks that can mostly be run in parallel. The tasks in
+          the group have dependencies or communicate with each other.
+        </li>
+</ul></div>
+<a name="boost_task.appendices.todo.interdepended_task"></a><h5>
+<a name="id687912"></a>
+        <a class="link" href="appendices.html#boost_task.appendices.todo.interdepended_task">Interdepended
+        task</a>
+      </h5>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
+          With special support of concurrence and synchronisation abstractions interdepended
+          tasks work in <span class="emphasis"><em>thread-pools</em></span> without deadlocking the
+          pool.
+        </li></ul></div>
+<a name="boost_task.appendices.todo.optimizations"></a><h5>
+<a name="id687943"></a>
+        <a class="link" href="appendices.html#boost_task.appendices.todo.optimizations">Optimizations</a>
+      </h5>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+          two-lock-queue as global queue in <span class="emphasis"><em>thread-pool</em></span>
+</li>
+<li class="listitem">
+          maybe lock-free-queue as global queue too (how to provide the scheduling
+          policies fifo, priority, smart?)
+        </li>
+</ul></div>
+</div>
+<div class="section" title="Appendix B: Acknowledgments">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.appendices.acknowledgements"></a><a class="link" href="appendices.html#boost_task.appendices.acknowledgements" title="Appendix B: Acknowledgments"> Appendix B:
+      Acknowledgments</a>
+</h3></div></div></div>
+<p>
+        I'd like to thank Vicente J. Botet Escriba for his comments and contributions
+        (this_task::reschedule_until, this_task::delay, this_task::yield) as well
+        Anthony Williams and Braddock Gaskill for their future libraries.
+      </p>
+</div>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="reference.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/as_sub_task.html boost-altered/libs/task/doc/html/boost_task/as_sub_task.html
--- boost/libs/task/doc/html/boost_task/as_sub_task.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/as_sub_task.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,64 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Execute as sub-task</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="pool.html" title="Thread-pool">
+<link rel="next" href="utilities.html" title="Utilities">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="pool.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="utilities.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Execute as sub-task">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.as_sub_task"></a><a class="link" href="as_sub_task.html" title="Execute as sub-task"> Execute as sub-task</a>
+</h2></div></div></div>
+<p>
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">as_sub_task</span></code>
+      is a convenient way to execute a <span class="emphasis"><em>sub-task</em></span>. If the parent
+      task is executed inside a <span class="emphasis"><em>thread-pool</em></span> the <span class="emphasis"><em>sub-task</em></span>
+      is put into the local-queue of the <span class="emphasis"><em>worker-thread</em></span> in the
+      other case the <span class="emphasis"><em>sub-task</em></span> will be executed in a new thread.
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">as_sub_task</span></code>
+      is used as default <span class="emphasis"><em>execution-policy</em></span> for <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code>,
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">fibonacci</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+
+<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">as_sub_task</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+</pre>
+<p>
+    </p>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="pool.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="utilities.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/async.html boost-altered/libs/task/doc/html/boost_task/async.html
--- boost/libs/task/doc/html/boost_task/async.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/async.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,91 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Asynchronous execution</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="handle.html" title="Handle">
+<link rel="next" href="own_thread.html" title="Execute in own thread">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="handle.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="own_thread.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Asynchronous execution">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.async"></a><a class="link" href="async.html" title="Asynchronous execution"> Asynchronous execution</a>
+</h2></div></div></div>
+<p>
+      Function <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code> applies the moved <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> to the <span class="emphasis"><em>execution-policy</em></span>
+      which executes the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+      (for this purpose <span class="emphasis"><em>execution-policy</em></span> is required to provide
+      <code class="computeroutput"><span class="identifier">handle</span><span class="special">&lt;</span>
+      <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="keyword">operator</span><span class="special">()(</span>
+      <span class="identifier">task</span><span class="special">&lt;</span>
+      <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">)</span></code>). <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code> accepts
+      two arguments - the first is an <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> object and the second an <span class="emphasis"><em>execution-policy</em></span>.
+      For the second argument <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">as_sub_task</span></code> is used per default. The function
+      returns a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code>
+      which controls the submitted <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>.
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">fibonacci</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// task computing fibonacci(10)
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">fibonacci</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+
+	<span class="comment">// move the task to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			 <span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// access the result
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="handle.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="own_thread.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/handle.html boost-altered/libs/task/doc/html/boost_task/handle.html
--- boost/libs/task/doc/html/boost_task/handle.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/handle.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,325 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Handle</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="task.html" title="Task">
+<link rel="next" href="async.html" title="Asynchronous execution">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="task.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="async.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Handle">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.handle"></a><a class="link" href="handle.html" title="Handle"> Handle</a>
+</h2></div></div></div>
+<p>
+      The <span class="emphasis"><em>asynchronous-completion-token</em></span> dispatches tasks in
+      response to the completion of asynchronous operations. <span class="emphasis"><em>asynchronous-completion-token</em></span>
+      uniquely identifies the task and state necessary to process the result of the
+      operation
+      <sup>[<a name="id646812" href="#ftn.id646812" class="footnote">3</a>]</sup>
+      .
+    </p>
+<p>
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code>
+      represents an <span class="emphasis"><em>asynchronous-completion-token</em></span>. It will be
+      returned by <a class="link" href="async.html" title="Asynchronous execution"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code></a>
+      and is associated with the submitted <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>.
+    </p>
+<a name="boost_task.handle.asynchronous_completion_token_interface"></a><h4>
+<a name="id646919"></a>
+      <a class="link" href="handle.html#boost_task.handle.asynchronous_completion_token_interface">Asynchronous
+      completion token interface</a>
+    </h4>
+<p>
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code>
+      implements an interface in order to check the state of computation and to transfer
+      the result.
+    </p>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">is_ready</span><span class="special">()</span></code>:
+        test if result is set
+      </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">has_value</span><span class="special">()</span></code>:
+        test if value-result is set
+      </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">has_exception</span><span class="special">()</span></code>:
+        test if exception-result is set
+      </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>:
+        return value-result or throw the exception-result
+      </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>:
+        wait until result is set
+      </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code>:
+        wait until result is set or time-duration has elapsed
+      </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code>:
+        wait until result ist set or time-point has elapsed
+      </li>
+</ul></div>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">fibonacci</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// create task
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">fibonacci</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+
+	<span class="comment">// move task ownership to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"is ready == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+
+	<span class="comment">// wait for task completion
+</span>	<span class="identifier">h</span><span class="special">.</span><span class="identifier">wait</span><span class="special">();</span>
+
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"has value == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"has exception == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+
+	<span class="comment">// return result
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<a name="boost_task.handle.task_interruption"></a><h4>
+<a name="id647994"></a>
+      <a class="link" href="handle.html#boost_task.handle.task_interruption">Task interruption</a>
+    </h4>
+<p>
+      Each invokation of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code> returns an <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code> which allows to control the associated
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+      (passed to <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code>). This includes the ability to interrupt
+      an <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+      if it is cooperative. Cooperative means that the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> contains <span class="emphasis"><em>interruption-points</em></span>
+      or checks for interruption requests
+      <sup>[<a name="id648167" href="#ftn.id648167" class="footnote">4</a>]</sup>
+      .
+    </p>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code>:
+        interrupt <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> and return immediately
+      </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">interrupt_and_wait</span><span class="special">()</span></code>:
+        interrupt and wait until <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+        was removed from <span class="emphasis"><em>worker-thread</em></span>
+</li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">interrupt_and_wait_for</span><span class="special">()</span></code>:
+        interrupt and wait until <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+        was removed from <span class="emphasis"><em>worker-thread</em></span> or time duration has
+        elapsed
+      </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">interrupt_and_wait_until</span><span class="special">()</span></code>: interrupt and wait until <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> was removed from <span class="emphasis"><em>worker-thread</em></span>
+        or time point has reached
+      </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">interruption_requested</span><span class="special">()</span></code>:
+        return bool if interruption was requested
+      </li>
+</ul></div>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">cooperative</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">interruption_point</span><span class="special">();</span> <span class="comment">// interruption point
+</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">interruption_requested</span><span class="special">()</span> <span class="special">)</span>	<span class="comment">// check if interruption was requested
+</span>			<span class="keyword">return</span><span class="special">;</span>
+
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">interruption_point</span><span class="special">();</span>  <span class="comment">// interruption point
+</span>
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// task, to be executed asynchronously
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">cooperative</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+
+	<span class="comment">// move task to async. executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// interrupt task and wait until task is removed by worker-thread
+</span>	<span class="identifier">h</span><span class="special">.</span><span class="identifier">interrupt_and_wait</span><span class="special">();</span>
+
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"is ready == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"has value == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"has exception == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+
+	<span class="comment">// access result
+</span>	<span class="comment">// throws boost::task::task_interrupted
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<div class="note" title="Note"><table border="0" summary="Note">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
+<th align="left">Note</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+        If the task is still pending (not executed yet) when an interruption is requested
+        - the task is not removed from the queue, it is marked to be interrupted
+        instead.
+      </p></td></tr>
+</table></div>
+<a name="boost_task.handle.waiting_for_handles"></a><h4>
+<a name="id649489"></a>
+      <a class="link" href="handle.html#boost_task.handle.waiting_for_handles">Waiting for handles</a>
+    </h4>
+<p>
+      <span class="bold"><strong>Boost.Task</strong></span> provides function <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">waitfor_all</span><span class="special">()</span></code> waits for all handles passed to this function
+      to become ready
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span> <span class="identifier">handles</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">results</span><span class="special">;</span>
+	<span class="identifier">results</span><span class="special">.</span><span class="identifier">reserve</span><span class="special">(</span> <span class="number">10</span><span class="special">);</span>
+
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">10</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">fibonacci</span><span class="special">,</span> <span class="identifier">i</span><span class="special">);</span>
+
+		<span class="identifier">results</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+				<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">)</span> <span class="special">);</span>
+	<span class="special">}</span>
+
+	<span class="comment">// wait until all tasks are ready
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">results</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">results</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">);</span>
+
+	<span class="keyword">int</span> <span class="identifier">k</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">e</span><span class="special">(</span> <span class="identifier">results</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span>
+		<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">i</span><span class="special">(</span> <span class="identifier">results</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">);</span>
+		<span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">e</span><span class="special">;</span>
+		<span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+		<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci("</span> <span class="special">&lt;&lt;</span> <span class="identifier">k</span><span class="special">++</span> <span class="special">&lt;&lt;</span> <span class="string">") == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<p>
+      and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">waitfor_any</span><span class="special">()</span></code> which returns if at least one of the passed
+      handles becomes ready.
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span> <span class="identifier">cooperative</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span> <span class="identifier">cooperative</span><span class="special">,</span> <span class="number">7</span><span class="special">);</span>
+	 <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t3</span><span class="special">(</span> <span class="identifier">cooperative</span><span class="special">,</span> <span class="number">5</span><span class="special">);</span>
+
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h1</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">)</span> <span class="special">)</span> <span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h2</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">)</span> <span class="special">)</span> <span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h3</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t3</span><span class="special">)</span> <span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// wait for any task becomes ready
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">waitfor_any</span><span class="special">(</span> <span class="identifier">h1</span><span class="special">,</span> <span class="identifier">h2</span><span class="special">,</span> <span class="identifier">h3</span><span class="special">);</span>
+
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">()</span> <span class="special">)</span>
+		<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">()</span> <span class="special">)</span>
+		<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(7) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">h3</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">()</span> <span class="special">)</span>
+		<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(5) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h3</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<div class="footnotes">
+<br><hr width="100" align="left">
+<div class="footnote"><p><sup>[<a name="ftn.id646812" href="#id646812" class="para">3</a>] </sup>
+          see <a href="http://www.cs.wustl.edu/~schmidt/PDF/ACT.pdf" target="_top">'Asynchronous
+          Completion Token'</a>, Douglas Schmidt
+        </p></div>
+<div class="footnote"><p><sup>[<a name="ftn.id648167" href="#id648167" class="para">4</a>] </sup>
+          see <a href="http://www.ddj.com/architect/207100682" target="_top">'Interrupt Politely'</a>,
+          Herb Sutter
+        </p></div>
+</div>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="task.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="async.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/meta_functions.html boost-altered/libs/task/doc/html/boost_task/meta_functions.html
--- boost/libs/task/doc/html/boost_task/meta_functions.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/meta_functions.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,69 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Meta functions</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="utilities.html" title="Utilities">
+<link rel="next" href="reference.html" title="Reference">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="utilities.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Meta functions">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.meta_functions"></a><a class="link" href="meta_functions.html" title="Meta functions"> Meta functions</a>
+</h2></div></div></div>
+<p>
+      If the <span class="emphasis"><em>thread-pool</em></span> supports attributes (like priorities)
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">has_attribute</span></code>
+      evaluates to <code class="computeroutput"><span class="keyword">true</span></code> at compile-time
+      (derived from boost::mpl::bool_). The type of the attribute is determined by
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">attribute_type</span></code>.
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="comment">// thread-pool with priority scheduling
+</span><span class="comment">// type of priority is int
+</span><span class="identifier">typdef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">priority</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span>
+	<span class="special">&gt;</span>
+<span class="special">&gt;</span> <span class="identifier">pool_type</span><span class="special">;</span>
+
+<span class="comment">// test if thread-pool supports priorities at compile time
+</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">has_attribute</span><span class="special">&lt;</span> <span class="identifier">pool_type</span> <span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+
+<span class="comment">// access the type used for priority
+</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="keyword">typeid</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">attribute_type</span><span class="special">&lt;</span> <span class="identifier">pool_type</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">).</span><span class="identifier">name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+</pre>
+<p>
+    </p>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="utilities.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="reference.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/motivation.html boost-altered/libs/task/doc/html/boost_task/motivation.html
--- boost/libs/task/doc/html/boost_task/motivation.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/motivation.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,264 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Motivation</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="next" href="task.html" title="Task">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="../index.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="task.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Motivation">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.motivation"></a><a class="link" href="motivation.html" title="Motivation"> Motivation</a>
+</h2></div></div></div>
+<p>
+      To speed-up computer-bound work and/or increase the computation-throughput
+      is a common motivation for parallelizing a program. Especially for interactive
+      applications that have to process user input while performing some background
+      tasks responsivness is very important. Parallelizing a program requires partitioning
+      the program into smaller chunks that can run in parallel. The code can scale
+      as the hardware gets better without changing the code.
+    </p>
+<p>
+      The evolution from one-core to many-core architectures and the usage of threads
+      (of course processes fit too) support this paradigm.
+    </p>
+<div class="note" title="Note"><table border="0" summary="Note">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
+<th align="left">Note</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+        <span class="quote">&#8220;<span class="quote">You can have multithreading on a single core machine, but you can
+        only have parallelism on a multi core machine ... .</span>&#8221;</span> -- Daniel Moth
+        <sup>[<a name="id640350" href="#ftn.id640350" class="footnote">1</a>]</sup>
+      </p></td></tr>
+</table></div>
+<p>
+      <span class="bold"><strong>Boost.Task</strong></span> provides a framework to utilize
+      the available hardware and provide a way for efficient asynchronous processing
+      of time consuming operations. The framework provides some <span class="emphasis"><em>execution-policies</em></span>,
+      like <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span></code>,
+      in order to execute the task asynchronously in another execution context (<span class="bold"><strong>Boost.Task</strong></span> uses preemptible threads for this purpose).
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">print</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">)</span>
+<span class="special">{</span> <span class="identifier">printf</span><span class="special">(</span><span class="string">"%s\n"</span><span class="special">,</span> <span class="identifier">msg</span><span class="special">.</span><span class="identifier">c_str</span><span class="special">()</span> <span class="special">);</span> <span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// task, to be executed asynchronously
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">print</span><span class="special">,</span> <span class="string">"Hello World!"</span><span class="special">);</span>
+
+	<span class="comment">// execute task in newly-created thread
+</span>	<span class="comment">// move task ownership to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<p>
+      In order to manage the task <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code> returns
+      a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code>
+      (associated with the submitted task). It functions as a <span class="emphasis"><em>asynchronous-completion-token</em></span>
+      - that means it transfers the result of the execution back to the caller thread.
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">echo</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">)</span>
+<span class="special">{</span> <span class="keyword">return</span> <span class="identifier">msg</span><span class="special">;</span> <span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// task returning the submitted string
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">echo</span><span class="special">,</span> <span class="string">"Hello World!"</span><span class="special">);</span>
+
+	<span class="comment">// execute task in newly-created thread
+</span>	<span class="comment">// move task ownership to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// wait until task has finished and return the result
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<p>
+      The task can also be interrupted via <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code> if it is a so-called <a class="link" href="task.html" title="Task"><span class="emphasis"><em>cooperative
+      task</em></span></a>.
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">long_running</span><span class="special">(</span>  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span>
+<span class="special">{</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">sleep</span><span class="special">(</span> <span class="identifier">rel_time</span><span class="special">);</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// create a long runing task
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">long_running</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">millisec</span><span class="special">(</span> <span class="number">500</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// execute task in newly-created thread
+</span>	<span class="comment">// move task ownership to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// requests interruption of task
+</span>	<span class="comment">// returns immediately
+</span>	<span class="identifier">h</span><span class="special">.</span><span class="identifier">interrupt</span><span class="special">();</span>
+
+	<span class="comment">// access the result
+</span>	<span class="comment">// task_interrupted exeception will be thrown
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>		
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<p>
+      Beside <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span></code>
+      (which creates a new task for each submitted task - the thread will be joined
+      by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code>)
+      <span class="bold"><strong>Boost.Task</strong></span> provides <a class="link" href="pool.html" title="Thread-pool"><span class="emphasis"><em>thread-pools</em></span></a>
+      to prevent the overhead of thread creation and destruction of threads for each
+      task (<span class="emphasis"><em>thread-pools</em></span> can be customized).
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span><span class="special">(</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="number">2</span><span class="special">)</span> <span class="keyword">return</span> <span class="identifier">n</span><span class="special">;</span>
+	<span class="keyword">else</span> <span class="keyword">return</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="identifier">n</span> <span class="special">-</span> <span class="number">1</span><span class="special">)</span> <span class="special">+</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="identifier">n</span> <span class="special">-</span> <span class="number">2</span><span class="special">);</span>
+<span class="special">}</span>
+
+<span class="keyword">long</span> <span class="identifier">parallel_fib</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">,</span> <span class="keyword">long</span> <span class="identifier">cutof</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="identifier">cutof</span><span class="special">)</span> <span class="keyword">return</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="identifier">n</span><span class="special">);</span>
+	<span class="keyword">else</span>
+	<span class="special">{</span>
+		<span class="comment">// create a sub-task calculating fibonacci(n-1)
+</span>		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span>
+			<span class="identifier">parallel_fib</span><span class="special">,</span>
+			<span class="identifier">n</span> <span class="special">-</span> <span class="number">1</span><span class="special">,</span>
+			<span class="identifier">cutof</span><span class="special">);</span>
+		<span class="comment">// create a sub-task calculating fibonacci(n-2)
+</span>		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span>
+			<span class="identifier">parallel_fib</span><span class="special">,</span>
+			<span class="identifier">n</span> <span class="special">-</span> <span class="number">2</span><span class="special">,</span>
+			<span class="identifier">cutof</span><span class="special">);</span>
+
+		<span class="comment">// fork two sub-tasks
+</span>		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h1</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+				<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">),</span>
+				<span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">get_pool</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h2</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+				<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">),</span>
+				<span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">get_pool</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+
+		<span class="comment">// join the results of both sub-tasks
+</span>		<span class="keyword">return</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
+	<span class="special">}</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// create a thread-pool with five worker-threads
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">fifo</span>
+		<span class="special">&gt;</span>
+	<span class="special">&gt;</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">5</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// create task computing fibonacci-number for 10
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span>
+		<span class="identifier">parallel_fib</span><span class="special">,</span>
+		<span class="number">10</span><span class="special">,</span>
+		<span class="number">5</span><span class="special">);</span>
+
+	<span class="comment">// execute task in a thread-pool
+</span>	<span class="comment">// move task ownership to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// access the result
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<p>
+      With function <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">runs_in_pool</span><span class="special">()</span></code>
+      a task can detect if it is executed inside a <span class="emphasis"><em>thread-pool</em></span>.
+      <span class="emphasis"><em>sub-tasks</em></span> arecreated by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">as_sub_task</span></code>. Where the <span class="emphasis"><em>sub-task</em></span>
+      is executed by a new thread if the parent task is not executed inside a <span class="emphasis"><em>thread-pool</em></span>.
+      In the other case the <span class="emphasis"><em>sub-task</em></span> is put into the local
+      <span class="emphasis"><em>worker-queue</em></span> which enables <a class="link" href="pool.html#boost_task.pool.work_stealing" title="Work-Stealing"><span class="emphasis"><em>work-stealing</em></span></a>
+      and <a class="link" href="pool.html#boost_task.pool.forkjoin" title="Fork/Join">inline execution</a> of tasks.
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="comment">// create a long runing task
+</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span>
+	<span class="identifier">parallel_fib</span><span class="special">,</span>
+	<span class="number">10</span><span class="special">,</span>
+	<span class="number">5</span><span class="special">);</span>
+
+<span class="comment">// move task ownership to executor
+</span><span class="comment">// sub-task executed in a new thread or inside the thread-pool
+</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">as_sub_task</span><span class="special">()</span> <span class="special">);</span>
+</pre>
+<p>
+    </p>
+<div class="footnotes">
+<br><hr width="100" align="left">
+<div class="footnote"><p><sup>[<a name="ftn.id640350" href="#id640350" class="para">1</a>] </sup>
+            more to read at Daniel's <a href="http://www.danielmoth.com/Blog/2008/11/threadingconcurrency-vs-parallelism.html" target="_top">blog</a>
+          </p></div>
+</div>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="../index.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="task.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/new_thread.html boost-altered/libs/task/doc/html/boost_task/new_thread.html
--- boost/libs/task/doc/html/boost_task/new_thread.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/new_thread.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,115 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Execute in new thread</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="own_thread.html" title="Execute in own thread">
+<link rel="next" href="pool.html" title="Thread-pool">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="own_thread.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="pool.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Execute in new thread">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.new_thread"></a><a class="link" href="new_thread.html" title="Execute in new thread"> Execute in new thread</a>
+</h2></div></div></div>
+<p>
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span></code>
+      creates a new <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code> and executes the task in this thread
+      (asynchronous). The created thread gets joined by handle (so <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html" target="_top">N2802</a>
+      should be addressed). The returned <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code> joins the thread in its destructor
+      (if the last reference gets out of scope) .
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">fibonacci</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">fibonacci</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<div class="caution" title="Caution"><table border="0" summary="Caution">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="../../../doc/html/images/caution.png"></td>
+<th align="left">Caution</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+        Always store the returned <span class="emphasis"><em>asynchronous-completion-token</em></span>
+        in a variable because <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code>
+        joins the thread in its destructor (if the last reference gets out of scope).
+      </p></td></tr>
+</table></div>
+<p>
+      In the example below both <code class="computeroutput"><span class="identifier">a_function</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">another_function</span><span class="special">()</span></code> are executed synchron because the returned
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code>
+      is not stored in a variable. Thatswhy the <span class="emphasis"><em>worker-thread</em></span>
+      is joined after return from <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code>!
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span> <span class="identifier">a_function</span><span class="special">);</span>
+<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span> <span class="identifier">another_function</span><span class="special">);</span>
+
+<span class="comment">// handles are not retrieved
+</span><span class="comment">// both task executed in sequence
+</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">),</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">),</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+</pre>
+<p>
+    </p>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="own_thread.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="pool.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/own_thread.html boost-altered/libs/task/doc/html/boost_task/own_thread.html
--- boost/libs/task/doc/html/boost_task/own_thread.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/own_thread.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,80 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Execute in own thread</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="async.html" title="Asynchronous execution">
+<link rel="next" href="new_thread.html" title="Execute in new thread">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="async.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="new_thread.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Execute in own thread">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.own_thread"></a><a class="link" href="own_thread.html" title="Execute in own thread"> Execute in own thread</a>
+</h2></div></div></div>
+<p>
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">own_thread</span></code>
+      executes the task in the current thread (synchronous execution - concerns of
+      <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html" target="_top">N2802</a>
+      do not aply).
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">fibonacci</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">fibonacci</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">own_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="async.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="new_thread.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/pool.html boost-altered/libs/task/doc/html/boost_task/pool.html
--- boost/libs/task/doc/html/boost_task/pool.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/pool.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,707 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Thread-pool</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="new_thread.html" title="Execute in new thread">
+<link rel="next" href="as_sub_task.html" title="Execute as sub-task">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="new_thread.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="as_sub_task.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Thread-pool">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.pool"></a><a class="link" href="pool.html" title="Thread-pool"> Thread-pool</a>
+</h2></div></div></div>
+<div class="toc"><dl>
+<dt><span class="section"><a href="pool.html#boost_task.pool.static_pool"> Static thread-pool</a></span></dt>
+<dt><span class="section"><a href="pool.html#boost_task.pool.channel"> Channel</a></span></dt>
+<dt><span class="section"><a href="pool.html#boost_task.pool.scheduling"> Scheduling</a></span></dt>
+<dt><span class="section"><a href="pool.html#boost_task.pool.pool_shutdown"> Pool shutdown</a></span></dt>
+<dt><span class="section"><a href="pool.html#boost_task.pool.processor_binding"> Processor binding</a></span></dt>
+<dt><span class="section"><a href="pool.html#boost_task.pool.work_stealing"> Work-Stealing</a></span></dt>
+<dt><span class="section"><a href="pool.html#boost_task.pool.forkjoin"> Fork/Join</a></span></dt>
+</dl></div>
+<p>
+      Instead of creating a new thread and quickly throwing it away after the task
+      is done, the overhead related to thread creation and destruction can be avoided
+      by running the <span class="emphasis"><em>work-items</em></span> on a <span class="emphasis"><em>thread-pool</em></span>
+      (reusing an existing <span class="emphasis"><em>worker-thread</em></span> instead).
+    </p>
+<p>
+      A <span class="emphasis"><em>thread-pool</em></span> maintains a queue (or queues) of <span class="emphasis"><em>work-items</em></span>
+      to be done, and a pool of <span class="emphasis"><em>worker-threads</em></span> which execute
+      <span class="emphasis"><em>work-items</em></span> from the queue(s).
+    </p>
+<p>
+      <span class="bold"><strong>Boost.Task</strong></span> provides <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code> with
+      support of executing an <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> in <span class="emphasis"><em>thread-pool</em></span>:
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">echo</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">)</span>
+<span class="special">{</span> <span class="keyword">return</span> <span class="identifier">msg</span><span class="special">;</span> <span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// create a thread-pool with
+</span>	<span class="comment">// five worker-threads
+</span>	<span class="comment">// FIFO schduling of queued tasks
+</span>	<span class="comment">// and unlimited size of internal queue
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">fifo</span>
+		<span class="special">&gt;</span>
+	<span class="special">&gt;</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">5</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// create task
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">echo</span><span class="special">,</span> <span class="string">"Hello World!"</span><span class="special">);</span>
+
+	<span class="comment">// move task to executor
+</span>	<span class="comment">// let the task be executed by the thread-pool
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// access the result
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<div class="important" title="Important"><table border="0" summary="Important">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../../doc/html/images/important.png"></td>
+<th align="left">Important</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+        Tasks should not be too small (performance overhead dominates) and avoid
+        blocking tasks
+        <sup>[<a name="id655144" href="#ftn.id655144" class="footnote">5</a>]</sup>
+        .
+      </p></td></tr>
+</table></div>
+<div class="section" title="Static thread-pool">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.pool.static_pool"></a><a class="link" href="pool.html#boost_task.pool.static_pool" title="Static thread-pool"> Static thread-pool</a>
+</h3></div></div></div>
+<p>
+        <span class="bold"><strong>Boost.Task</strong></span> provides <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span></code>
+        - which contains an fixed set of pre-forked <span class="emphasis"><em>worker-threads</em></span>
+        (the size of the pool doesn't change during its lifetime). <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span></code> supports move semantics.
+      </p>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">_static_pool</span><span class="special">&lt;</span>               <span class="comment">// pool type
+</span>        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>  <span class="comment">// queuing policy (unbounded_channel, bounded_channel)
+</span>               <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">fifo</span>        <span class="comment">// scheduling policy (fifo, priority, smart)
+</span>        <span class="special">&gt;</span>
+<span class="special">&gt;</span> <span class="identifier">pool</span><span class="special">(</span>
+        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">6</span><span class="special">),</span>                         <span class="comment">// pool with 6 pre-forked worker-threads
+</span>        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">milliseconds</span><span class="special">(</span> <span class="number">50</span><span class="special">),</span>  <span class="comment">// time to sleep if no work-item available
+</span>        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">scanns</span><span class="special">(</span> <span class="number">10</span><span class="special">)</span> <span class="special">);</span>                        <span class="comment">// iterations over local-queues before sleep
+</span></pre>
+<p>
+      </p>
+<p>
+        The first argument of the constructor specifies how many <span class="emphasis"><em>worker-threads</em></span>
+        the pool will contain. The second and third argument are used by the <a class="link" href="pool.html#boost_task.pool.work_stealing" title="Work-Stealing"><span class="emphasis"><em>work-stealing</em></span></a>
+        algorithm.
+      </p>
+<div class="note" title="Note"><table border="0" summary="Note">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
+<th align="left">Note</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+          If <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">bounded_channel</span></code> is used as queuing policy
+          the constructor has two additional arguments .
+        </p></td></tr>
+</table></div>
+<p>
+        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span></code> provides functionality to check
+        the status of the pool - <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code> returns true when the pool was shutdown
+        and <code class="computeroutput"><span class="identifier">active</span><span class="special">()</span></code>
+        as well as <code class="computeroutput"><span class="identifier">idle</span><span class="special">()</span></code>
+        returning how many <span class="emphasis"><em>worker-threads</em></span> are active (executing
+        a task) or idle. The size of the pool can be accessed over <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>.
+      </p>
+<p>
+        For informational pruposes <code class="computeroutput"><span class="identifier">empty</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">pending</span><span class="special">()</span></code> can be used in order to know if the global
+        task-queue is empty or how many tasks are waiting for execution. With <code class="computeroutput"><span class="identifier">clear</span><span class="special">()</span></code>
+        all tasks are removed from the global-queue.
+      </p>
+<div class="note" title="Note"><table border="0" summary="Note">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
+<th align="left">Note</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+          <code class="computeroutput"><span class="identifier">pending</span><span class="special">()</span></code>
+          does not count tasks in the local-queues of the <span class="emphasis"><em>worker-threads</em></span>.
+        </p></td></tr>
+</table></div>
+</div>
+<div class="section" title="Channel">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.pool.channel"></a><a class="link" href="pool.html#boost_task.pool.channel" title="Channel"> Channel</a>
+</h3></div></div></div>
+<p>
+        The channel synchronizes the access between non-pool threads (application
+        threads) and <span class="emphasis"><em>worker-threads</em></span> and implements a queuing
+        policy (limitation of queued tasks).
+      </p>
+<a name="boost_task.pool.channel._code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__task__phrase__phrase_role__special______phrase__phrase_role__identifier__bounded_channel__phrase___code_"></a><h5>
+<a name="id655776"></a>
+        <a class="link" href="pool.html#boost_task.pool.channel._code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__task__phrase__phrase_role__special______phrase__phrase_role__identifier__bounded_channel__phrase___code_"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">bounded_channel</span></code></a>
+      </h5>
+<p>
+        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">bounded_channel</span></code> contains a single lock
+        in order to synchronize access to the queue. The number of pending tasks
+        is limited in order to prevent resource exhaustion. For this purpose a high-
+        and low-watermark has to be passed at construction. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">high_watermark</span></code>
+        sets the maximum of pending tasks. If this limited is reached all threads
+        which submit a task will be set to sleep (blocked). If it is equal to <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">low_watermark</span></code> everytime a sleeping producer
+        thread will be woken up and puts its task if one worker thread has taken
+        a task from the channel. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">low_watermark</span></code>
+        sets the threshold when blocked threads get woken up. If it is less than
+        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">high_watermark</span></code> all sleeping producer threads
+        will be woken up if the amount of pending tasks reaches <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">low_watermark</span></code>.
+      </p>
+<a name="boost_task.pool.channel._code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__task__phrase__phrase_role__special______phrase__phrase_role__identifier__unbounded_channel__phrase___code_"></a><h5>
+<a name="id656008"></a>
+        <a class="link" href="pool.html#boost_task.pool.channel._code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__task__phrase__phrase_role__special______phrase__phrase_role__identifier__unbounded_channel__phrase___code_"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span></code></a>
+      </h5>
+<p>
+        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span></code> contains a single lock
+        in order to synchronize access to the queue. An unlimited number of tasks
+        can be queued into this channel. The insertion of an <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+        will never block. If the channel becomes empty <span class="emphasis"><em>worker-threads</em></span>
+        will be set to sleep until new tasks are enqueued.
+      </p>
+</div>
+<div class="section" title="Scheduling">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.pool.scheduling"></a><a class="link" href="pool.html#boost_task.pool.scheduling" title="Scheduling"> Scheduling</a>
+</h3></div></div></div>
+<p>
+        The scheduling policy determines how tasks are scheduled inside the <span class="emphasis"><em>channel</em></span>.
+      </p>
+<a name="boost_task.pool.scheduling.fifo"></a><h5>
+<a name="id656149"></a>
+        <a class="link" href="pool.html#boost_task.pool.scheduling.fifo">fifo</a>
+      </h5>
+<p>
+        First inserted pending <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+        gets taken first.
+      </p>
+<a name="boost_task.pool.scheduling.priority"></a><h5>
+<a name="id656201"></a>
+        <a class="link" href="pool.html#boost_task.pool.scheduling.priority">priority</a>
+      </h5>
+<p>
+        Each <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> is submitted to the pool with a priority
+        attribute. The type and ordering of the priority is user-defined.
+      </p>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="comment">// thread-pool with priority scheduling
+</span><span class="comment">// tasks with higher priority are
+</span><span class="comment">// scheduled first
+</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">priority</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
+<span class="special">&gt;</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">5</span><span class="special">)</span> <span class="special">);</span>
+
+<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span> <span class="identifier">some_fn</span><span class="special">);</span>
+<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span> <span class="identifier">another_fn</span><span class="special">);</span>
+
+<span class="comment">// move task t1 with priority 5 to thread-pool
+</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">),</span>
+	<span class="number">5</span><span class="special">,</span>
+	<span class="identifier">pool</span><span class="special">);</span>
+
+<span class="comment">// move task t2 with priority 3 to thread-pool
+</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">),</span>
+	<span class="number">3</span><span class="special">,</span>
+	<span class="identifier">pool</span><span class="special">);</span>
+</pre>
+<p>
+      </p>
+<p>
+        In this example the tasks get scheduled by the assigned integer (third argument
+        of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code>).
+        The <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> with the lowest priority gets scheduled
+        first (taken by a <span class="emphasis"><em>worker-thread</em></span>). The ordering can be
+        changed by the second argument of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">priority</span></code>
+        (the default is <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">greater</span><span class="special">&lt;</span> <span class="identifier">Attr</span> <span class="special">&gt;</span></code>).
+      </p>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="comment">// thread-pool with priority scheduling
+</span><span class="comment">// tasks with lower priority are
+</span><span class="comment">// scheduled first
+</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">priority</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
+	<span class="special">&gt;</span>
+<span class="special">&gt;</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">5</span><span class="special">)</span> <span class="special">);</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.pool.scheduling.smart"></a><h5>
+<a name="id657077"></a>
+        <a class="link" href="pool.html#boost_task.pool.scheduling.smart">smart</a>
+      </h5>
+<p>
+        Each inserted <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> is associated with an attribute. The
+        scheduler gets an put- and take-policy as template arguments. The corresponding
+        policy gets applied for each insertion and removal.
+      </p>
+<p>
+        <span class="bold"><strong>Boost.Task</strong></span> provides <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">replace_oldest</span></code>
+        as put- policy and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">take_oldest</span></code>
+        as take-policy. Both policies allow the replacement of older (pending) tasks
+        in the scheduler by new ones.
+      </p>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">fibonacci_fn</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">smart</span><span class="special">&lt;</span>
+			<span class="keyword">int</span><span class="special">,</span>
+			<span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;,</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">replace_oldest</span><span class="special">,</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">take_oldest</span>
+		<span class="special">&gt;</span>
+	<span class="special">&gt;</span>
+<span class="special">&gt;</span> <span class="identifier">pool_type</span><span class="special">;</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="identifier">pool_type</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="special">...</span>
+
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span> <span class="identifier">fibonacci_fn</span><span class="special">,</span> <span class="number">10</span><span class="special">)</span> <span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span> <span class="identifier">fibonacci_fn</span><span class="special">,</span> <span class="number">5</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// replaced by later task with same attribute == 2
+</span>	<span class="comment">// if still pending in pool
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">),</span>
+		<span class="number">2</span><span class="special">,</span>
+		<span class="identifier">pool</span><span class="special">);</span>
+
+	<span class="comment">// will replace previous pending task with attribute == 2
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">),</span>
+		<span class="number">2</span><span class="special">,</span>
+		<span class="identifier">pool</span><span class="special">);</span>
+<span class="special">}</span>
+</pre>
+<p>
+      </p>
+</div>
+<div class="section" title="Pool shutdown">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.pool.pool_shutdown"></a><a class="link" href="pool.html#boost_task.pool.pool_shutdown" title="Pool shutdown"> Pool shutdown</a>
+</h3></div></div></div>
+<p>
+        <span class="bold"><strong>Boost.Task</strong></span> allows to shutdown a <span class="emphasis"><em>thread-pool</em></span>
+        explicitly via functions <code class="computeroutput"><span class="identifier">shutdown</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">shutdown_now</span><span class="special">()</span></code>. The destructor of the pool calls <code class="computeroutput"><span class="identifier">shutdown</span><span class="special">()</span></code>
+        if not already done so that all <span class="emphasis"><em>worker-threads</em></span> are joined
+        and the topic of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html" target="_top">N2802</a>
+        should be addressed.
+      </p>
+<a name="boost_task.pool.pool_shutdown.shutdown"></a><h5>
+<a name="id658313"></a>
+        <a class="link" href="pool.html#boost_task.pool.pool_shutdown.shutdown">Shutdown</a>
+      </h5>
+<p>
+        If <code class="computeroutput"><span class="identifier">shutdown</span><span class="special">()</span></code>
+        is called - the the pool is set the closed state and all <span class="emphasis"><em>worker-threads</em></span>
+        are joined until all pending tasks are processed. No futher tasks can be
+        submitted.
+      </p>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">fibonacci_fn</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">fifo</span>
+	<span class="special">&gt;</span>
+<span class="special">&gt;</span> <span class="identifier">pool_type</span><span class="special">;</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="identifier">pool_type</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="special">...</span>
+
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span> <span class="identifier">fibonacci_fn</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span> <span class="identifier">fibonacci_fn</span><span class="special">,</span> <span class="number">5</span><span class="special">);</span>
+
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h1</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">)</span> <span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h2</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// waits until all pending tasks are finished
+</span>	<span class="identifier">pool</span><span class="special">.</span><span class="identifier">shutdown</span><span class="special">();</span>
+
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(5) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+      </p>
+<div class="note" title="Note"><table border="0" summary="Note">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
+<th align="left">Note</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+          The deconstructor calls <code class="computeroutput"><span class="identifier">shutdown</span><span class="special">()</span></code> if the pool was not shutdown yet.
+        </p></td></tr>
+</table></div>
+<a name="boost_task.pool.pool_shutdown.shutdown_immediatly"></a><h5>
+<a name="id659496"></a>
+        <a class="link" href="pool.html#boost_task.pool.pool_shutdown.shutdown_immediatly">Shutdown
+        immediatly</a>
+      </h5>
+<p>
+        The function <code class="computeroutput"><span class="identifier">shutdown_now</span><span class="special">()</span></code> closes the pool, interrupts and then joins
+        all <span class="emphasis"><em>worker-threads</em></span>. Pending tasks are unprocessed.
+      </p>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">fibonacci_fn</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">fifo</span>
+	<span class="special">&gt;</span>
+<span class="special">&gt;</span> <span class="identifier">pool_type</span><span class="special">;</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="identifier">pool_type</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="special">...</span>
+
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span> <span class="identifier">fibonacci_fn</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span> <span class="identifier">fibonacci_fn</span><span class="special">,</span> <span class="number">5</span><span class="special">);</span>
+
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h1</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">)</span> <span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h2</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// requests task interruption and
+</span>	<span class="comment">// joins all worker-threads
+</span>	<span class="identifier">pool</span><span class="special">.</span><span class="identifier">shutdown_now</span><span class="special">();</span>
+
+	<span class="comment">// accessing the result may throw task_interrupted
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(5) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+      </p>
+</div>
+<div class="section" title="Processor binding">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.pool.processor_binding"></a><a class="link" href="pool.html#boost_task.pool.processor_binding" title="Processor binding"> Processor binding</a>
+</h3></div></div></div>
+<p>
+        For some applications it is convenient to bind the <span class="emphasis"><em>worker-threads</em></span>
+        to processors/cores of the system. For this purpose <code class="computeroutput"><span class="identifier">bind_to_processors</span><span class="special">()</span></code> must be given to constructor instead <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span></code> so that a <span class="emphasis"><em>worker-thread</em></span>
+        is created an bound the the core.
+      </p>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tp</span><span class="special">::</span><span class="identifier">fifo</span> <span class="special">&gt;</span>
+<span class="special">&gt;</span> <span class="identifier">pool_type</span><span class="special">;</span>
+
+<span class="comment">// constructs thread-pool with worker-threads as
+</span><span class="comment">// CPUs/Cores are available on the system
+</span><span class="identifier">pool_type</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">pool_type</span><span class="special">::</span><span class="identifier">bind_to_processors</span><span class="special">()</span> <span class="special">);</span>
+</pre>
+<p>
+      </p>
+<p>
+        The constructor takes additional arguments for the <a class="link" href="pool.html#boost_task.pool.work_stealing" title="Work-Stealing">work-stealing
+        algorithm</a> and <a class="link" href="pool.html#boost_task.pool.channel" title="Channel">high-</a>
+        and <a class="link" href="pool.html#boost_task.pool.channel" title="Channel">low-watermark</a> too.
+      </p>
+<div class="note" title="Note"><table border="0" summary="Note">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
+<th align="left">Note</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+          <span class="bold"><strong>Boost.Task</strong></span> does provide this feature only
+          for Windows, Linux, AIX, HP-UX, Solaris and FreeBSD.
+        </p></td></tr>
+</table></div>
+</div>
+<div class="section" title="Work-Stealing">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.pool.work_stealing"></a><a class="link" href="pool.html#boost_task.pool.work_stealing" title="Work-Stealing"> Work-Stealing</a>
+</h3></div></div></div>
+<p>
+        Traditional <span class="emphasis"><em>thread-pools</em></span> do not scale because they use
+        a single global-queue protected by a global-lock. The frequency at which
+        <span class="emphasis"><em>worker-threads</em></span> aquire the global-lock becomes a limiting
+        factor for the throughput if:
+      </p>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+          the tasks become smaller
+        </li>
+<li class="listitem">
+          more processors are added
+        </li>
+</ul></div>
+<p>
+        A <span class="emphasis"><em>work-stealing</em></span> algorithm can be used to solve this
+        problem. It uses a special kind of queue which has two ends, and allows lock-free
+        pushes and pops from the <span class="emphasis"><em>private end</em></span> (accessed by the
+        <span class="emphasis"><em>worker-thread</em></span> owning the queue), but requires synchronization
+        from the <span class="emphasis"><em>public end</em></span> (accessed by the other <span class="emphasis"><em>worker-threads</em></span>).
+        Synchronization is necessary when the queue is sufficiently small that private
+        and public operations could conflict.
+      </p>
+<p>
+        The pool contains one global-queue (<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">bounded_channel</span></code>
+        or <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span></code>) protected by a global-lock
+        and each <span class="emphasis"><em>worker-thread</em></span> has its own private local worker-queue.
+        If work is enqueued by a <span class="emphasis"><em>worker-thread</em></span> the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> is stored in the worker queue. If
+        the work is enqueued by a application thread it goes into the global queue.
+        When <span class="emphasis"><em>worker-threads</em></span> are looking for work, they have
+        following search order:
+      </p>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+          look into the private worker-queue - tasks can be dequeued without locks
+        </li>
+<li class="listitem">
+          look in the global-queue - locks are used for synchronization
+        </li>
+<li class="listitem">
+          check other worker-queues ('stealing' tasks from private worker queues
+          of other <span class="emphasis"><em>worker-threads</em></span>) - requires locks
+        </li>
+</ul></div>
+<p>
+        For a lot of recursively queued tasks (so called <span class="emphasis"><em>sub-tasks</em></span>),
+        the use of a worker-queue per thread substantially reduces the synchronization
+        necessary to complete the work. There are also fewer cache effects due to
+        sharing of the global-queue information.
+      </p>
+<p>
+        Operations on the private worker queue are executed in LIFO order and operations
+        on worker queues of other <span class="emphasis"><em>worker-threads</em></span> in FIFO order
+        (steals).
+      </p>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+          There are chances that memory is still hot in the cache, if the tasks are
+          pushed in LIFO order into the private worker queue.
+        </li>
+<li class="listitem">
+          If a <span class="emphasis"><em>worker-thread</em></span> steals work in FIFO order, increases
+          the chances that a larger 'chunk' of work will be stolen (the need for
+          other steals will be possibly reduced). Because the <span class="emphasis"><em>sub-tasks</em></span>
+          are stored in LIFO order, the oldest items are closer to the <span class="emphasis"><em>public
+          end</em></span> of the queue (forming a tree). Stealing such an older <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> also steals a (probably) larger
+          subtree of tasks unfolded if the stolen work item get executed. Since a
+          <span class="emphasis"><em>sub-task</em></span> is just part of a larger <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>,
+          we don&#8217;t need to worry about execution order.
+        </li>
+</ul></div>
+</div>
+<p>
+      / Copyright Oliver Kowalke 2009. Distributed under the Boost Software License,
+      Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt
+      ]
+    </p>
+<div class="section" title="Fork/Join">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.pool.forkjoin"></a><a class="link" href="pool.html#boost_task.pool.forkjoin" title="Fork/Join"> Fork/Join</a>
+</h3></div></div></div>
+<p>
+        Fork/Join algorithms are recursive divide-and-conquer algorithms which repeatedly
+        splitt into sub-tasks until they become small enough to solve using simple,
+        short sequential methods, so that they run in parallel on multiple cores.
+      </p>
+<p>
+        The fork operation creates new <span class="emphasis"><em>sub-tasks</em></span> which can run
+        in parallel. The current <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+        is not proceeded in the join operation until the forked <span class="emphasis"><em>sub-tasks</em></span>
+        have completed. In the meantime the <span class="emphasis"><em>worker-thread</em></span> executes
+        other tasks from its local <span class="emphasis"><em>worker-queue</em></span>.
+      </p>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span><span class="special">(</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="number">2</span><span class="special">)</span> <span class="keyword">return</span> <span class="identifier">n</span><span class="special">;</span>
+	<span class="keyword">else</span> <span class="keyword">return</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="identifier">n</span> <span class="special">-</span> <span class="number">1</span><span class="special">)</span> <span class="special">+</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="identifier">n</span> <span class="special">-</span> <span class="number">2</span><span class="special">);</span>
+<span class="special">}</span>
+
+<span class="keyword">long</span> <span class="identifier">parallel_fib</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">,</span> <span class="keyword">long</span> <span class="identifier">cutof</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="identifier">cutof</span><span class="special">)</span> <span class="keyword">return</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="identifier">n</span><span class="special">);</span>
+	<span class="keyword">else</span>
+	<span class="special">{</span>
+		<span class="comment">// create a sub-task calculating fibonacci(n-1)
+</span>		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span>
+			<span class="identifier">parallel_fib</span><span class="special">,</span>
+			<span class="identifier">n</span> <span class="special">-</span> <span class="number">1</span><span class="special">,</span>
+			<span class="identifier">cutof</span><span class="special">);</span>
+		<span class="comment">// create a sub-task calculating fibonacci(n-2)
+</span>		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span>
+			<span class="identifier">parallel_fib</span><span class="special">,</span>
+			<span class="identifier">n</span> <span class="special">-</span> <span class="number">2</span><span class="special">,</span>
+			<span class="identifier">cutof</span><span class="special">);</span>
+
+		<span class="comment">// fork both sub-tasks by moving the task
+</span>		<span class="comment">// ownership to the thread-pool
+</span>		<span class="identifier">h1</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">)</span> <span class="special">);</span>
+		<span class="identifier">h2</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">)</span> <span class="special">);</span>
+
+		<span class="comment">// join the results of both sub-tasks
+</span>		<span class="comment">// if one of the both sub-tasks is not ready
+</span>		<span class="comment">// the worker-thread does not block, it executes other
+</span>		<span class="comment">// task from its local-queue
+</span>		<span class="keyword">return</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
+	<span class="special">}</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">fifo</span>
+		<span class="special">&gt;</span>
+	<span class="special">&gt;</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">5</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// compute fibonacci-number 10
+</span>	<span class="comment">// for numbers &lt; 5 do inline calculation
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span>
+		<span class="identifier">parallel_fib</span><span class="special">,</span>
+		<span class="number">10</span><span class="special">,</span>
+		<span class="number">5</span><span class="special">);</span>
+
+	<span class="comment">// move task ownership to thread-pool
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// access result
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+      </p>
+</div>
+<div class="footnotes">
+<br><hr width="100" align="left">
+<div class="footnote"><p><sup>[<a name="ftn.id655144" href="#id655144" class="para">5</a>] </sup>
+            see <a href="http://www.ddj.com/go-parallel/article/showArticle.jhtml?articleID=216500409" target="_top">'Use
+            Thread Pools Correctly'</a>, Herb Sutter
+          </p></div>
+</div>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="new_thread.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="as_sub_task.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/reference.html boost-altered/libs/task/doc/html/boost_task/reference.html
--- boost/libs/task/doc/html/boost_task/reference.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/reference.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,2752 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Reference</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="meta_functions.html" title="Meta functions">
+<link rel="next" href="appendices.html" title="Appendices">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="meta_functions.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="appendices.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Reference">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.reference"></a><a class="link" href="reference.html" title="Reference"> Reference</a>
+</h2></div></div></div>
+<div class="toc"><dl>
+<dt><span class="section"><a href="reference.html#boost_task.reference.task"> Class template <code class="computeroutput"><span class="identifier">task</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.handle"> Class template <code class="computeroutput"><span class="identifier">handle</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.async"> Non-member function <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;,</span> <span class="identifier">EP</span><span class="special">)</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.async1"> Non-member function <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;,</span> <span class="identifier">pool</span><span class="special">&lt;</span> <span class="identifier">Channel</span> <span class="special">&gt;</span> <span class="special">&amp;)</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.async2"> Non-member function <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;,</span> <span class="identifier">Attr</span><span class="special">,</span> <span class="identifier">pool</span><span class="special">&lt;</span>
+      <span class="identifier">Channel</span> <span class="special">&gt;</span>
+      <span class="special">&amp;)</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.own_thread"> Class <code class="computeroutput"><span class="identifier">own_thread</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.new_thread"> Class <code class="computeroutput"><span class="identifier">new_thread</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.static_pool"> Class template <code class="computeroutput"><span class="identifier">static_pool</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.reschedule_until"> Non-member function
+      <code class="computeroutput"><span class="identifier">reschedule_until</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.get_pool"> Non-member function
+      <code class="computeroutput"><span class="identifier">get_pool</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.runs_in_pool"> Non-member function
+      <code class="computeroutput"><span class="identifier">runs_in_pool</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.worker_id"> Non-member function
+      <code class="computeroutput"><span class="identifier">worker_id</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.delay"> Non-member function <code class="computeroutput"><span class="identifier">delay</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.yield"> Non-member function <code class="computeroutput"><span class="identifier">yield</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.interrupt"> Non-member function
+      <code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.has_attribute"> Meta function <code class="computeroutput"><span class="identifier">has_attribute</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.attribute_type"> Meta function
+      <code class="computeroutput"><span class="identifier">attribute_type</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.poolsize"> Class <code class="computeroutput"><span class="identifier">poolsize</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.high_watermark"> Class <code class="computeroutput"><span class="identifier">high_watermark</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.low_watermark"> Class <code class="computeroutput"><span class="identifier">low_watermark</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.scanns"> Class <code class="computeroutput"><span class="identifier">scanns</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.invalid_poolsize"> Class <code class="computeroutput"><span class="identifier">invalid_poolsize</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.invalid_scanns"> Class <code class="computeroutput"><span class="identifier">invalid_scanns</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.invalid_timeduration"> Class <code class="computeroutput"><span class="identifier">invalid_timeduration</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.invalid_watermark"> Class <code class="computeroutput"><span class="identifier">invalid_watermark</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.task_rejected"> Class <code class="computeroutput"><span class="identifier">task_rejected</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.task_unitialized"> Class <code class="computeroutput"><span class="identifier">task_unitialized</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.task_already_executed"> Class <code class="computeroutput"><span class="identifier">task_already_executed</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.task_moved"> Class <code class="computeroutput"><span class="identifier">task_moved</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.broken_task"> Class <code class="computeroutput"><span class="identifier">broken_task</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.task_interrupted"> Class <code class="computeroutput"><span class="identifier">task_interrupted</span></code></a></span></dt>
+<dt><span class="section"><a href="reference.html#boost_task.reference.pool_moved"> Class <code class="computeroutput"><span class="identifier">pool_moved</span></code></a></span></dt>
+</dl></div>
+<div class="section" title="Class template task">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.task"></a><a class="link" href="reference.html#boost_task.reference.task" title="Class template task"> Class template <code class="computeroutput"><span class="identifier">task</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">task</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+<span class="keyword">class</span> <span class="identifier">task</span> <span class="special">:</span> <span class="keyword">private</span> <span class="identifier">noncopyable</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">task</span><span class="special">();</span>
+
+	<span class="identifier">task</span><span class="special">(</span> <span class="identifier">R</span><span class="special">(</span> <span class="special">*</span> <span class="identifier">fn</span><span class="special">)());</span>
+
+	<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span> <span class="special">&gt;</span>
+	<span class="identifier">task</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="identifier">fn</span><span class="special">);</span>
+
+	<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A0</span> <span class="special">&gt;</span>
+	<span class="identifier">task</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="identifier">fn</span><span class="special">,</span> <span class="identifier">A0</span> <span class="identifier">a0</span><span class="special">);</span>
+	<span class="special">...</span>
+	<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A0</span><span class="special">,</span> <span class="special">...,</span> <span class="keyword">typename</span> <span class="identifier">A9</span> <span class="special">&gt;</span>
+	<span class="identifier">task</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="identifier">fn</span><span class="special">,</span> <span class="identifier">A0</span> <span class="identifier">a0</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">A9</span> <span class="identifier">a9</span><span class="special">);</span>
+
+	<span class="identifier">task</span><span class="special">(</span> <span class="identifier">task</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">);</span>
+	<span class="identifier">task</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">task</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">);</span>
+	<span class="identifier">task</span> <span class="special">&amp;&amp;</span> <span class="identifier">move</span><span class="special">();</span>
+
+	<span class="identifier">shared_future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">get_future</span><span class="special">();</span>
+
+	<span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()();</span>
+
+	<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Cb</span> <span class="special">&gt;</span>
+	<span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span> <span class="identifier">Cb</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">cb</span><span class="special">);</span>
+
+	<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
+
+	<span class="keyword">operator</span> <span class="identifier">unspecified_bool_type</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+	<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span><span class="special">;</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.task.default_constructor"></a><h5>
+<a name="id664852"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.default_constructor">Default constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs an unitialized <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span></code>
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.constructor__function_pointer_"></a><h5>
+<a name="id664962"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.constructor__function_pointer_">Constructor
+        (function pointer)</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task</span><span class="special">(</span> <span class="identifier">R</span><span class="special">(</span> <span class="special">*</span> <span class="identifier">fn</span><span class="special">)());</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span>
+            <span class="identifier">R</span> <span class="special">&gt;</span></code>
+            from a function pointer
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.constructor__functor_"></a><h5>
+<a name="id665099"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.constructor__functor_">Constructor
+        (functor)</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span> <span class="special">&gt;</span>
+<span class="identifier">task</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">fn</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span>
+            <span class="identifier">R</span> <span class="special">&gt;</span></code>
+            from a function object
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.constructor__functor_with_arguments_"></a><h5>
+<a name="id665262"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.constructor__functor_with_arguments_">Constructor
+        (functor with arguments)</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A0</span> <span class="special">&gt;</span>
+<span class="identifier">task</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="identifier">fn</span><span class="special">,</span> <span class="identifier">A0</span> <span class="identifier">a0</span><span class="special">);</span>
+<span class="special">...</span>
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">A0</span><span class="special">,</span> <span class="special">...,</span> <span class="keyword">typename</span> <span class="identifier">A9</span> <span class="special">&gt;</span>
+<span class="identifier">task</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="identifier">fn</span><span class="special">,</span> <span class="identifier">A0</span> <span class="identifier">a0</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">A9</span> <span class="identifier">a9</span><span class="special">);</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span>
+            <span class="identifier">R</span> <span class="special">&gt;</span></code>
+            from a function object and its arguments
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.move_copy_constructor"></a><h5>
+<a name="id665578"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.move_copy_constructor">Move-copy
+        constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task</span><span class="special">(</span> <span class="identifier">task</span> <span class="special">&amp;&amp;)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span>
+            <span class="identifier">R</span> <span class="special">&gt;</span></code>
+            from another task taking over the ownership
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.move_assignment_operator"></a><h5>
+<a name="id665699"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.move_assignment_operator">Move-assignment
+        operator</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">task</span> <span class="special">&amp;&amp;)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span>
+            <span class="identifier">R</span> <span class="special">&gt;</span></code>
+            from another task taking over the ownership
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.member_function__code__phrase_role__identifier__move__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id665833"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.member_function__code__phrase_role__identifier__move__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">move</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task</span> <span class="special">&amp;&amp;</span> <span class="identifier">move</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            moves task releasing the ownership
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.member_function__code__phrase_role__identifier__get_future__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id665927"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.member_function__code__phrase_role__identifier__get_future__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">get_future</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">shared_future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">get_future</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns a future assiciated with the task
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special________phrase___code_"></a><h5>
+<a name="id666036"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special________phrase___code_">Member
+        function <code class="computeroutput"><span class="keyword">operator</span><span class="special">()()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            executes task's internal function object
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.member_template_function__code__phrase_role__identifier__set_wait_callback__phrase__phrase_role__special_____phrase___phrase_role__identifier__cb__phrase___phrase_role__identifier__cons__phrase__phrase_role__special___amp____phrase___code_"></a><h5>
+<a name="id666123"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.member_template_function__code__phrase_role__identifier__set_wait_callback__phrase__phrase_role__special_____phrase___phrase_role__identifier__cb__phrase___phrase_role__identifier__cons__phrase__phrase_role__special___amp____phrase___code_">Member
+        template-function <code class="computeroutput"><span class="identifier">set_wait_callback</span><span class="special">(</span> <span class="identifier">Cb</span> <span class="identifier">cons</span><span class="special">&amp;)</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Cb</span> <span class="special">&gt;</span>
+<span class="keyword">void</span> <span class="identifier">set_wait_callback</span><span class="special">(</span> <span class="identifier">Cb</span> <span class="keyword">const</span> <span class="identifier">cb</span><span class="special">&amp;);</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            stores callback function object which will be called if task would block
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.member_function__code__phrase_role__identifier__swap__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp____phrase___code_"></a><h5>
+<a name="id666281"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.member_function__code__phrase_role__identifier__swap__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp____phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">swap</span><span class="special">(</span>
+        <span class="identifier">task</span><span class="special">&lt;</span>
+        <span class="identifier">R</span> <span class="special">&gt;</span>
+        <span class="special">&amp;)</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            swaps the task
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.operator__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__unspecified_bool_type__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id666441"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.operator__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__unspecified_bool_type__phrase__phrase_role__special______phrase___code_">operator
+        <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">unspecified_bool_type</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">unspecified_bool_type</span><span class="special">()</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            is task valid == does task own ownership
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.task.operator__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___code_"></a><h5>
+<a name="id666540"></a>
+        <a class="link" href="reference.html#boost_task.reference.task.operator__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___code_">operator
+        <code class="computeroutput"><span class="keyword">operator</span><span class="special">!()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            is task invalid == task does not have ownership
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class template handle">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.handle"></a><a class="link" href="reference.html#boost_task.reference.handle" title="Class template handle"> Class template <code class="computeroutput"><span class="identifier">handle</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">handle</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+<span class="keyword">class</span> <span class="identifier">handle</span>
+<span class="special">{</span>
+	<span class="identifier">handle</span><span class="special">();</span>
+
+	<span class="keyword">void</span> <span class="identifier">interrupt</span><span class="special">();</span>
+	<span class="keyword">void</span> <span class="identifier">interrupt_and_wait</span><span class="special">();</span>
+	<span class="keyword">void</span> <span class="identifier">interrupt_and_wait_until</span><span class="special">(</span> <span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
+	<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
+	<span class="keyword">void</span> <span class="identifier">interrupt_and_wait_for</span><span class="special">(</span> <span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>
+	<span class="keyword">bool</span> <span class="identifier">interruption_requested</span><span class="special">();</span>
+
+	<span class="identifier">R</span> <span class="identifier">get</span><span class="special">();</span>
+	<span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+	<span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+	<span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+	<span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+
+	<span class="identifier">shared_future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">get_future</span><span class="special">();</span>
+
+	<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
+<span class="special">};</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Iterator</span> <span class="special">&gt;</span>
+<span class="keyword">friend</span> <span class="keyword">void</span> <span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span> <span class="special">&gt;</span>
+<span class="keyword">friend</span> <span class="keyword">void</span> <span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">T1</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">);</span>
+<span class="special">...</span>
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T3</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T4</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T5</span> <span class="special">&gt;</span>
+<span class="keyword">friend</span> <span class="keyword">void</span> <span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T3</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t3</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T4</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t4</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T5</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t5</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Iterator</span> <span class="special">&gt;</span>
+<span class="keyword">friend</span> <span class="identifier">Iterator</span> <span class="identifier">waitfor_any</span><span class="special">(</span> <span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span> <span class="special">&gt;</span>
+<span class="keyword">friend</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">waitfor_any</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">);</span>
+<span class="special">...</span>
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T3</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T4</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T5</span> <span class="special">&gt;</span>
+<span class="keyword">friend</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">waitfor_any</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T3</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t3</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T4</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t4</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T5</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t5</span><span class="special">);</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.handle.constructor"></a><h5>
+<a name="id668168"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">handle</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs an empty (invalid) handle
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__interruption_requested__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id668235"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__interruption_requested__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">interruption_requested</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">interruption_requested</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            checks if interruption is already requested
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id668323"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">interrupt</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            requests task interruption; doesn not block (immediatly returns)
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id668412"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">interrupt_and_wait</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">interrupt_and_wait</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            requests task interruption and blocks until worker-thread stops task
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait_until__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id668520"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait_until__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">interrupt_and_wait_until</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">interrupt_and_wait_until</span><span class="special">(</span> <span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            requests task interruption and blocks until worker-thread stops task
+            or time-point elapsed
+          </p></dd>
+<dt><span class="term">Returns:</span></dt>
+<dd><p>
+            false if the the time specified by abs_time was reached, true otherwise
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait_for__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id668667"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__interrupt_and_wait_for__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">interrupt_and_wait_for</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
+<span class="keyword">bool</span> <span class="identifier">interrupt_and_wait_for</span><span class="special">(</span> <span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            requests task interruption and blocks until worker-thread stops task
+            or time-duration elapsed
+          </p></dd>
+<dt><span class="term">Returns:</span></dt>
+<dd><p>
+            false if the the time specified by rel_time was reached, true otherwise
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__get__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id668841"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__get__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">R</span> <span class="identifier">get</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            requests the result
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_interrupted</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_uninialized</span></code>,
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">broken_task</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__wait__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id669042"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__wait__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            blocks caller until task is done
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_interrupted</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_uninialized</span></code>,
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">broken_task</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__wait_for__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id669243"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__wait_for__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
+<span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            blocks caller until task is done
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_interrupted</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_uninialized</span></code>,
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">broken_task</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__wait_until__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id669504"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__wait_until__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            blocks caller until task is done
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_interrupted</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_uninialized</span></code>,
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">broken_task</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__is_ready__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id669738"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__is_ready__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">is_ready</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">is_ready</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            checks if task is done
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__has_value__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id669825"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__has_value__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">has_value</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_value</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            checks if task is done and a result value is set
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__has_exception__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id669913"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__has_exception__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">has_exception</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">has_exception</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            checks if task is done and an exception is set
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__get_future__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id670002"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__get_future__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">get_future</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">shared_future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">get_future</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns a reference to the internal shared_future&lt; R &gt;
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.member_function__code__phrase_role__identifier__swap__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id670112"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.member_function__code__phrase_role__identifier__swap__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">swap</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            swapps handle
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.non_member_function__code__phrase_role__identifier__wait_for_all__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id670238"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.non_member_function__code__phrase_role__identifier__wait_for_all__phrase__phrase_role__special______phrase___code_">Non-member
+        function <code class="computeroutput"><span class="identifier">wait_for_all</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Iterator</span> <span class="special">&gt;</span>
+<span class="keyword">void</span> <span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span> <span class="special">&gt;</span>
+<span class="keyword">void</span> <span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">T1</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T3</span> <span class="special">&gt;</span>
+<span class="keyword">void</span> <span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T3</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t3</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T3</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T4</span> <span class="special">&gt;</span>
+<span class="keyword">void</span> <span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T3</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t3</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T4</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t4</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T3</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T4</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T5</span> <span class="special">&gt;</span>
+<span class="keyword">void</span> <span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T3</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t3</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T4</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t4</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T5</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t5</span><span class="special">);</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            waits for all handles to become ready
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_interrupted</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.handle.non_member_function__code__phrase_role__identifier__wait_for_any__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id671259"></a>
+        <a class="link" href="reference.html#boost_task.reference.handle.non_member_function__code__phrase_role__identifier__wait_for_any__phrase__phrase_role__special______phrase___code_">Non-member
+        function <code class="computeroutput"><span class="identifier">wait_for_any</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Iterator</span> <span class="special">&gt;</span>
+<span class="identifier">Iterator</span> <span class="identifier">waitfor_any</span><span class="special">(</span> <span class="identifier">Iterator</span> <span class="identifier">begin</span><span class="special">,</span> <span class="identifier">Iterator</span> <span class="identifier">end</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span> <span class="special">&gt;</span>
+<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">waitfor_any</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T3</span> <span class="special">&gt;</span>
+<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">waitfor_any</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T3</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t3</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T3</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T4</span> <span class="special">&gt;</span>
+<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">waitfor_any</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T3</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t3</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T4</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t4</span><span class="special">);</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T3</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T4</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T5</span> <span class="special">&gt;</span>
+<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">waitfor_any</span><span class="special">(</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t1</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t2</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T3</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t3</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T4</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t4</span><span class="special">,</span> <span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">T5</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">t5</span><span class="special">);</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            waits for any handle to become ready
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_interrupted</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>,
+            <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function async( task&lt; R &gt; &amp;&amp;, EP)">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.async"></a><a class="link" href="reference.html#boost_task.reference.async" title="Non-member function async( task&lt; R &gt; &amp;&amp;, EP)"> Non-member function <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;,</span> <span class="identifier">EP</span><span class="special">)</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">async</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">EP</span> <span class="special">&gt;</span>
+<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">,</span> <span class="identifier">EP</span> <span class="identifier">ep</span><span class="special">);</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            moves task to an asyncrounous executer and returns a handle associated
+            with the task
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function async( task&lt; R &gt; &amp;&amp;, pool&lt; Channel &gt; &amp;)">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.async1"></a><a class="link" href="reference.html#boost_task.reference.async1" title="Non-member function async( task&lt; R &gt; &amp;&amp;, pool&lt; Channel &gt; &amp;)"> Non-member function <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;,</span> <span class="identifier">pool</span><span class="special">&lt;</span> <span class="identifier">Channel</span> <span class="special">&gt;</span> <span class="special">&amp;)</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">async</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Channel</span> <span class="special">&gt;</span>
+<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">,</span> <span class="identifier">pool</span><span class="special">&lt;</span> <span class="identifier">Channel</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">ep</span><span class="special">);</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            moves task into a thread-pool and returns a handle associated with the
+            task
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function async( task&lt; R &gt; &amp;&amp;, Attr, pool&lt; Channel &gt; &amp;)">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.async2"></a><a class="link" href="reference.html#boost_task.reference.async2" title="Non-member function async( task&lt; R &gt; &amp;&amp;, Attr, pool&lt; Channel &gt; &amp;)"> Non-member function <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;,</span> <span class="identifier">Attr</span><span class="special">,</span> <span class="identifier">pool</span><span class="special">&lt;</span>
+      <span class="identifier">Channel</span> <span class="special">&gt;</span>
+      <span class="special">&amp;)</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">async</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Channel</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Attr</span> <span class="special">&gt;</span>
+<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">,</span> <span class="identifier">Attr</span> <span class="identifier">attr</span><span class="special">,</span> <span class="identifier">pool</span><span class="special">&lt;</span> <span class="identifier">Channel</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">ep</span><span class="special">);</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            moves attributed task into a thread-pool and returns a handle associated
+            with the task
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class own_thread">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.own_thread"></a><a class="link" href="reference.html#boost_task.reference.own_thread" title="Class own_thread"> Class <code class="computeroutput"><span class="identifier">own_thread</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">async</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">struct</span> <span class="identifier">own_thread</span>
+<span class="special">{</span>
+	<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+	<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">);</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.own_thread.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_"></a><h5>
+<a name="id673593"></a>
+        <a class="link" href="reference.html#boost_task.reference.own_thread.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_">Member
+        function <code class="computeroutput"><span class="keyword">operator</span><span class="special">()(</span>
+        <span class="identifier">task</span><span class="special">&lt;</span>
+        <span class="identifier">R</span> <span class="special">&gt;</span>
+        <span class="special">&amp;&amp;)</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            moves task in the current thread an returns an handle associated with
+            the task
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class new_thread">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.new_thread"></a><a class="link" href="reference.html#boost_task.reference.new_thread" title="Class new_thread"> Class <code class="computeroutput"><span class="identifier">new_thread</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">async</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">struct</span> <span class="identifier">new_thread</span>
+<span class="special">{</span>
+	<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+	<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;);</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.new_thread.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_"></a><h5>
+<a name="id673985"></a>
+        <a class="link" href="reference.html#boost_task.reference.new_thread.member_function__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_">Member
+        function <code class="computeroutput"><span class="keyword">operator</span><span class="special">()(</span>
+        <span class="identifier">task</span><span class="special">&lt;</span>
+        <span class="identifier">R</span> <span class="special">&gt;</span>
+        <span class="special">&amp;&amp;)</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            moves task in a new thread an returns an handle associated with the task
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class template static_pool">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.static_pool"></a><a class="link" href="reference.html#boost_task.reference.static_pool" title="Class template static_pool"> Class template <code class="computeroutput"><span class="identifier">static_pool</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting">	<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">static_pool</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+	<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Channel</span> <span class="special">&gt;</span>
+	<span class="keyword">class</span> <span class="identifier">static_pool</span> <span class="special">:</span> <span class="keyword">private</span> <span class="identifier">noncopyable</span>
+	<span class="special">{</span>
+	<span class="keyword">public</span><span class="special">:</span>
+		<span class="identifier">static_pool</span><span class="special">();</span>
+
+		<span class="keyword">explicit</span> <span class="identifier">static_pool</span><span class="special">(</span>
+			<span class="identifier">poolsize</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">psize</span><span class="special">,</span>
+			<span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">asleep</span> <span class="special">=</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">microseconds</span><span class="special">(</span> <span class="number">10</span><span class="special">),</span>
+			<span class="identifier">scanns</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">scns</span> <span class="special">=</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="number">20</span><span class="special">)</span> <span class="special">);</span>
+
+		<span class="keyword">explicit</span> <span class="identifier">static_pool</span><span class="special">(</span>
+			<span class="identifier">poolsize</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">psize</span><span class="special">,</span>
+			<span class="identifier">high_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">hwm</span><span class="special">,</span>
+			<span class="identifier">low_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">lwm</span><span class="special">,</span>
+			<span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">asleep</span> <span class="special">=</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">milliseconds</span><span class="special">(</span> <span class="number">100</span><span class="special">),</span>
+			<span class="identifier">scanns</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">scns</span> <span class="special">=</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="number">20</span><span class="special">)</span> <span class="special">);</span>
+
+		<span class="identifier">static_pool</span><span class="special">(</span> <span class="identifier">static_pool</span> <span class="special">&amp;&amp;);</span>
+
+		<span class="identifier">static_pool</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">static_pool</span> <span class="special">&amp;&amp;);</span>
+
+<span class="preprocessor"># if</span> <span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_HAS_PROCESSOR_BINDINGS</span><span class="special">)</span>
+		<span class="keyword">explicit</span> <span class="identifier">static_pool</span><span class="special">(</span>
+			<span class="special">&lt;&lt;</span><span class="identifier">unspec</span><span class="special">-</span><span class="identifier">type</span><span class="special">&gt;&gt;,</span>
+			<span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">asleep</span> <span class="special">=</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">microseconds</span><span class="special">(</span> <span class="number">10</span><span class="special">),</span>
+			<span class="identifier">scanns</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">scns</span> <span class="special">=</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="number">20</span><span class="special">)</span> <span class="special">);</span>
+
+		<span class="keyword">explicit</span> <span class="identifier">static_pool</span><span class="special">(</span>
+			<span class="special">&lt;&lt;</span><span class="identifier">unspec</span><span class="special">-</span><span class="identifier">type</span><span class="special">&gt;&gt;,</span>
+			<span class="identifier">high_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">hwm</span><span class="special">,</span>
+			<span class="identifier">low_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">lwm</span><span class="special">,</span>
+			<span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">asleep</span> <span class="special">=</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">milliseconds</span><span class="special">(</span> <span class="number">100</span><span class="special">),</span>
+			<span class="identifier">scanns</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">scns</span> <span class="special">=</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="number">20</span><span class="special">)</span> <span class="special">);</span>
+			
+		<span class="keyword">static</span> <span class="special">&lt;&lt;</span><span class="identifier">unspec</span><span class="special">-</span><span class="identifier">type</span><span class="special">&gt;&gt;</span> <span class="identifier">bind_to_processors</span><span class="special">();</span>
+<span class="preprocessor"># endif</span>
+
+		<span class="special">~</span><span class="identifier">static_pool</span><span class="special">();</span>
+
+		<span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">();</span>
+		<span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">active</span><span class="special">();</span>
+		<span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">idle</span><span class="special">();</span>
+
+		<span class="keyword">void</span> <span class="identifier">shutdown</span><span class="special">();</span>
+		<span class="keyword">void</span> <span class="identifier">shutdown_now</span><span class="special">();</span>
+
+		<span class="keyword">void</span> <span class="identifier">interrupt_all_worker</span><span class="special">();</span>
+
+		<span class="keyword">bool</span> <span class="identifier">closed</span><span class="special">();</span>
+		<span class="keyword">void</span> <span class="identifier">clear</span><span class="special">();</span>
+		<span class="keyword">bool</span> <span class="identifier">empty</span><span class="special">();</span>
+		<span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">pending</span><span class="special">();</span>
+
+		<span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">upper_bound</span><span class="special">();</span>
+		<span class="keyword">void</span> <span class="identifier">upper_bound</span><span class="special">(</span> <span class="identifier">high_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">hwm</span><span class="special">);</span>
+		<span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">lower_bound</span><span class="special">();</span>
+		<span class="keyword">void</span> <span class="identifier">lower_bound</span><span class="special">(</span> <span class="identifier">low_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">lwm</span><span class="special">);</span>
+
+		<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+		<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">submit</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">);</span>
+
+		<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Attr</span> <span class="special">&gt;</span>
+		<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">submit</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">,</span> <span class="identifier">Attr</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">);</span>
+
+		<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">static_pool</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
+
+		<span class="keyword">operator</span> <span class="identifier">unspecified_bool_type</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+		<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span><span class="special">;</span>
+	<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.static_pool.default_constructor"></a><h5>
+<a name="id675921"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.default_constructor">Default
+        constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">static_pool</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs an unitialized pool
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.constructor__unbounded_channel_"></a><h5>
+<a name="id675988"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.constructor__unbounded_channel_">Constructor
+        (unbounded channel)</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">static_pool</span><span class="special">(</span>
+	<span class="special">&lt;&lt;</span><span class="identifier">unspec</span><span class="special">-</span><span class="identifier">type</span><span class="special">&gt;&gt;,</span>
+	<span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">asleep</span> <span class="special">=</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">microseconds</span><span class="special">(</span> <span class="number">10</span><span class="special">),</span>
+	<span class="identifier">scanns</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">scns</span> <span class="special">=</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="number">20</span><span class="special">)</span> <span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            operating system provides functionality for processor binding
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a pool - for each processor a worker-thread is created and
+            bound to one processor - global-queue can queue an unlimited number of
+            tasks
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_scanns</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_timeduration</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            constructor has to be called if a unbounded-channel is used and <code class="computeroutput"><span class="identifier">bind_to_processors</span><span class="special">()</span></code>
+            must be set as first argument
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.constructor__unbounded_channel_poolsize_"></a><h5>
+<a name="id676321"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.constructor__unbounded_channel_poolsize_">Constructor
+        (unbounded channel/poolsize)</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">static_pool</span><span class="special">(</span>
+	<span class="identifier">poolsize</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">psize</span><span class="special">,</span>
+	<span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">asleep</span> <span class="special">=</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">microseconds</span><span class="special">(</span> <span class="number">10</span><span class="special">),</span>
+	<span class="identifier">scanns</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">scns</span> <span class="special">=</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="number">20</span><span class="special">)</span> <span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a pool containing psize worker-threads - global-queue can
+            queue an unlimited number of tasks
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_scanns</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_timeduration</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            constructor has to be called if a unbounded-channel is used
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.constructor__bounded_channel_"></a><h5>
+<a name="id676627"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.constructor__bounded_channel_">Constructor
+        (bounded channel)</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">static_pool</span><span class="special">(</span>
+	<span class="special">&lt;&lt;</span><span class="identifier">unspec</span><span class="special">-</span><span class="identifier">type</span><span class="special">&gt;&gt;,</span>
+	<span class="identifier">high_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">hwm</span><span class="special">,</span>
+	<span class="identifier">low_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">lwm</span><span class="special">,</span>
+	<span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">asleep</span> <span class="special">=</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">milliseconds</span><span class="special">(</span> <span class="number">100</span><span class="special">),</span>
+	<span class="identifier">scanns</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">scns</span> <span class="special">=</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="number">20</span><span class="special">)</span> <span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            operating system provides functionality for processor binding
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a pool - for each processor a worker-thread is created and
+            bound to one processor - global-queue can only queue a limited number
+            of tasks
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_scanns</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_timeduration</span></code>,
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_watermark</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            constructor has to be called if a bounded-channel is used and <code class="computeroutput"><span class="identifier">bind_to_processors</span><span class="special">()</span></code>
+            must be set as first argument
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.constructor__bounded_channel_poolsize_"></a><h5>
+<a name="id677040"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.constructor__bounded_channel_poolsize_">Constructor
+        (bounded channel/poolsize)</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">static_pool</span><span class="special">(</span>
+	<span class="identifier">poolsize</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">psize</span><span class="special">,</span>
+	<span class="identifier">high_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">hwm</span><span class="special">,</span>
+	<span class="identifier">low_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">lwm</span><span class="special">,</span>
+	<span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">asleep</span> <span class="special">=</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">milliseconds</span><span class="special">(</span> <span class="number">100</span><span class="special">),</span>
+	<span class="identifier">scanns</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">scns</span> <span class="special">=</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="number">20</span><span class="special">)</span> <span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a pool containing psize worker-threads - global-queue can
+            only queue a limited number of tasks
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_scanns</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_timeduration</span></code>,
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_watermark</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            constructor has to be called if a bounded-channel is used
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.move_copy_constructor"></a><h5>
+<a name="id677427"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.move_copy_constructor">Move-copy
+        constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">static_pool</span><span class="special">(</span> <span class="identifier">static_pool</span> <span class="special">&amp;&amp;)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            creates an pool out of another one which gets zeroed out
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.move_assigment_constructor"></a><h5>
+<a name="id677504"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.move_assigment_constructor">Move-assigment
+        constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">static_pool</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">static_pool</span> <span class="special">&amp;&amp;)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            creates an pool out of another one which gets zeroed out
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.destructor"></a><h5>
+<a name="id677594"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.destructor">Destructor</a>
+      </h5>
+<pre class="programlisting"><span class="special">~</span><span class="identifier">static_pool</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            calls <code class="computeroutput"><span class="identifier">shutdown</span><span class="special">()</span></code>
+            if not already called
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.static_member_function__code__phrase_role__identifier__bind_to_processors__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id677681"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.static_member_function__code__phrase_role__identifier__bind_to_processors__phrase__phrase_role__special______phrase___code_">Static
+        member function <code class="computeroutput"><span class="identifier">bind_to_processors</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="special">&lt;&lt;</span><span class="identifier">unspec</span><span class="special">-</span><span class="identifier">type</span><span class="special">&gt;&gt;</span> <span class="identifier">bind_to_processors</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            used in order to let the pool create worker-threads as cores are available
+            and bound the threads to the cores
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__size__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id677789"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__size__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns how many worker-threads are running in the pool
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__active__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id677915"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__active__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">active</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">active</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns how many worker-threads are active (executing an task)
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__idle__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id678039"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__idle__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">idle</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">idle</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns how many worker-threads are idle (not executing an task).
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            the value is the difference of <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">active</span><span class="special">()</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__shutdown__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id678207"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__shutdown__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">shutdown</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">shutdown</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            deactivates the channel and joins all worker-threads - the pool is closed
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">system_error</span></code>,
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            all pending tasks are processed
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__shutdown_now__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id678384"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__shutdown_now__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">shutdown_now</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">shutdown_now</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            deactivates the channel, send interruption request to all worker-threads
+            and joins them - the pool is closed
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">system_error</span></code>,
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            pending tasks are not processed but returned
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__interrupt_all_worker__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id678561"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__interrupt_all_worker__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">interrupt_all_worker</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">interrupt_all_worker</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            interrupts all worker-threads without invalidating the pool
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__closed__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id678650"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__closed__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">closed</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">closed</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            queries if the pool is closed (pool is shutdown)
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__clear__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id678766"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__clear__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">clear</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">clear</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            removes all pending tasks from the channel
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__empty__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id678882"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__empty__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">empty</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">empty</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            queries if the channel is empty
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__pending__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id678998"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__pending__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">pending</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">pending</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            queries how many tasks are pending (still unprocessed) in the global-queue
+            (channel)
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__upper_bound__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id679123"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__upper_bound__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">upper_bound</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">upper_bound</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            channel is of type bounded-channel
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns the upper bound of the bounded-channel
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            can only be used if a bounded-channel is used
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__upper_bound__phrase__phrase_role__special_____phrase___phrase_role__identifier__high_watermark__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__hwm__phrase__phrase_role__special_____phrase___code_"></a><h5>
+<a name="id679272"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__upper_bound__phrase__phrase_role__special_____phrase___phrase_role__identifier__high_watermark__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__hwm__phrase__phrase_role__special_____phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">upper_bound</span><span class="special">(</span>
+        <span class="identifier">high_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">hwm</span><span class="special">)</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">upper_bound</span><span class="special">(</span> <span class="identifier">high_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">hwm</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            channel is of type bounded-channel
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            sets the upper bound of the bounded-channel
+          </p></dd>
+<dt><span class="term">Postconditions:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">upper_bound</span><span class="special">()</span>
+            <span class="special">==</span> <span class="identifier">hwm</span></code>
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_watermark</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            can only be used if a bounded-channel is used
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__lower_bound__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id679549"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__lower_bound__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">lower_bound</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">lower_bound</span><span class="special">();</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            channel is of type bounded-channel
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns the lower bound of the bounded-channel
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            can only be used if a bounded-channel is used
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__lower_bound__phrase__phrase_role__special_____phrase___phrase_role__identifier__low_watermark__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__lwm__phrase__phrase_role__special_____phrase___code_"></a><h5>
+<a name="id679699"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__lower_bound__phrase__phrase_role__special_____phrase___phrase_role__identifier__low_watermark__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__lwm__phrase__phrase_role__special_____phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">lower_bound</span><span class="special">(</span>
+        <span class="identifier">low_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">lwm</span><span class="special">)</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">lower_bound</span><span class="special">(</span> <span class="identifier">low_watermark</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">lwm</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            channel is of type bounded-channel
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            sets the lower bound of the bounded-channel
+          </p></dd>
+<dt><span class="term">Postconditions:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">lower_bound</span><span class="special">()</span>
+            <span class="special">==</span> <span class="identifier">lwm</span></code>
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_watermark</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+<dt><span class="term">Notes:</span></dt>
+<dd><p>
+            can only be used if a bounded-channel is used
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__submit__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_"></a><h5>
+<a name="id679974"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__submit__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">submit</span><span class="special">(</span>
+        <span class="identifier">task</span><span class="special">&lt;</span>
+        <span class="identifier">R</span> <span class="special">&gt;</span>
+        <span class="special">&amp;&amp;)</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">submit</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            has_attribute&lt; pool &gt;::value == false &amp;&amp; ! closed()
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            moves an task to the pool and returns an associated handle
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function__code__phrase_role__identifier__submit__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___phrase_role__identifier__attr__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__attr__phrase__phrase_role__special_____phrase___code_"></a><h5>
+<a name="id680249"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function__code__phrase_role__identifier__submit__phrase__phrase_role__special_____phrase___phrase_role__identifier__task__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__r__phrase___phrase_role__special___gt___phrase___phrase_role__special___amp__amp____phrase___phrase_role__identifier__attr__phrase___phrase_role__keyword__const__phrase__phrase_role__special___amp___phrase___phrase_role__identifier__attr__phrase__phrase_role__special_____phrase___code_">Member
+        function <code class="computeroutput"><span class="identifier">submit</span><span class="special">(</span>
+        <span class="identifier">task</span><span class="special">&lt;</span>
+        <span class="identifier">R</span> <span class="special">&gt;</span>
+        <span class="special">&amp;&amp;,</span> <span class="identifier">Attr</span>
+        <span class="keyword">const</span><span class="special">&amp;</span>
+        <span class="identifier">attr</span><span class="special">)</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Attr</span> <span class="special">&gt;</span>
+<span class="identifier">handle</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">submit</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">t</span><span class="special">,</span> <span class="identifier">Attr</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">attr</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            has_attribute&lt; pool &gt;::value == true &amp;&amp; ! closed()
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            moves an task to the pool and returns an associated handle - task is
+            scheduled by the attribute
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.member_function_swap__static_pool__amp___"></a><h5>
+<a name="id680595"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.member_function_swap__static_pool__amp___">Member
+        function swap( static_pool &amp;)`</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">static_pool</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            swaps pool
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.operator__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__unspecified_bool_type__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id680691"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.operator__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__unspecified_bool_type__phrase__phrase_role__special______phrase___code_">operator
+        <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">unspecified_bool_type</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">unspecified_bool_type</span><span class="special">()</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            is static_pool valid == does static_pool own ownership
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.static_pool.operator__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___code_"></a><h5>
+<a name="id680791"></a>
+        <a class="link" href="reference.html#boost_task.reference.static_pool.operator__code__phrase_role__keyword__operator__phrase__phrase_role__special_______phrase___code_">operator
+        <code class="computeroutput"><span class="keyword">operator</span><span class="special">!()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            is static_pool invalid == static_pool does not have ownership
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function reschedule_until()">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.reschedule_until"></a><a class="link" href="reference.html#boost_task.reference.reschedule_until" title="Non-member function reschedule_until()"> Non-member function
+      <code class="computeroutput"><span class="identifier">reschedule_until</span><span class="special">()</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">utility</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
+<span class="keyword">void</span> <span class="identifier">reschedule_until</span><span class="special">(</span> <span class="identifier">Pred</span> <span class="keyword">const</span><span class="special">&amp;)</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            reschedules current task until passed callable predicate becomes ready
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code>,<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">system_error</span></code>
+          </p></dd>
+<dt><span class="term">Note:</span></dt>
+<dd><p>
+            this function resides in namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function get_pool()">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.get_pool"></a><a class="link" href="reference.html#boost_task.reference.get_pool" title="Non-member function get_pool()"> Non-member function
+      <code class="computeroutput"><span class="identifier">get_pool</span><span class="special">()</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">utility</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Pool</span> <span class="special">&gt;</span>
+<span class="identifier">Pool</span> <span class="special">&amp;</span> <span class="identifier">get_pool</span><span class="special">()</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns reference to the thread-pool where the current worker thread
+            is executed
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+<dt><span class="term">Note:</span></dt>
+<dd><p>
+            this function resides in namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function runs_in_pool()">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.runs_in_pool"></a><a class="link" href="reference.html#boost_task.reference.runs_in_pool" title="Non-member function runs_in_pool()"> Non-member function
+      <code class="computeroutput"><span class="identifier">runs_in_pool</span><span class="special">()</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">utility</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">bool</span> <span class="identifier">runs_in_pool</span><span class="special">()</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns true if the current task is executed in a thread-pool
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+<dt><span class="term">Note:</span></dt>
+<dd><p>
+            this function resides in namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function worker_id()">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.worker_id"></a><a class="link" href="reference.html#boost_task.reference.worker_id" title="Non-member function worker_id()"> Non-member function
+      <code class="computeroutput"><span class="identifier">worker_id</span><span class="special">()</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">utility</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="identifier">id</span> <span class="identifier">worker_id</span><span class="special">()</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns returns the thread-id of the worker-thread
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+<dt><span class="term">Note:</span></dt>
+<dd><p>
+            this function resides in namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function delay()">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.delay"></a><a class="link" href="reference.html#boost_task.reference.delay" title="Non-member function delay()"> Non-member function <code class="computeroutput"><span class="identifier">delay</span><span class="special">()</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">utility</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">void</span> <span class="identifier">delay</span><span class="special">(</span> <span class="identifier">system_time</span> <span class="identifier">abs_time</span><span class="special">)</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
+<span class="keyword">void</span> <span class="identifier">delay</span><span class="special">(</span> <span class="identifier">Duration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            delays the execution of the current task so that the worker-thread can
+            process another task in the meantime
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+<dt><span class="term">Note:</span></dt>
+<dd><p>
+            this function resides in namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function yield()">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.yield"></a><a class="link" href="reference.html#boost_task.reference.yield" title="Non-member function yield()"> Non-member function <code class="computeroutput"><span class="identifier">yield</span><span class="special">()</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">utility</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">void</span> <span class="identifier">yield</span><span class="special">()</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            yields the current task so that the worker-threadcan process another
+            task in the meantime
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+<dt><span class="term">Note:</span></dt>
+<dd><p>
+            this function resides in namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Non-member function interrupt()">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.interrupt"></a><a class="link" href="reference.html#boost_task.reference.interrupt" title="Non-member function interrupt()"> Non-member function
+      <code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">utility</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">void</span> <span class="identifier">interrupt</span><span class="special">()</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            task can request interruption for itself
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+<dt><span class="term">Note:</span></dt>
+<dd><p>
+            this function resides in namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span></code>
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Meta function has_attribute">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.has_attribute"></a><a class="link" href="reference.html#boost_task.reference.has_attribute" title="Meta function has_attribute"> Meta function <code class="computeroutput"><span class="identifier">has_attribute</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">meta</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Pool</span> <span class="special">&gt;</span>
+<span class="keyword">struct</span> <span class="identifier">has_attribute</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">bool_</span><span class="special">&lt;</span>
+	<span class="identifier">is_same</span><span class="special">&lt;</span>
+		<span class="identifier">detail</span><span class="special">::</span><span class="identifier">has_priority</span><span class="special">,</span>
+		<span class="keyword">typename</span> <span class="identifier">Pool</span><span class="special">::</span><span class="identifier">scheduler_type</span><span class="special">::</span><span class="identifier">priority_tag_type</span>
+	<span class="special">&gt;::</span><span class="identifier">value</span>
+<span class="special">&gt;</span>
+<span class="special">{};</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns true if Pool supports attributes (priority-scheduling)
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Meta function attribute_type">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.attribute_type"></a><a class="link" href="reference.html#boost_task.reference.attribute_type" title="Meta function attribute_type"> Meta function
+      <code class="computeroutput"><span class="identifier">attribute_type</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">meta</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Pool</span> <span class="special">&gt;</span>
+<span class="keyword">struct</span> <span class="identifier">attribute_type</span>
+<span class="special">{</span>
+	<span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Pool</span><span class="special">::</span><span class="identifier">scheduler_type</span><span class="special">::</span><span class="identifier">attribute_type</span>   <span class="identifier">type</span><span class="special">;</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns type of attribute
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class poolsize">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.poolsize"></a><a class="link" href="reference.html#boost_task.reference.poolsize" title="Class poolsize"> Class <code class="computeroutput"><span class="identifier">poolsize</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">poolsize</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">poolsize</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="keyword">explicit</span> <span class="identifier">poolsize</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">value</span><span class="special">);</span>
+
+	<span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.poolsize.constructor"></a><h5>
+<a name="id682905"></a>
+        <a class="link" href="reference.html#boost_task.reference.poolsize.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">poolsize</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">value</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            value &gt; 0
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span></code> instance
+          </p></dd>
+<dt><span class="term">Postconditions:</span></dt>
+<dd><p>
+            operator std::size_t () &gt; 0
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_poolsize</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.poolsize.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id596678"></a>
+        <a class="link" href="reference.html#boost_task.reference.poolsize.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="special">()</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns the value
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class high_watermark">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.high_watermark"></a><a class="link" href="reference.html#boost_task.reference.high_watermark" title="Class high_watermark"> Class <code class="computeroutput"><span class="identifier">high_watermark</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">watermark</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">high_watermark</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="keyword">explicit</span> <span class="identifier">high_watermark</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">value</span><span class="special">);</span>
+
+	<span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.high_watermark.constructor"></a><h5>
+<a name="id683462"></a>
+        <a class="link" href="reference.html#boost_task.reference.high_watermark.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">high_watermark</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">value</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tp</span><span class="special">::</span><span class="identifier">high_watermark</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_watermark</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.high_watermark.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id683614"></a>
+        <a class="link" href="reference.html#boost_task.reference.high_watermark.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="special">()</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns high watermark
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class low_watermark">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.low_watermark"></a><a class="link" href="reference.html#boost_task.reference.low_watermark" title="Class low_watermark"> Class <code class="computeroutput"><span class="identifier">low_watermark</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">watermark</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">low_watermark</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="keyword">explicit</span> <span class="identifier">low_watermark</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">value</span><span class="special">);</span>
+
+	<span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.low_watermark.constructor"></a><h5>
+<a name="id683927"></a>
+        <a class="link" href="reference.html#boost_task.reference.low_watermark.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">low_watermark</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">value</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">low_watermark</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_watermark</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.low_watermark.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id684080"></a>
+        <a class="link" href="reference.html#boost_task.reference.low_watermark.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="special">()</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns low watermark
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class scanns">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.scanns"></a><a class="link" href="reference.html#boost_task.reference.scanns" title="Class scanns"> Class <code class="computeroutput"><span class="identifier">scanns</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">scanns</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">scanns</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="keyword">explicit</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">value</span><span class="special">);</span>
+
+	<span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.scanns.constructor"></a><h5>
+<a name="id684393"></a>
+        <a class="link" href="reference.html#boost_task.reference.scanns.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">scanns</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">value</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Preconditions:</span></dt>
+<dd><p>
+            value &gt; 0
+          </p></dd>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">scanns</span></code> instance
+          </p></dd>
+<dt><span class="term">Postconditions:</span></dt>
+<dd><p>
+            operator std::size_t () &gt; 0
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_poolsize</span></code>
+          </p></dd>
+</dl>
+</div>
+<a name="boost_task.reference.scanns.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_"></a><h5>
+<a name="id684570"></a>
+        <a class="link" href="reference.html#boost_task.reference.scanns.member_function__code__phrase_role__keyword__operator__phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase__phrase_role__special______phrase___code_">Member
+        function <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">()</span></code></a>
+      </h5>
+<pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="special">()</span> <span class="keyword">const</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            returns the value
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            Nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class invalid_poolsize">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.invalid_poolsize"></a><a class="link" href="reference.html#boost_task.reference.invalid_poolsize" title="Class invalid_poolsize"> Class <code class="computeroutput"><span class="identifier">invalid_poolsize</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">invalid_poolsize</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">invalid_argument</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">invalid_poolsize</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">);</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.invalid_poolsize.constructor"></a><h5>
+<a name="id684876"></a>
+        <a class="link" href="reference.html#boost_task.reference.invalid_poolsize.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">invalid_poolsize</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">);</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_poolsize</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class invalid_scanns">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.invalid_scanns"></a><a class="link" href="reference.html#boost_task.reference.invalid_scanns" title="Class invalid_scanns"> Class <code class="computeroutput"><span class="identifier">invalid_scanns</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">invalid_scanns</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">invalid_argument</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">invalid_scanns</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">);</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.invalid_scanns.constructor"></a><h5>
+<a name="id685189"></a>
+        <a class="link" href="reference.html#boost_task.reference.invalid_scanns.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">invalid_scanns</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_scanns</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class invalid_timeduration">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.invalid_timeduration"></a><a class="link" href="reference.html#boost_task.reference.invalid_timeduration" title="Class invalid_timeduration"> Class <code class="computeroutput"><span class="identifier">invalid_timeduration</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">invalid_timeduration</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">invalid_argument</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">invalid_timeduration</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">);</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.invalid_timeduration.constructor"></a><h5>
+<a name="id685503"></a>
+        <a class="link" href="reference.html#boost_task.reference.invalid_timeduration.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">invalid_timeduration</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_timeduration</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class invalid_watermark">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.invalid_watermark"></a><a class="link" href="reference.html#boost_task.reference.invalid_watermark" title="Class invalid_watermark"> Class <code class="computeroutput"><span class="identifier">invalid_watermark</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">invalid_watermark</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">invalid_argument</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">invalid_watermark</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">);</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.invalid_watermark.constructor"></a><h5>
+<a name="id685817"></a>
+        <a class="link" href="reference.html#boost_task.reference.invalid_watermark.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">invalid_watermark</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">invalid_watermark</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class task_rejected">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.task_rejected"></a><a class="link" href="reference.html#boost_task.reference.task_rejected" title="Class task_rejected"> Class <code class="computeroutput"><span class="identifier">task_rejected</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">task_rejected</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">task_rejected</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">);</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.task_rejected.constructor"></a><h5>
+<a name="id686131"></a>
+        <a class="link" href="reference.html#boost_task.reference.task_rejected.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task_rejected</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">msg</span><span class="special">)</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_rejected</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class task_unitialized">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.task_unitialized"></a><a class="link" href="reference.html#boost_task.reference.task_unitialized" title="Class task_unitialized"> Class <code class="computeroutput"><span class="identifier">task_unitialized</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">task_unitialized</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">logic_error</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">task_unitialized</span><span class="special">();</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.task_unitialized.constructor"></a><h5>
+<a name="id686410"></a>
+        <a class="link" href="reference.html#boost_task.reference.task_unitialized.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task_unitialized</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_unitialized</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class task_already_executed">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.task_already_executed"></a><a class="link" href="reference.html#boost_task.reference.task_already_executed" title="Class task_already_executed"> Class <code class="computeroutput"><span class="identifier">task_already_executed</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">task_already_executed</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">logic_error</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">task_already_executed</span><span class="special">();</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.task_already_executed.constructor"></a><h5>
+<a name="id686655"></a>
+        <a class="link" href="reference.html#boost_task.reference.task_already_executed.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task_already_executed</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_already_executed</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class task_moved">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.task_moved"></a><a class="link" href="reference.html#boost_task.reference.task_moved" title="Class task_moved"> Class <code class="computeroutput"><span class="identifier">task_moved</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">task_moved</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">logic_error</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">task_moved</span><span class="special">();</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.task_moved.constructor"></a><h5>
+<a name="id686899"></a>
+        <a class="link" href="reference.html#boost_task.reference.task_moved.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task_moved</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_moved</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class broken_task">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.broken_task"></a><a class="link" href="reference.html#boost_task.reference.broken_task" title="Class broken_task"> Class <code class="computeroutput"><span class="identifier">broken_task</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">broken_task</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">logic_error</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">broken_task</span><span class="special">();</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.broken_task.constructor"></a><h5>
+<a name="id687144"></a>
+        <a class="link" href="reference.html#boost_task.reference.broken_task.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">broken_task</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">broken_task</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class task_interrupted">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.task_interrupted"></a><a class="link" href="reference.html#boost_task.reference.task_interrupted" title="Class task_interrupted"> Class <code class="computeroutput"><span class="identifier">task_interrupted</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">task_interrupted</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">task_interrupted</span><span class="special">();</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.task_interrupted.constructor"></a><h5>
+<a name="id687387"></a>
+        <a class="link" href="reference.html#boost_task.reference.task_interrupted.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">task_interrupted</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_interrupted</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+<div class="section" title="Class pool_moved">
+<div class="titlepage"><div><div><h3 class="title">
+<a name="boost_task.reference.pool_moved"></a><a class="link" href="reference.html#boost_task.reference.pool_moved" title="Class pool_moved"> Class <code class="computeroutput"><span class="identifier">pool_moved</span></code></a>
+</h3></div></div></div>
+<p>
+        
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">/</span><span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+
+<span class="keyword">class</span> <span class="identifier">pool_moved</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">logic_error</span>
+<span class="special">{</span>
+<span class="keyword">public</span><span class="special">:</span>
+	<span class="identifier">pool_moved</span><span class="special">();</span>
+<span class="special">};</span>
+</pre>
+<p>
+      </p>
+<a name="boost_task.reference.pool_moved.constructor"></a><h5>
+<a name="id687632"></a>
+        <a class="link" href="reference.html#boost_task.reference.pool_moved.constructor">Constructor</a>
+      </h5>
+<pre class="programlisting"><span class="identifier">pool_moved</span><span class="special">()</span>
+</pre>
+<div class="variablelist">
+<p class="title"><b></b></p>
+<dl>
+<dt><span class="term">Effects:</span></dt>
+<dd><p>
+            constructs a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">pool_moved</span></code> instance
+          </p></dd>
+<dt><span class="term">Throws:</span></dt>
+<dd><p>
+            nothing
+          </p></dd>
+</dl>
+</div>
+</div>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="meta_functions.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="appendices.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/task.html boost-altered/libs/task/doc/html/boost_task/task.html
--- boost/libs/task/doc/html/boost_task/task.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/task.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,292 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Task</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="motivation.html" title="Motivation">
+<link rel="next" href="handle.html" title="Handle">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="motivation.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="handle.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Task">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.task"></a><a class="link" href="task.html" title="Task"> Task</a>
+</h2></div></div></div>
+<p>
+      A task is a chunk of code that can be executed independently.
+    </p>
+<p>
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+      represents a <span class="emphasis"><em>callable</em></span> (provides <code class="computeroutput"><span class="keyword">operator</span><span class="special">()()</span></code>) object containing the unit of code to
+      be execute by a <span class="emphasis"><em>execution-policy</em></span>. Function <code class="computeroutput"><span class="identifier">get_future</span><span class="special">()</span></code>
+      returns a <span class="emphasis"><em>asynchronous-completion-token</em></span> allowing to wait
+      for the completion of the computation of the task, for getting the result of
+      a computation or for transfering exceptions. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> supports move semantics (moving ownership).
+    </p>
+<a name="boost_task.task.cooperative_task_and_interruption"></a><h4>
+<a name="id643366"></a>
+      <a class="link" href="task.html#boost_task.task.cooperative_task_and_interruption">Cooperative
+      task and interruption</a>
+    </h4>
+<p>
+      Sometimes it is desired to stop a running task if it is no longer needed. In
+      this case the thread is not killed - it stops only at well-defined points (<span class="emphasis"><em>interruption-points</em></span>)
+      its execution. In the context of task-interruption a task is known as cooperative
+      if it checks for an interruption request between two <span class="emphasis"><em>interruption-points</em></span>
+      via <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">interruption_requested</span><span class="special">()</span></code>
+      <sup>[<a name="id643417" href="#ftn.id643417" class="footnote">2</a>]</sup>
+      .
+    </p>
+<p>
+      <span class="emphasis"><em>interruption-points</em></span> are:
+    </p>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span><span class="special">::</span><span class="identifier">join</span><span class="special">()</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span><span class="special">::</span><span class="identifier">timed_join</span><span class="special">()</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span><span class="special">::</span><span class="identifier">timed_wait</span><span class="special">()</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable_any</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable_any</span><span class="special">::</span><span class="identifier">timed_wait</span><span class="special">()</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span><span class="special">::</span><span class="identifier">sleep</span><span class="special">()</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">sleep</span><span class="special">()</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">interruption_point</span><span class="special">()</span></code></li>
+</ul></div>
+<p>
+      A <span class="emphasis"><em>interruption-point</em></span> throws <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_interrupted</span></code> if an interruption was requested.
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">cooperative</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="comment">// interruption point
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">interruption_point</span><span class="special">();</span>
+	
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="comment">// check if interruption was requested
+</span>		<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">interruption_requested</span><span class="special">()</span> <span class="special">)</span>
+			<span class="keyword">return</span><span class="special">;</span>
+			
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+	
+	<span class="comment">// interruption point
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">interruption_point</span><span class="special">();</span>
+	
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// task for computing fibonacci-number
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">cooperative</span><span class="special">,</span> <span class="number">10</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// execute task in new thread
+</span>	<span class="comment">// move task ownership to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// interrupt task an wait until
+</span>	<span class="comment">// the task is removed by the worker-thread
+</span>	<span class="identifier">h</span><span class="special">.</span><span class="identifier">interrupt_and_wait</span><span class="special">();</span>
+
+	<span class="comment">// access the result
+</span>	<span class="comment">// throws boost::task::task_interrupted
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<a name="boost_task.task.exceptions"></a><h4>
+<a name="id644579"></a>
+      <a class="link" href="task.html#boost_task.task.exceptions">Exceptions</a>
+    </h4>
+<p>
+      Exceptions thrown by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> are transported by the <span class="emphasis"><em>asynchronous-completion-token</em></span>.
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">throwing</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="special">...</span>
+	<span class="keyword">throw</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">domain_error</span><span class="special">(</span><span class="string">"domain error"</span><span class="special">);</span>
+	<span class="special">...</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// create task throwing std::domain_error
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span> <span class="identifier">throwing</span><span class="special">);</span>
+
+	<span class="comment">// execute task asynchron
+</span>	<span class="comment">// move task ownership to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span><span class="special">()</span> <span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// wait for task completion
+</span>	<span class="comment">// throws std::domain_error
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">wait</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<p>
+      Exceptions rethrown by type are:
+    </p>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_cast</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_exception</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_typeid</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">domain_error</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">invalid_argument</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">failure</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">length_error</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">logic_error</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">out_of_range</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">overflow_error</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">range_error</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">underflow_error</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">exception</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_already_set</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">future_cancel</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">invalid_thread_argument</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_error</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">broken_task</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">pool_moved</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_already_executed</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_interrupted</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_moved</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task_interrupted</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_task_rejected</span></code></li>
+<li class="listitem"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task_unitialized</span></code></li>
+</ul></div>
+<a name="boost_task.task.parent_task"></a><h4>
+<a name="id645550"></a>
+      <a class="link" href="task.html#boost_task.task.parent_task">Parent task</a>
+    </h4>
+<p>
+      Top-level tasks have no parent. A parent task can create child tasks when it
+      creates another task by using <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">as_sub_task</span></code> as <span class="emphasis"><em>execution-policy</em></span>.
+      These children are implicitly treated as <span class="emphasis"><em>sub-tasks</em></span> of
+      the larger task. It is assumed that that <span class="emphasis"><em>sub-tasks</em></span> can
+      be executed in any order because only overall operation speed matters (enabling
+      strategies for fast execution of unordered <span class="emphasis"><em>work-items</em></span>
+      as <a class="link" href="pool.html#boost_task.pool.work_stealing" title="Work-Stealing"><span class="emphasis"><em>work-stealing</em></span></a>).
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span><span class="special">(</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="number">2</span><span class="special">)</span> <span class="keyword">return</span> <span class="identifier">n</span><span class="special">;</span>
+	<span class="keyword">else</span> <span class="keyword">return</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="identifier">n</span> <span class="special">-</span> <span class="number">1</span><span class="special">)</span> <span class="special">+</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="identifier">n</span> <span class="special">-</span> <span class="number">2</span><span class="special">);</span>
+<span class="special">}</span>
+
+<span class="keyword">long</span> <span class="identifier">parallel_fib</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">,</span> <span class="keyword">long</span> <span class="identifier">cutof</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">&lt;</span> <span class="identifier">cutof</span><span class="special">)</span> <span class="keyword">return</span> <span class="identifier">serial_fib</span><span class="special">(</span> <span class="identifier">n</span><span class="special">);</span>
+	<span class="keyword">else</span>
+	<span class="special">{</span>
+		<span class="comment">// sub-task for computing fibonacci(n-1)
+</span>		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span>
+			<span class="identifier">parallel_fib</span><span class="special">,</span>
+			<span class="identifier">n</span> <span class="special">-</span> <span class="number">1</span><span class="special">,</span>
+			<span class="identifier">cutof</span><span class="special">);</span>
+		<span class="comment">// sub-task for computing fibonacci(n-2)
+</span>		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span>
+			<span class="identifier">parallel_fib</span><span class="special">,</span>
+			<span class="identifier">n</span> <span class="special">-</span> <span class="number">2</span><span class="special">,</span>
+			<span class="identifier">cutof</span><span class="special">);</span>
+
+		<span class="comment">// submit a sub-tasks to thread-pool
+</span>		<span class="comment">// move task ownership to executor
+</span>		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h1</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+				<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">)</span> <span class="special">);</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h2</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+				<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">)</span> <span class="special">);</span>
+
+		<span class="comment">// computing fibonacci(n) by
+</span>		<span class="comment">// joining results of both sub-tasks
+</span>		<span class="keyword">return</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
+	<span class="special">}</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// create thread-pool with five worker-threads
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">fifo</span>
+		<span class="special">&gt;</span>
+	<span class="special">&gt;</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">5</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// create task computing fibonacci-number for 10
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t</span><span class="special">(</span>
+		<span class="identifier">parallel_fib</span><span class="special">,</span>
+		<span class="number">10</span><span class="special">,</span>
+		<span class="number">5</span><span class="special">);</span>
+
+	<span class="comment">// execute task asynchron in thread-pool
+</span>	<span class="comment">// move task ownership to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// access result
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<div class="footnotes">
+<br><hr width="100" align="left">
+<div class="footnote"><p><sup>[<a name="ftn.id643417" href="#id643417" class="para">2</a>] </sup>
+          see <a href="http://www.ddj.com/architect/207100682" target="_top">'Interrupt Politely'</a>,
+          Herb Sutter
+        </p></div>
+</div>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="motivation.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="handle.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/boost_task/utilities.html boost-altered/libs/task/doc/html/boost_task/utilities.html
--- boost/libs/task/doc/html/boost_task/utilities.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/boost_task/utilities.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,112 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Utilities</title>
+<link rel="stylesheet" href="../boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="up" href="../index.html" title="Chapter1.Boost.Task">
+<link rel="prev" href="as_sub_task.html" title="Execute as sub-task">
+<link rel="next" href="meta_functions.html" title="Meta functions">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
+<td align="center"><a href="../../../index.html">Home</a></td>
+<td align="center"><a href="../libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="as_sub_task.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="meta_functions.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+<div class="section" title="Utilities">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.utilities"></a><a class="link" href="utilities.html" title="Utilities"> Utilities</a>
+</h2></div></div></div>
+<p>
+      <span class="bold"><strong>Boost.Task</strong></span> provides some free-functions which
+      can be used inside a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> to access some informations (like if
+      the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+      runs in a <span class="emphasis"><em>thread-pool</em></span>).
+    </p>
+<a name="boost_task.utilities.reschedule_until"></a><h4>
+<a name="id662954"></a>
+      <a class="link" href="utilities.html#boost_task.utilities.reschedule_until">reschedule_until</a>
+    </h4>
+<p>
+      In the function <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">reschedule_until</span><span class="special">(</span>
+      <span class="identifier">Pred</span> <span class="keyword">const</span><span class="special">&amp;)</span></code> allows to synchronize the task with other
+      asynchronous events without blocking the <span class="emphasis"><em>worker-threads</em></span>
+      (bool Pred::operator()() must not block). The current task will be rescheduled
+      until the passed predicate becomes true.
+    </p>
+<a name="boost_task.utilities.get_pool"></a><h4>
+<a name="id663030"></a>
+      <a class="link" href="utilities.html#boost_task.utilities.get_pool">get_pool</a>
+    </h4>
+<p>
+      The pool in which the current code (<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>) is executed can be accessed via <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">get_pool</span><span class="special">()</span></code>. If hte code is not executed by a <span class="emphasis"><em>worker-thread</em></span>
+      an assertion is raised.
+    </p>
+<a name="boost_task.utilities.runs_in_pool"></a><h4>
+<a name="id663119"></a>
+      <a class="link" href="utilities.html#boost_task.utilities.runs_in_pool">runs_in_pool</a>
+    </h4>
+<p>
+      In order to check if the current code is executed in a <span class="emphasis"><em>thread-pool</em></span>
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">runs_in_pool</span><span class="special">()</span></code>
+      should be used.
+    </p>
+<a name="boost_task.utilities.worker_id"></a><h4>
+<a name="id663178"></a>
+      <a class="link" href="utilities.html#boost_task.utilities.worker_id">worker_id</a>
+    </h4>
+<p>
+      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">worker_id</span><span class="special">()</span></code>
+      returns the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span><span class="special">::</span><span class="identifier">id</span></code> of the <span class="emphasis"><em>worker-thread</em></span>
+      executing the current <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>.
+    </p>
+<a name="boost_task.utilities.delay"></a><h4>
+<a name="id663294"></a>
+      <a class="link" href="utilities.html#boost_task.utilities.delay">delay</a>
+    </h4>
+<p>
+      The execution of a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+      can be delayed for a time-duration or until a specific time-point with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">delay</span><span class="special">()</span></code>.
+    </p>
+<a name="boost_task.utilities.yield"></a><h4>
+<a name="id663378"></a>
+      <a class="link" href="utilities.html#boost_task.utilities.yield">yield</a>
+    </h4>
+<p>
+      If a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+      detects that it would bould block it can yield itself with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">yield</span><span class="special">()</span></code>
+      so that the <span class="emphasis"><em>worker-thread</em></span> can execute another <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code> in
+      the meantime.
+    </p>
+<a name="boost_task.utilities.interrupt"></a><h4>
+<a name="id663495"></a>
+      <a class="link" href="utilities.html#boost_task.utilities.interrupt">interrupt</a>
+    </h4>
+<p>
+      A <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>
+      can interrupt itself via <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span><span class="special">::</span><span class="identifier">interrupt</span><span class="special">()</span></code>.
+    </p>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"></td>
+<td align="right"><div class="copyright-footer">Copyright  2009 Oliver Kowalke<p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav">
+<a accesskey="p" href="as_sub_task.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="meta_functions.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
+</div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/docutils.css boost-altered/libs/task/doc/html/docutils.css
--- boost/libs/task/doc/html/docutils.css	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/docutils.css	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,275 @@
+/*
+:Author: David Goodger
+:Contact: goodger@python.org
+:Date: $Date: 2007-11-25 19:34:32 +0000 (Sun, 25 Nov 2007) $
+:Revision: $Revision: 41371 $
+:Copyright: This stylesheet has been placed in the public domain.
+
+Default cascading style sheet for the HTML output of Docutils.
+
+See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
+customize this style sheet.
+*/
+
+/* used to remove borders from tables and images */
+.borderless, table.borderless td, table.borderless th {
+  border: 0 }
+
+table.borderless td, table.borderless th {
+  /* Override padding for "table.docutils td" with "! important".
+     The right padding separates the table cells. */
+  padding: 0 0.5em 0 0 ! important }
+
+.first {
+  /* Override more specific margin styles with "! important". */
+  margin-top: 0 ! important }
+
+.last, .with-subtitle {
+  margin-bottom: 0 ! important }
+
+.hidden {
+  display: none }
+
+a.toc-backref {
+  text-decoration: none ;
+  color: black }
+
+blockquote.epigraph {
+  margin: 2em 5em ; }
+
+dl.docutils dd {
+  margin-bottom: 0.5em }
+
+/* Uncomment (and remove this text!) to get bold-faced definition list terms
+dl.docutils dt {
+  font-weight: bold }
+*/
+
+div.abstract {
+  margin: 2em 5em }
+
+div.abstract p.topic-title {
+  font-weight: bold ;
+  text-align: center }
+
+div.admonition, div.attention, div.caution, div.danger, div.error,
+div.hint, div.important, div.note, div.tip, div.warning {
+  margin: 2em ;
+  border: medium outset ;
+  padding: 1em }
+
+div.admonition p.admonition-title, div.hint p.admonition-title,
+div.important p.admonition-title, div.note p.admonition-title,
+div.tip p.admonition-title {
+  font-weight: bold ;
+  font-family: sans-serif }
+
+div.attention p.admonition-title, div.caution p.admonition-title,
+div.danger p.admonition-title, div.error p.admonition-title,
+div.warning p.admonition-title {
+  color: red ;
+  font-weight: bold ;
+  font-family: sans-serif }
+
+/* Uncomment (and remove this text!) to get reduced vertical space in
+   compound paragraphs.
+div.compound .compound-first, div.compound .compound-middle {
+  margin-bottom: 0.5em }
+
+div.compound .compound-last, div.compound .compound-middle {
+  margin-top: 0.5em }
+*/
+
+div.dedication {
+  margin: 2em 5em ;
+  text-align: center ;
+  font-style: italic }
+
+div.dedication p.topic-title {
+  font-weight: bold ;
+  font-style: normal }
+
+div.figure {
+  margin-left: 2em ;
+  margin-right: 2em }
+
+div.footer, div.header {
+  clear: both;
+  font-size: smaller }
+
+div.line-block {
+  display: block ;
+  margin-top: 1em ;
+  margin-bottom: 1em }
+
+div.line-block div.line-block {
+  margin-top: 0 ;
+  margin-bottom: 0 ;
+  margin-left: 1.5em }
+
+div.sidebar {
+  margin-left: 1em ;
+  border: medium outset ;
+  padding: 1em ;
+  background-color: #ffffee ;
+  width: 40% ;
+  float: right ;
+  clear: right }
+
+div.sidebar p.rubric {
+  font-family: sans-serif ;
+  font-size: medium }
+
+div.system-messages {
+  margin: 5em }
+
+div.system-messages h1 {
+  color: red }
+
+div.system-message {
+  border: medium outset ;
+  padding: 1em }
+
+div.system-message p.system-message-title {
+  color: red ;
+  font-weight: bold }
+
+div.topic {
+  margin: 2em }
+
+h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
+h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
+  margin-top: 0.4em }
+
+h1.title {
+  text-align: center }
+
+h2.subtitle {
+  text-align: center }
+
+hr.docutils {
+  width: 75% }
+
+img.align-left {
+  clear: left }
+
+img.align-right {
+  clear: right }
+
+ol.simple, ul.simple {
+  margin-bottom: 1em }
+
+ol.arabic {
+  list-style: decimal }
+
+ol.loweralpha {
+  list-style: lower-alpha }
+
+ol.upperalpha {
+  list-style: upper-alpha }
+
+ol.lowerroman {
+  list-style: lower-roman }
+
+ol.upperroman {
+  list-style: upper-roman }
+
+p.attribution {
+  text-align: right ;
+  margin-left: 50% }
+
+p.caption {
+  font-style: italic }
+
+p.credits {
+  font-style: italic ;
+  font-size: smaller }
+
+p.label {
+  white-space: nowrap }
+
+p.rubric {
+  font-weight: bold ;
+  font-size: larger ;
+  color: maroon ;
+  text-align: center }
+
+p.sidebar-title {
+  font-family: sans-serif ;
+  font-weight: bold ;
+  font-size: larger }
+
+p.sidebar-subtitle {
+  font-family: sans-serif ;
+  font-weight: bold }
+
+p.topic-title {
+  font-weight: bold }
+
+pre.address {
+  margin-bottom: 0 ;
+  margin-top: 0 ;
+  font-family: serif ;
+  font-size: 100% }
+
+pre.literal-block, pre.doctest-block {
+  margin-left: 2em ;
+  margin-right: 2em }
+
+span.classifier {
+  font-family: sans-serif ;
+  font-style: oblique }
+
+span.classifier-delimiter {
+  font-family: sans-serif ;
+  font-weight: bold }
+
+span.interpreted {
+  font-family: sans-serif }
+
+span.option {
+  white-space: nowrap }
+
+span.pre {
+  white-space: pre }
+
+span.problematic {
+  color: red }
+
+span.section-subtitle {
+  /* font-size relative to parent (h1..h6 element) */
+  font-size: 80% }
+
+table.citation {
+  border-left: solid 1px gray;
+  margin-left: 1px }
+
+table.docinfo {
+  margin: 2em 4em }
+
+table.docutils {
+  margin-top: 0.5em ;
+  margin-bottom: 0.5em }
+
+table.footnote {
+  border-left: solid 1px black;
+  margin-left: 1px }
+
+table.docutils td, table.docutils th,
+table.docinfo td, table.docinfo th {
+  padding-left: 0.5em ;
+  padding-right: 0.5em ;
+  vertical-align: top }
+
+table.docutils th.field-name, table.docinfo th.docinfo-name {
+  font-weight: bold ;
+  text-align: left ;
+  white-space: nowrap ;
+  padding-left: 0 }
+
+h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
+h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
+  font-size: 100% }
+
+ul.auto-toc {
+  list-style-type: none }
Binary files boost/libs/task/doc/html/images/accumulators/doxygen.png and boost-altered/libs/task/doc/html/images/accumulators/doxygen.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_0.png and boost-altered/libs/task/doc/html/images/accumulators/form_0.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_100.png and boost-altered/libs/task/doc/html/images/accumulators/form_100.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_10.png and boost-altered/libs/task/doc/html/images/accumulators/form_10.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_11.png and boost-altered/libs/task/doc/html/images/accumulators/form_11.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_12.png and boost-altered/libs/task/doc/html/images/accumulators/form_12.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_13.png and boost-altered/libs/task/doc/html/images/accumulators/form_13.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_14.png and boost-altered/libs/task/doc/html/images/accumulators/form_14.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_15.png and boost-altered/libs/task/doc/html/images/accumulators/form_15.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_16.png and boost-altered/libs/task/doc/html/images/accumulators/form_16.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_17.png and boost-altered/libs/task/doc/html/images/accumulators/form_17.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_18.png and boost-altered/libs/task/doc/html/images/accumulators/form_18.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_19.png and boost-altered/libs/task/doc/html/images/accumulators/form_19.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_1.png and boost-altered/libs/task/doc/html/images/accumulators/form_1.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_20.png and boost-altered/libs/task/doc/html/images/accumulators/form_20.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_21.png and boost-altered/libs/task/doc/html/images/accumulators/form_21.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_22.png and boost-altered/libs/task/doc/html/images/accumulators/form_22.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_23.png and boost-altered/libs/task/doc/html/images/accumulators/form_23.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_24.png and boost-altered/libs/task/doc/html/images/accumulators/form_24.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_25.png and boost-altered/libs/task/doc/html/images/accumulators/form_25.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_26.png and boost-altered/libs/task/doc/html/images/accumulators/form_26.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_27.png and boost-altered/libs/task/doc/html/images/accumulators/form_27.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_28.png and boost-altered/libs/task/doc/html/images/accumulators/form_28.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_29.png and boost-altered/libs/task/doc/html/images/accumulators/form_29.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_2.png and boost-altered/libs/task/doc/html/images/accumulators/form_2.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_30.png and boost-altered/libs/task/doc/html/images/accumulators/form_30.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_31.png and boost-altered/libs/task/doc/html/images/accumulators/form_31.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_32.png and boost-altered/libs/task/doc/html/images/accumulators/form_32.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_33.png and boost-altered/libs/task/doc/html/images/accumulators/form_33.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_34.png and boost-altered/libs/task/doc/html/images/accumulators/form_34.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_35.png and boost-altered/libs/task/doc/html/images/accumulators/form_35.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_36.png and boost-altered/libs/task/doc/html/images/accumulators/form_36.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_37.png and boost-altered/libs/task/doc/html/images/accumulators/form_37.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_38.png and boost-altered/libs/task/doc/html/images/accumulators/form_38.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_39.png and boost-altered/libs/task/doc/html/images/accumulators/form_39.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_3.png and boost-altered/libs/task/doc/html/images/accumulators/form_3.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_40.png and boost-altered/libs/task/doc/html/images/accumulators/form_40.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_41.png and boost-altered/libs/task/doc/html/images/accumulators/form_41.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_42.png and boost-altered/libs/task/doc/html/images/accumulators/form_42.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_43.png and boost-altered/libs/task/doc/html/images/accumulators/form_43.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_44.png and boost-altered/libs/task/doc/html/images/accumulators/form_44.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_45.png and boost-altered/libs/task/doc/html/images/accumulators/form_45.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_46.png and boost-altered/libs/task/doc/html/images/accumulators/form_46.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_47.png and boost-altered/libs/task/doc/html/images/accumulators/form_47.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_48.png and boost-altered/libs/task/doc/html/images/accumulators/form_48.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_49.png and boost-altered/libs/task/doc/html/images/accumulators/form_49.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_4.png and boost-altered/libs/task/doc/html/images/accumulators/form_4.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_50.png and boost-altered/libs/task/doc/html/images/accumulators/form_50.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_51.png and boost-altered/libs/task/doc/html/images/accumulators/form_51.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_52.png and boost-altered/libs/task/doc/html/images/accumulators/form_52.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_53.png and boost-altered/libs/task/doc/html/images/accumulators/form_53.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_54.png and boost-altered/libs/task/doc/html/images/accumulators/form_54.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_55.png and boost-altered/libs/task/doc/html/images/accumulators/form_55.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_56.png and boost-altered/libs/task/doc/html/images/accumulators/form_56.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_57.png and boost-altered/libs/task/doc/html/images/accumulators/form_57.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_58.png and boost-altered/libs/task/doc/html/images/accumulators/form_58.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_59.png and boost-altered/libs/task/doc/html/images/accumulators/form_59.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_5.png and boost-altered/libs/task/doc/html/images/accumulators/form_5.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_60.png and boost-altered/libs/task/doc/html/images/accumulators/form_60.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_61.png and boost-altered/libs/task/doc/html/images/accumulators/form_61.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_62.png and boost-altered/libs/task/doc/html/images/accumulators/form_62.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_63.png and boost-altered/libs/task/doc/html/images/accumulators/form_63.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_64.png and boost-altered/libs/task/doc/html/images/accumulators/form_64.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_65.png and boost-altered/libs/task/doc/html/images/accumulators/form_65.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_66.png and boost-altered/libs/task/doc/html/images/accumulators/form_66.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_67.png and boost-altered/libs/task/doc/html/images/accumulators/form_67.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_68.png and boost-altered/libs/task/doc/html/images/accumulators/form_68.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_69.png and boost-altered/libs/task/doc/html/images/accumulators/form_69.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_6.png and boost-altered/libs/task/doc/html/images/accumulators/form_6.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_70.png and boost-altered/libs/task/doc/html/images/accumulators/form_70.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_71.png and boost-altered/libs/task/doc/html/images/accumulators/form_71.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_72.png and boost-altered/libs/task/doc/html/images/accumulators/form_72.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_73.png and boost-altered/libs/task/doc/html/images/accumulators/form_73.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_74.png and boost-altered/libs/task/doc/html/images/accumulators/form_74.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_75.png and boost-altered/libs/task/doc/html/images/accumulators/form_75.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_76.png and boost-altered/libs/task/doc/html/images/accumulators/form_76.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_77.png and boost-altered/libs/task/doc/html/images/accumulators/form_77.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_78.png and boost-altered/libs/task/doc/html/images/accumulators/form_78.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_79.png and boost-altered/libs/task/doc/html/images/accumulators/form_79.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_7.png and boost-altered/libs/task/doc/html/images/accumulators/form_7.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_80.png and boost-altered/libs/task/doc/html/images/accumulators/form_80.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_81.png and boost-altered/libs/task/doc/html/images/accumulators/form_81.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_82.png and boost-altered/libs/task/doc/html/images/accumulators/form_82.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_83.png and boost-altered/libs/task/doc/html/images/accumulators/form_83.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_84.png and boost-altered/libs/task/doc/html/images/accumulators/form_84.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_85.png and boost-altered/libs/task/doc/html/images/accumulators/form_85.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_86.png and boost-altered/libs/task/doc/html/images/accumulators/form_86.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_87.png and boost-altered/libs/task/doc/html/images/accumulators/form_87.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_88.png and boost-altered/libs/task/doc/html/images/accumulators/form_88.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_89.png and boost-altered/libs/task/doc/html/images/accumulators/form_89.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_8.png and boost-altered/libs/task/doc/html/images/accumulators/form_8.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_90.png and boost-altered/libs/task/doc/html/images/accumulators/form_90.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_91.png and boost-altered/libs/task/doc/html/images/accumulators/form_91.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_92.png and boost-altered/libs/task/doc/html/images/accumulators/form_92.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_93.png and boost-altered/libs/task/doc/html/images/accumulators/form_93.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_94.png and boost-altered/libs/task/doc/html/images/accumulators/form_94.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_95.png and boost-altered/libs/task/doc/html/images/accumulators/form_95.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_96.png and boost-altered/libs/task/doc/html/images/accumulators/form_96.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_97.png and boost-altered/libs/task/doc/html/images/accumulators/form_97.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_98.png and boost-altered/libs/task/doc/html/images/accumulators/form_98.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_99.png and boost-altered/libs/task/doc/html/images/accumulators/form_99.png differ
Binary files boost/libs/task/doc/html/images/accumulators/form_9.png and boost-altered/libs/task/doc/html/images/accumulators/form_9.png differ
Binary files boost/libs/task/doc/html/images/alert.png and boost-altered/libs/task/doc/html/images/alert.png differ
Binary files boost/libs/task/doc/html/images/blank.png and boost-altered/libs/task/doc/html/images/blank.png differ
Binary files boost/libs/task/doc/html/images/callouts/10.png and boost-altered/libs/task/doc/html/images/callouts/10.png differ
Binary files boost/libs/task/doc/html/images/callouts/11.png and boost-altered/libs/task/doc/html/images/callouts/11.png differ
Binary files boost/libs/task/doc/html/images/callouts/12.png and boost-altered/libs/task/doc/html/images/callouts/12.png differ
Binary files boost/libs/task/doc/html/images/callouts/13.png and boost-altered/libs/task/doc/html/images/callouts/13.png differ
Binary files boost/libs/task/doc/html/images/callouts/14.png and boost-altered/libs/task/doc/html/images/callouts/14.png differ
Binary files boost/libs/task/doc/html/images/callouts/15.png and boost-altered/libs/task/doc/html/images/callouts/15.png differ
Binary files boost/libs/task/doc/html/images/callouts/1.png and boost-altered/libs/task/doc/html/images/callouts/1.png differ
Binary files boost/libs/task/doc/html/images/callouts/2.png and boost-altered/libs/task/doc/html/images/callouts/2.png differ
Binary files boost/libs/task/doc/html/images/callouts/3.png and boost-altered/libs/task/doc/html/images/callouts/3.png differ
Binary files boost/libs/task/doc/html/images/callouts/4.png and boost-altered/libs/task/doc/html/images/callouts/4.png differ
Binary files boost/libs/task/doc/html/images/callouts/5.png and boost-altered/libs/task/doc/html/images/callouts/5.png differ
Binary files boost/libs/task/doc/html/images/callouts/6.png and boost-altered/libs/task/doc/html/images/callouts/6.png differ
Binary files boost/libs/task/doc/html/images/callouts/7.png and boost-altered/libs/task/doc/html/images/callouts/7.png differ
Binary files boost/libs/task/doc/html/images/callouts/8.png and boost-altered/libs/task/doc/html/images/callouts/8.png differ
Binary files boost/libs/task/doc/html/images/callouts/9.png and boost-altered/libs/task/doc/html/images/callouts/9.png differ
Binary files boost/libs/task/doc/html/images/caution.png and boost-altered/libs/task/doc/html/images/caution.png differ
Binary files boost/libs/task/doc/html/images/draft.png and boost-altered/libs/task/doc/html/images/draft.png differ
Binary files boost/libs/task/doc/html/images/home.png and boost-altered/libs/task/doc/html/images/home.png differ
Binary files boost/libs/task/doc/html/images/important.png and boost-altered/libs/task/doc/html/images/important.png differ
Binary files boost/libs/task/doc/html/images/next_disabled.png and boost-altered/libs/task/doc/html/images/next_disabled.png differ
Binary files boost/libs/task/doc/html/images/next.png and boost-altered/libs/task/doc/html/images/next.png differ
Binary files boost/libs/task/doc/html/images/note.png and boost-altered/libs/task/doc/html/images/note.png differ
Binary files boost/libs/task/doc/html/images/prev_disabled.png and boost-altered/libs/task/doc/html/images/prev_disabled.png differ
Binary files boost/libs/task/doc/html/images/prev.png and boost-altered/libs/task/doc/html/images/prev.png differ
Binary files boost/libs/task/doc/html/images/smiley.png and boost-altered/libs/task/doc/html/images/smiley.png differ
Binary files boost/libs/task/doc/html/images/tip.png and boost-altered/libs/task/doc/html/images/tip.png differ
Binary files boost/libs/task/doc/html/images/toc-blank.png and boost-altered/libs/task/doc/html/images/toc-blank.png differ
Binary files boost/libs/task/doc/html/images/toc-minus.png and boost-altered/libs/task/doc/html/images/toc-minus.png differ
Binary files boost/libs/task/doc/html/images/toc-plus.png and boost-altered/libs/task/doc/html/images/toc-plus.png differ
Binary files boost/libs/task/doc/html/images/up_disabled.png and boost-altered/libs/task/doc/html/images/up_disabled.png differ
Binary files boost/libs/task/doc/html/images/up.png and boost-altered/libs/task/doc/html/images/up.png differ
Binary files boost/libs/task/doc/html/images/warning.png and boost-altered/libs/task/doc/html/images/warning.png differ
diff -urN boost/libs/task/doc/html/index.html boost-altered/libs/task/doc/html/index.html
--- boost/libs/task/doc/html/index.html	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/index.html	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,414 @@
+<html>
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<title>Chapter1.Boost.Task</title>
+<link rel="stylesheet" href="boostbook.css" type="text/css">
+<meta name="generator" content="DocBook XSL Stylesheets V1.75.1">
+<link rel="home" href="index.html" title="Chapter1.Boost.Task">
+<link rel="next" href="boost_task/motivation.html" title="Motivation">
+</head>
+<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
+<table cellpadding="2" width="100%"><tr>
+<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../boost.png"></td>
+<td align="center"><a href="../../index.html">Home</a></td>
+<td align="center"><a href="libraries.html">Libraries</a></td>
+<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
+<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
+<td align="center"><a href="../../more/index.htm">More</a></td>
+</tr></table>
+<hr>
+<div class="spirit-nav"><a accesskey="n" href="boost_task/motivation.html"><img src="../../doc/html/images/next.png" alt="Next"></a></div>
+<div class="chapter" title="Chapter1.Boost.Task">
+<div class="titlepage"><div>
+<div><h2 class="title">
+<a name="boost_task"></a>Chapter1.Boost.Task</h2></div>
+<div><div class="author"><h3 class="author">
+<span class="firstname">Oliver</span> <span class="surname">Kowalke</span>
+</h3></div></div>
+<div><p class="copyright">Copyright  2009 Oliver Kowalke</p></div>
+<div><div class="legalnotice" title="Legal Notice">
+<a name="id623344"></a><p>
+        Distributed under the Boost Software License, Version 1.0. (See accompanying
+        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
+      </p>
+</div></div>
+</div></div>
+<div class="toc">
+<p><b>Table of Contents</b></p>
+<dl>
+<dt><span class="section"><a href="index.html#boost_task.overview"> Overview</a></span></dt>
+<dt><span class="section"><a href="boost_task/motivation.html"> Motivation</a></span></dt>
+<dt><span class="section"><a href="boost_task/task.html"> Task</a></span></dt>
+<dt><span class="section"><a href="boost_task/handle.html"> Handle</a></span></dt>
+<dt><span class="section"><a href="boost_task/async.html"> Asynchronous execution</a></span></dt>
+<dt><span class="section"><a href="boost_task/own_thread.html"> Execute in own thread</a></span></dt>
+<dt><span class="section"><a href="boost_task/new_thread.html"> Execute in new thread</a></span></dt>
+<dt><span class="section"><a href="boost_task/pool.html"> Thread-pool</a></span></dt>
+<dd><dl>
+<dt><span class="section"><a href="boost_task/pool.html#boost_task.pool.static_pool"> Static thread-pool</a></span></dt>
+<dt><span class="section"><a href="boost_task/pool.html#boost_task.pool.channel"> Channel</a></span></dt>
+<dt><span class="section"><a href="boost_task/pool.html#boost_task.pool.scheduling"> Scheduling</a></span></dt>
+<dt><span class="section"><a href="boost_task/pool.html#boost_task.pool.pool_shutdown"> Pool shutdown</a></span></dt>
+<dt><span class="section"><a href="boost_task/pool.html#boost_task.pool.processor_binding"> Processor binding</a></span></dt>
+<dt><span class="section"><a href="boost_task/pool.html#boost_task.pool.work_stealing"> Work-Stealing</a></span></dt>
+<dt><span class="section"><a href="boost_task/pool.html#boost_task.pool.forkjoin"> Fork/Join</a></span></dt>
+</dl></dd>
+<dt><span class="section"><a href="boost_task/as_sub_task.html"> Execute as sub-task</a></span></dt>
+<dt><span class="section"><a href="boost_task/utilities.html"> Utilities</a></span></dt>
+<dt><span class="section"><a href="boost_task/meta_functions.html"> Meta functions</a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html"> Reference</a></span></dt>
+<dd><dl>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.task"> Class template <code class="computeroutput"><span class="identifier">task</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.handle"> Class template <code class="computeroutput"><span class="identifier">handle</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.async"> Non-member function <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;,</span> <span class="identifier">EP</span><span class="special">)</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.async1"> Non-member function <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;,</span> <span class="identifier">pool</span><span class="special">&lt;</span> <span class="identifier">Channel</span> <span class="special">&gt;</span> <span class="special">&amp;)</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.async2"> Non-member function <code class="computeroutput"><span class="identifier">async</span><span class="special">(</span> <span class="identifier">task</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span>
+      <span class="special">&amp;&amp;,</span> <span class="identifier">Attr</span><span class="special">,</span> <span class="identifier">pool</span><span class="special">&lt;</span>
+      <span class="identifier">Channel</span> <span class="special">&gt;</span>
+      <span class="special">&amp;)</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.own_thread"> Class <code class="computeroutput"><span class="identifier">own_thread</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.new_thread"> Class <code class="computeroutput"><span class="identifier">new_thread</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.static_pool"> Class template <code class="computeroutput"><span class="identifier">static_pool</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.reschedule_until"> Non-member function
+      <code class="computeroutput"><span class="identifier">reschedule_until</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.get_pool"> Non-member function
+      <code class="computeroutput"><span class="identifier">get_pool</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.runs_in_pool"> Non-member function
+      <code class="computeroutput"><span class="identifier">runs_in_pool</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.worker_id"> Non-member function
+      <code class="computeroutput"><span class="identifier">worker_id</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.delay"> Non-member function <code class="computeroutput"><span class="identifier">delay</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.yield"> Non-member function <code class="computeroutput"><span class="identifier">yield</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.interrupt"> Non-member function
+      <code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.has_attribute"> Meta function <code class="computeroutput"><span class="identifier">has_attribute</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.attribute_type"> Meta function
+      <code class="computeroutput"><span class="identifier">attribute_type</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.poolsize"> Class <code class="computeroutput"><span class="identifier">poolsize</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.high_watermark"> Class <code class="computeroutput"><span class="identifier">high_watermark</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.low_watermark"> Class <code class="computeroutput"><span class="identifier">low_watermark</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.scanns"> Class <code class="computeroutput"><span class="identifier">scanns</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.invalid_poolsize"> Class <code class="computeroutput"><span class="identifier">invalid_poolsize</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.invalid_scanns"> Class <code class="computeroutput"><span class="identifier">invalid_scanns</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.invalid_timeduration"> Class <code class="computeroutput"><span class="identifier">invalid_timeduration</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.invalid_watermark"> Class <code class="computeroutput"><span class="identifier">invalid_watermark</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.task_rejected"> Class <code class="computeroutput"><span class="identifier">task_rejected</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.task_unitialized"> Class <code class="computeroutput"><span class="identifier">task_unitialized</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.task_already_executed"> Class <code class="computeroutput"><span class="identifier">task_already_executed</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.task_moved"> Class <code class="computeroutput"><span class="identifier">task_moved</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.broken_task"> Class <code class="computeroutput"><span class="identifier">broken_task</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.task_interrupted"> Class <code class="computeroutput"><span class="identifier">task_interrupted</span></code></a></span></dt>
+<dt><span class="section"><a href="boost_task/reference.html#boost_task.reference.pool_moved"> Class <code class="computeroutput"><span class="identifier">pool_moved</span></code></a></span></dt>
+</dl></dd>
+<dt><span class="section"><a href="boost_task/appendices.html">Appendices</a></span></dt>
+<dd><dl>
+<dt><span class="section"><a href="boost_task/appendices.html#boost_task.appendices.todo"> Appendix A: Future development</a></span></dt>
+<dt><span class="section"><a href="boost_task/appendices.html#boost_task.appendices.acknowledgements"> Appendix B:
+      Acknowledgments</a></span></dt>
+</dl></dd>
+</dl>
+</div>
+<div class="section" title="Overview">
+<div class="titlepage"><div><div><h2 class="title" style="clear: both">
+<a name="boost_task.overview"></a><a class="link" href="index.html#boost_task.overview" title="Overview"> Overview</a>
+</h2></div></div></div>
+<p>
+      <span class="bold"><strong>Boost.Task</strong></span> provides a framework for parallel
+      execution of tasks (a task is a small unit of code that can be executed independently).
+    </p>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">task</span></code>, a <span class="emphasis"><em>callable</em></span> representing
+        a fine-grained work-item:
+        <div class="itemizedlist"><ul class="itemizedlist" type="circle">
+<li class="listitem">
+<code class="computeroutput"><span class="keyword">operator</span><span class="special">()()</span></code>
+            to execute the fine-grained work-item
+          </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">get_future</span><span class="special">()</span></code>
+            providing an <span class="emphasis"><em>asynchronous-completion-token</em></span> in order
+            to pass the result (values, exceptions) back to initiator
+          </li>
+</ul></div>
+</li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span></code>, works as a <span class="emphasis"><em>asynchronous-completion-token</em></span>
+        of executed task:
+        <div class="itemizedlist"><ul class="itemizedlist" type="circle">
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code>,
+            <code class="computeroutput"><span class="identifier">interrupt_and_wait</span><span class="special">()</span></code>,
+            ... allow to cancel an cooperative task
+          </li>
+<li class="listitem">
+            interface of the <span class="emphasis"><em>asynchronous-completion-token</em></span>:
+            <div class="itemizedlist"><ul class="itemizedlist" type="square">
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>
+                retrieve value or exception of task execution
+              </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">is_ready</span><span class="special">()</span></code>
+                test if task was executed
+              </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>,
+                <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code>
+                and <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code>
+                block until task is executed and the result is set
+              </li>
+</ul></div>
+</li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">get_future</span><span class="special">()</span></code>
+            returns reference to internal <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_future</span></code>
+</li>
+<li class="listitem">
+            functions <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">waitfor_all</span><span class="special">()</span></code>/<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">waitfor_any</span><span class="special">()</span></code>
+            to wait for all or any handles
+          </li>
+</ul></div>
+</li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">()</span></code>,
+        executes a task by means of <span class="emphasis"><em>execution-policies</em></span>
+</li>
+<li class="listitem">
+<span class="emphasis"><em>execution-policy</em></span> models:
+        <div class="itemizedlist"><ul class="itemizedlist" type="circle">
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">own_thread</span></code>: executes task in current
+            thread
+          </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">new_thread</span></code>: executes task in a newly-created
+            thread (thread will be destroyed after completion)
+          </li>
+<li class="listitem">
+<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">as_sub_task</span></code>: executes task in newly-created
+            thread or in a pool of <span class="emphasis"><em>worker-threads</em></span> depending
+            on whether the parent-task is already executed in a <span class="emphasis"><em>thread-pool</em></span>
+</li>
+<li class="listitem">
+<span class="emphasis"><em>thread-pool</em></span>: task gets executed by a <span class="emphasis"><em>worker-thread</em></span>
+            of a custom <span class="emphasis"><em>thread-pool</em></span> (for instance with priority
+            or smart scheduling)
+          </li>
+</ul></div>
+</li>
+<li class="listitem">
+<span class="emphasis"><em>thread-pools</em></span> with work-stealing algorithm and for/join
+        semantics
+      </li>
+<li class="listitem">
+        support of forking and joining sub-tasks
+        <div class="itemizedlist"><ul class="itemizedlist" type="circle">
+<li class="listitem">
+            better performance
+          </li>
+<li class="listitem">
+            no deadlock because of inline-execution of sub-tasks
+          </li>
+<li class="listitem">
+            detects if parent-task runs in a <span class="emphasis"><em>thread-pool</em></span> - the
+            appropriate mechanism for executing the sub-tasks is choosen
+          </li>
+</ul></div>
+</li>
+</ul></div>
+<p>
+      In order to use the classes and functions described here, you can either include
+      the specific headers specified by the descriptions of each class or function,
+      or include the master library header:
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">task</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
+</pre>
+<p>
+    </p>
+<p>
+      which includes all the other headers in turn.
+    </p>
+<p>
+      Used namespaces are:
+    </p>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span>
+<span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_task</span>
+</pre>
+<p>
+    </p>
+<a name="boost_task.overview.example"></a><h4>
+<a name="id638414"></a>
+      <a class="link" href="index.html#boost_task.overview.example">Example</a>
+    </h4>
+<p>
+      
+</p>
+<pre class="programlisting"><span class="keyword">long</span> <span class="identifier">fibonacci</span><span class="special">(</span> <span class="keyword">long</span> <span class="identifier">n</span><span class="special">)</span>
+<span class="special">{</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
+	<span class="keyword">if</span> <span class="special">(</span> <span class="identifier">n</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
+	<span class="keyword">long</span> <span class="identifier">k1</span><span class="special">(</span> <span class="number">1</span><span class="special">),</span> <span class="identifier">k2</span><span class="special">(</span> <span class="number">0</span><span class="special">);</span>
+	<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span><span class="special">(</span> <span class="number">2</span><span class="special">);</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">n</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
+	<span class="special">{</span>
+		<span class="keyword">long</span> <span class="identifier">tmp</span><span class="special">(</span> <span class="identifier">k1</span><span class="special">);</span>
+		<span class="identifier">k1</span> <span class="special">=</span> <span class="identifier">k1</span> <span class="special">+</span> <span class="identifier">k2</span><span class="special">;</span>
+		<span class="identifier">k2</span> <span class="special">=</span> <span class="identifier">tmp</span><span class="special">;</span>
+	<span class="special">}</span>
+	<span class="keyword">return</span> <span class="identifier">k1</span><span class="special">;</span>
+<span class="special">}</span>
+
+<span class="keyword">void</span> <span class="identifier">main</span><span class="special">()</span>
+<span class="special">{</span>
+	<span class="comment">// create a thread-pool
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">static_pool</span><span class="special">&lt;</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">fifo</span>
+		<span class="special">&gt;</span>
+	<span class="special">&gt;</span> <span class="identifier">pool</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">poolsize</span><span class="special">(</span> <span class="number">5</span><span class="special">)</span> <span class="special">);</span>
+
+	<span class="comment">// create two tasks, computing fibonacci numbers
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t1</span><span class="special">(</span> <span class="identifier">fibonacci</span><span class="special">,</span> <span class="number">10</span><span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">t2</span><span class="special">(</span> <span class="identifier">fibonacci</span><span class="special">,</span> <span class="number">5</span><span class="special">);</span>
+
+	<span class="comment">// execute tasks in thread-pool
+</span>	<span class="comment">// move tasks ownership to executor
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h1</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t1</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">);</span>
+	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">handle</span><span class="special">&lt;</span> <span class="keyword">long</span> <span class="special">&gt;</span> <span class="identifier">h2</span><span class="special">(</span>
+		<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span>
+			<span class="identifier">boost</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t2</span><span class="special">),</span>
+			<span class="identifier">pool</span><span class="special">);</span>
+
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"h1: is ready == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"h2: is ready == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+
+	<span class="comment">// wait for completion of both tasks
+</span>	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">task</span><span class="special">::</span><span class="identifier">waitfor_all</span><span class="special">(</span> <span class="identifier">h1</span><span class="special">,</span> <span class="identifier">h2</span><span class="special">);</span>
+
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"h1: is ready == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"h2: is ready == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"h1: has value == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"h2: has value == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"h1: has exception == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"h2: has exception == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">boolalpha</span> <span class="special">&lt;&lt;</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
+
+	<span class="comment">// get results
+</span>	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(10) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h1</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"fibonacci(5) == "</span> <span class="special">&lt;&lt;</span> <span class="identifier">h2</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
+<span class="special">}</span>
+</pre>
+<p>
+    </p>
+<a name="boost_task.overview.references"></a><h4>
+<a name="id640113"></a>
+      <a class="link" href="index.html#boost_task.overview.references">References</a>
+    </h4>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+        N2185: Proposed Text for Parallel Task Execution <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2185.html" target="_top">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2185.html</a>
+        written by Peter Dimov.
+      </li>
+<li class="listitem">
+        N2276: Thread Pools and Futures <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2276.html" target="_top">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2276.html</a>
+        written by Anthony Williams.
+      </li>
+<li class="listitem">
+        N2802: A plea to reconsider detach-on-destruction for thread objects <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html" target="_top">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html</a>
+        written by Hans-J. Boehm.
+      </li>
+<li class="listitem">
+        N2880: C++ object lifetime interactions with the threads API <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2880.html" target="_top">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2880.html</a>
+        written by Hans-J. Boehm and Lawrence Crowl.
+      </li>
+<li class="listitem">
+<a href="http://herbsutter.wordpress.com" target="_top">'Sutter&#8217;s Mill'</a> by
+        Herb Sutter
+      </li>
+<li class="listitem">
+        mailing list of C++ standard committee's Library Working Group
+      </li>
+</ul></div>
+<div class="note" title="Note"><table border="0" summary="Note">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../doc/html/images/note.png"></td>
+<th align="left">Note</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+        <span class="bold"><strong>Boost.Task</strong></span> uses <a href="http://www.justsoftwaresolutions.co.uk/threading/updated-implementation-of-c++-futures-3.html" target="_top"><span class="bold"><strong>Boost.Future</strong></span></a> from Anthony Williams (will be
+        integrated in some of the next releases of <a href="http://www.boost.org/libs/thread" target="_top"><span class="bold"><strong>Boost.Thread</strong></span></a>).
+      </p></td></tr>
+</table></div>
+<div class="note" title="Note"><table border="0" summary="Note">
+<tr>
+<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../doc/html/images/note.png"></td>
+<th align="left">Note</th>
+</tr>
+<tr><td align="left" valign="top"><p>
+        Please note that <span class="bold"><strong>Boost.Task</strong></span> is not optimized
+        yet.
+      </p></td></tr>
+</table></div>
+<a name="boost_task.overview.tested_platforms"></a><h4>
+<a name="id640225"></a>
+      <a class="link" href="index.html#boost_task.overview.tested_platforms">Tested Platforms</a>
+    </h4>
+<p>
+      <span class="bold"><strong>Boost.Task</strong></span> has been tested on the following
+      platforms and compilers:
+    </p>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+        Debian GNU/Linux 2.6.29.2 (x86_64), GCC 4.3.3
+      </li>
+<li class="listitem">
+        Ubuntu GNU/Linux 2.6.28.11 (x86), GCC 4.3.3
+      </li>
+<li class="listitem">
+        FreeBSD 7.2 (x86), GCC 4.2.1
+      </li>
+<li class="listitem">
+        OpenSolaris 2009.06 (x86_64), GCC 4.3.2
+      </li>
+<li class="listitem">
+        Windows XP Professional (x86), MSVC 9.0
+      </li>
+</ul></div>
+<a name="boost_task.overview.how_to_build_and_install"></a><h4>
+<a name="id640269"></a>
+      <a class="link" href="index.html#boost_task.overview.how_to_build_and_install">How to build and
+      install</a>
+    </h4>
+<div class="itemizedlist"><ul class="itemizedlist" type="disc">
+<li class="listitem">
+        download the sources form <a href="http://www.boost-consulting.com/vault/index.php?directory=Concurrent%20Programming" target="_top">Boost
+        Vault</a> or the latest development version from <a href="https://svn.boost.org/svn/boost/sandbox/task/" target="_top">boost-sandbox</a>
+</li>
+<li class="listitem">
+        extract the archive into the boost-source directory
+      </li>
+<li class="listitem">
+        call <span class="emphasis"><em>'bjam toolset=&lt;compiler-name&gt; --with-task install'</em></span>
+        in order to build and install <span class="bold"><strong>Boost.Task</strong></span>
+</li>
+</ul></div>
+</div>
+</div>
+<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
+<td align="left"><p><small>Last revised: June 23, 2009 at 18:15:43 GMT</small></p></td>
+<td align="right"><div class="copyright-footer"></div></td>
+</tr></table>
+<hr>
+<div class="spirit-nav"><a accesskey="n" href="boost_task/motivation.html"><img src="../../doc/html/images/next.png" alt="Next"></a></div>
+</body>
+</html>
diff -urN boost/libs/task/doc/html/minimal.css boost-altered/libs/task/doc/html/minimal.css
--- boost/libs/task/doc/html/minimal.css	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/minimal.css	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,29 @@
+/*
+
+   Copyright Beman Dawes, 2007
+
+  Distributed under the Boost Software License, Version 1.0.
+  See www.boost.org/LICENSE_1_0.txt
+  
+*/
+
+/*******************************************************************************
+      Body
+*******************************************************************************/
+
+body    { font-family: sans-serif; margin: 1em; }
+
+/*******************************************************************************
+      Table
+*******************************************************************************/
+
+table   { margin: 0.5em; }
+
+/*******************************************************************************
+      Font sizes
+*******************************************************************************/
+
+p, td, li, blockquote { font-size: 10pt; }
+pre     { font-size: 9pt; }
+
+/*** end ***/
\ No newline at end of file
diff -urN boost/libs/task/doc/html/reference.css boost-altered/libs/task/doc/html/reference.css
--- boost/libs/task/doc/html/reference.css	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/html/reference.css	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,11 @@
+/*============================================================================
+    Copyright 2003-2004 Douglas Gregor
+    Distributed under the Boost Software License, Version 1.0. (See accompany-
+    ing file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+============================================================================*/
+
+PRE.synopsis { 
+  background-color: #e0ffff;
+  border: thin solid blue;
+  padding: 1em
+}
\ No newline at end of file
diff -urN boost/libs/task/doc/introduction.qbk boost-altered/libs/task/doc/introduction.qbk
--- boost/libs/task/doc/introduction.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/introduction.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,186 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:motivation Motivation]
+
+To speed-up computer-bound work and/or increase the computation-throughput is a common motivation for parallelizing a program.
+Especially for interactive applications that have to process user input while performing some background tasks responsivness is
+very important.
+Parallelizing a program requires partitioning the program into smaller chunks that can run in parallel. The code can scale as the
+hardware gets better without changing the code.
+
+The evolution from one-core to many-core architectures and the usage of threads (of course processes fit too) support this paradigm.
+
+[note
+  ["You can have multithreading on a single core machine, but you can only have parallelism on a multi core machine ... .] -- Daniel Moth
+  [footnote more to read at Daniel's [@http://www.danielmoth.com/Blog/2008/11/threadingconcurrency-vs-parallelism.html blog]]
+]
+
+__boost_task__ provides a framework to utilize the available hardware and provide a way for efficient asynchronous processing of
+time consuming operations.
+The framework provides some __eps__, like __new_thread__, in order to execute the task asynchronously in another execution
+context (__boost_task__ uses preemptible threads for this purpose).
+
+``
+	void print( std::string const& msg)
+	{ printf("%s\n", msg.c_str() ); }
+
+	void main()
+	{
+		// task, to be executed asynchronously
+		boost::task::task< void > t( print, "Hello World!");
+
+		// execute task in newly-created thread
+		// move task ownership to executor
+		boost::task::async(
+			boost::move( t),
+			boost::task::new_thread() ) );
+	}
+``
+
+In order to manage the task __fn_async__ returns a __handle__ (associated with the submitted task). It functions as a __act__ -
+that means it transfers the result of the execution back to the caller thread.
+
+``
+	std::string echo( std::string const& msg)
+	{ return msg; }
+
+	void main()
+	{
+		// task returning the submitted string
+		boost::task::task< std::string > t( echo, "Hello World!");
+
+		// execute task in newly-created thread
+		// move task ownership to executor
+		boost::task::handle< std::string > h(
+			boost::task::async(
+				boost::move( t),
+				boost::task::new_thread() ) );
+
+		// wait until task has finished and return the result
+		std::cout << h.get() << std::endl;
+	}
+``
+
+The task can also be interrupted via __handle__ if it is a so-called [link_task __coop_task__].
+
+``
+	void long_running(  boost::posix_time::time_duration const& rel_time)
+	{ boost::this_thread::sleep( rel_time);
+
+	void main()
+	{
+		// create a long runing task
+		boost::task::task< void > t( long_running, boost::posix_time::millisec( 500) );
+
+		// execute task in newly-created thread
+		// move task ownership to executor
+		boost::task::handle< std::string > h(
+			boost::task::async(
+				boost::move( t),
+				boost::task::new_thread() ) );
+
+		// requests interruption of task
+		// returns immediately
+		h.interrupt();
+
+		// access the result
+		// task_interrupted exeception will be thrown
+		std::cout << h.get() << std::endl;		
+	}
+``
+
+Beside __new_thread__ (which creates a new task for each submitted task - the thread will be joined by __handle__) __boost_task__ provides [link_pool __thread_pools__]
+to prevent the overhead of thread creation and destruction of threads for each task (__thread_pools__ can be customized).
+
+``
+	long serial_fib( long n)
+	{
+		if( n < 2) return n;
+		else return serial_fib( n - 1) + serial_fib( n - 2);
+	}
+
+	long parallel_fib( long n, long cutof)
+	{
+		if ( n < cutof) return serial_fib( n);
+		else
+		{
+			// create a sub-task calculating fibonacci(n-1)
+			boost::task::task< long > t1(
+				parallel_fib,
+				n - 1,
+				cutof);
+			// create a sub-task calculating fibonacci(n-2)
+			boost::task::task< long > t2(
+				parallel_fib,
+				n - 2,
+				cutof);
+
+			// fork two sub-tasks
+			boost::task::handle< long > h1(
+				boost::task::async(
+					boost::move( t1),
+					boost::this_task::get_pool() ) );
+			boost::task::handle< long > h2(
+				boost::task::async(
+					boost::move( t2),
+					boost::this_task::get_pool() ) );
+
+			// join the results of both sub-tasks
+			return h1.get() + h2.get();
+		}
+	}
+
+	void main()
+	{
+		// create a thread-pool with five worker-threads
+		boost::task::static_pool<
+			boost::task::unbounded_channel<
+				boost::task::fifo
+			>
+		> pool( boost::task::poolsize( 5) );
+
+		// create task computing fibonacci-number for 10
+		boost::task::task< long > t(
+			parallel_fib,
+			10,
+			5);
+
+		// execute task in a thread-pool
+		// move task ownership to executor
+		boost::task::handle< long > h(
+			boost::task::async(
+				boost::move( t),
+				pool) );
+
+		// access the result
+		std::cout << "fibonacci(10) == " << h.get() << std::endl;
+	}
+``
+
+With function __fn_runs_in_pool__ a task can detect if it is executed inside a __thread_pool__.
+__sub_tasks__ arecreated by __as_sub_task__. Where the __sub_task__ is executed by a new thread if the parent task is not
+executed inside a __thread_pool__. In the other case the __sub_task__ is put into the local __worker_queue__ which enables
+[link_work_stealing __work_stealing__] and [link_forkjoin inline execution] of tasks.
+
+``
+	// create a long runing task
+	boost::task::task< long > t(
+		parallel_fib,
+		10,
+		5);
+
+	// move task ownership to executor
+	// sub-task executed in a new thread or inside the thread-pool
+	boost::task::async(
+		boost::move( t),
+		boost::task::as_sub_task() );
+``
+
+
+[endsect]
diff -urN boost/libs/task/doc/Jamfile.v2 boost-altered/libs/task/doc/Jamfile.v2
--- boost/libs/task/doc/Jamfile.v2	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/Jamfile.v2	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,12 @@
+# Boost.ThreadPool Library Documentation Jamfile
+
+# Copyright (C) 2008 Oliver Kowalke
+
+# Use, modification and distribution is subject to the Boost Software License, 
+# Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at 
+# http://www.boost.org/LICENSE_1_0.txt) 
+
+using quickbook ;
+
+xml task : boost_task.qbk ;
+boostbook standalone : task ;
diff -urN boost/libs/task/doc/meta_functions.qbk boost-altered/libs/task/doc/meta_functions.qbk
--- boost/libs/task/doc/meta_functions.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/meta_functions.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,33 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:meta_functions Meta functions]
+
+If the __thread_pool__ supports attributes (like priorities) __has_attribute__ evaluates to `true` at compile-time (derived from
+boost::mpl::bool_). The type of the attribute is determined by __attribute_type__.
+
+
+``
+	// thread-pool with priority scheduling
+	// type of priority is int
+	typdef boost::task::static_pool<
+		boost::task::unbounded_channel<
+			boost::task::priority< int >
+		>
+	> pool_type;
+
+	// test if thread-pool supports priorities at compile time
+	std::cout << std::boolalpha << boost::task::has_attribute< pool_type >::value << "\n";
+
+	// access the type used for priority
+	std::cout << typeid( boost::task::attribute_type< pool_type >::type).name() << std::endl;
+``
+
+
+[endsect]
+
diff -urN boost/libs/task/doc/new_thread.qbk boost-altered/libs/task/doc/new_thread.qbk
--- boost/libs/task/doc/new_thread.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/new_thread.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,70 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:new_thread Execute in new thread]
+
+__new_thread__ creates a new __thread__ and executes the task in this thread (asynchronous). The created thread gets joined by
+handle (so [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html N2802] should be addressed).
+The returned __handle__ joins the thread in its destructor (if the last reference gets out of scope) [/and thus provides one possible
+solution of [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2880.html N2880]].
+
+
+
+``
+	long fibonacci( long n)
+	{
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+		return k1;
+	}
+
+	void main()
+	{
+		boost::task::task< long > t( fibonacci, 10);
+
+		boost::task::handle< long > h(
+			boost::task::async(
+				boost::move( t),
+				boost::task::new_thread() ) );
+
+		std::cout << "fibonacci(10) == " << h.get() << std::endl;
+	}
+``
+
+[caution Always store the returned __act__ in a variable because __handle__ joins the thread in its destructor (if the last
+reference gets out of scope). ]
+
+
+In the example below both `a_function()` and `another_function()` are executed synchron because the returned __handle__ is not stored in
+a variable. Thatswhy the __worker_thread__ is joined after return from __fn_async__!
+
+``
+	boost::task::task< void > t1( a_function);
+	boost::task::task< void > t2( another_function);
+
+	// handles are not retrieved
+	// both task executed in sequence
+	boost::task::async(
+		boost::move( t1),
+		boost::task::new_thread() ) );
+	boost::task::async(
+		boost::move( t2),
+		boost::task::new_thread() ) );
+``
+
+
+[endsect] 
+ 
+ 
diff -urN boost/libs/task/doc/overview.qbk boost-altered/libs/task/doc/overview.qbk
--- boost/libs/task/doc/overview.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/overview.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,158 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:overview Overview]
+
+__boost_task__ provides a framework for parallel execution of tasks (a task is a small unit of code that can be executed independently).
+
+* __task__, a __callable__ representing a fine-grained work-item:
+	* __fn_operator__ to execute the fine-grained work-item
+	* __fn_get_future__ providing an __act__ in order to pass the result (values, exceptions) back to initiator
+
+* __handle__, works as a __act__ of executed task:
+	* __fn_interrupt__, __fn_interrupt_and_wait__, ... allow to cancel an cooperative task
+	* interface of the __act__:
+		* __fn_get__ retrieve value or exception of task execution
+		* __fn_is_ready__ test if task was executed
+		* __fn_wait__, __fn_wait_for__ and __fn_wait_until__ block until task is executed and the result is set
+	* __fn_get_future__ returns reference to internal __shared_future__
+	* functions __waitfor_all__/__waitfor_any__ to wait for all or any handles
+
+* __fn_async__, executes a task by means of __eps__
+
+* __ep__ models:
+	* __own_thread__: executes task in current thread
+	* __new_thread__: executes task in a newly-created thread (thread will be destroyed after completion)
+	* __as_sub_task__: executes task in newly-created thread or in a pool of __worker_threads__ depending on whether the parent-task is already executed in a __thread_pool__
+	* __thread_pool__: task gets executed by a __worker_thread__ of a custom __thread_pool__ (for instance with priority or smart scheduling)
+
+* __thread_pools__ with work-stealing algorithm and for/join semantics
+
+* support of forking and joining sub-tasks
+	* better performance
+	* no deadlock because of inline-execution of sub-tasks
+	* detects if parent-task runs in a __thread_pool__ - the appropriate mechanism for executing the sub-tasks is choosen
+
+
+In order to use the classes and functions described here, you can either include the specific headers specified by the descriptions of each class or function,
+or include the master library header:
+
+``
+    #include <boost/task.hpp>
+``
+
+which includes all the other headers in turn.
+
+Used namespaces are:
+
+``
+    namespace boost::task
+    namespace boost::this_task
+``
+
+
+[heading Example]
+
+``
+	long fibonacci( long n)
+	{
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+		return k1;
+	}
+
+	void main()
+	{
+		// create a thread-pool
+		boost::task::static_pool<
+			boost::task::unbounded_channel<
+				boost::task::fifo
+			>
+		> pool( boost::task::poolsize( 5) );
+
+		// create two tasks, computing fibonacci numbers
+		boost::task< long > t1( fibonacci, 10);
+		boost::task< long > t2( fibonacci, 5);
+
+		// execute tasks in thread-pool
+		// move tasks ownership to executor
+		boost::task::handle< long > h1(
+			boost::task::async(
+				boost::move( t1),
+				pool);
+		boost::task::handle< long > h2(
+			boost::task::async(
+				boost::move( t2),
+				pool);
+
+		std::cout << "h1: is ready == " << std::boolalpha << h1.is_ready() << "\n";
+		std::cout << "h2: is ready == " << std::boolalpha << h2.is_ready() << "\n";
+
+		// wait for completion of both tasks
+		boost::task::waitfor_all( h1, h2);
+
+		std::cout << "h1: is ready == " << std::boolalpha << h1.is_ready() << "\n";
+		std::cout << "h2: is ready == " << std::boolalpha << h2.is_ready() << "\n";
+		std::cout << "h1: has value == " << std::boolalpha << h1.has_value() << "\n";
+		std::cout << "h2: has value == " << std::boolalpha << h2.has_value() << "\n";
+		std::cout << "h1: has exception == " << std::boolalpha << h1.has_exception() << "\n";
+		std::cout << "h2: has exception == " << std::boolalpha << h2.has_exception() << "\n";
+
+		// get results
+		std::cout << "fibonacci(10) == " << h1.get() << std::endl;
+		std::cout << "fibonacci(5) == " << h2.get() << std::endl;
+	}
+``
+
+
+[heading References]
+
+* N2185: Proposed Text for Parallel Task Execution [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2185.html] written by Peter Dimov.
+
+* N2276: Thread Pools and Futures [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2276.html] written by Anthony Williams.
+
+* N2802: A plea to reconsider detach-on-destruction for thread objects [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html] written by Hans-J. Boehm.
+
+* N2880: C++ object lifetime interactions with the threads API [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2880.html] written by Hans-J. Boehm and Lawrence Crowl.
+
+* [@http://herbsutter.wordpress.com 'Sutters Mill'] by Herb Sutter
+
+* mailing list of C++ standard committee's Library Working Group
+
+[note __boost_task__ uses __boost_future__ from Anthony Williams (will be integrated in some of the next releases of __boost_thread__).]
+
+[note Please note that __boost_task__ is not optimized yet.]
+
+
+[heading Tested Platforms]
+
+__boost_task__ has been tested on the following platforms and compilers:
+
+*  Debian GNU/Linux 2.6.29.2 (x86_64), GCC 4.3.3
+*  Ubuntu GNU/Linux 2.6.28.11 (x86), GCC 4.3.3
+*  FreeBSD 7.2 (x86), GCC 4.2.1
+*  OpenSolaris 2009.06 (x86_64), GCC 4.3.2
+*  Windows XP Professional (x86), MSVC 9.0
+
+
+[heading How to build and install]
+
+* download the sources form [@http://www.boost-consulting.com/vault/index.php?directory=Concurrent%20Programming Boost Vault] or the latest
+development version from [@https://svn.boost.org/svn/boost/sandbox/task/ boost-sandbox]
+* extract the archive into the boost-source directory
+* call [''bjam toolset=<compiler-name> --with-task install'] in order to build and install __boost_task__
+
+
+[endsect]
diff -urN boost/libs/task/doc/own_thread.qbk boost-altered/libs/task/doc/own_thread.qbk
--- boost/libs/task/doc/own_thread.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/own_thread.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,42 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:own_thread Execute in own thread]
+
+__own_thread__ executes the task in the current thread (synchronous execution - concerns of [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html N2802] do not aply). 
+
+``
+	long fibonacci( long n)
+	{
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+		return k1;
+	}
+
+	void main()
+	{
+		boost::task::task< long > t( fibonacci, 10);
+
+		boost::task::handle< long > h(
+			boost::task::async(
+				boost::move( t),
+				boost::task::own_thread() ) );
+
+		std::cout << "fibonacci(10) == " << h.get() << std::endl;
+	}
+``
+
+[endsect] 
+ 
diff -urN boost/libs/task/doc/pool.qbk boost-altered/libs/task/doc/pool.qbk
--- boost/libs/task/doc/pool.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/pool.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,67 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:pool Thread-pool]
+
+Instead of creating a new thread and quickly throwing it away after the task is done, the overhead related to thread
+creation and destruction can be avoided by running the __work_items__ on a __thread_pool__ (reusing an existing
+__worker_thread__ instead).
+
+A __thread_pool__ maintains a queue (or queues) of __work_items__ to be done, and a pool of __worker_threads__ which execute __work_items__ from the queue(s).
+
+__boost_task__ provides __fn_async__ with support of executing an __task__ in __thread_pool__:
+
+
+``
+	std::string echo( std::string const& msg)
+	{ return msg; }
+
+	void main()
+	{
+		// create a thread-pool with
+		// five worker-threads
+		// FIFO schduling of queued tasks
+		// and unlimited size of internal queue
+		boost::task::static_pool<
+			boost::task::unbounded_channel<
+				boost::task::fifo
+			>
+		> pool( boost::task::poolsize( 5) );
+
+		// create task
+		boost::task::task< std::string > t( echo, "Hello World!");
+
+		// move task to executor
+		// let the task be executed by the thread-pool
+		boost::task::handle< std::string > h(
+			boost::task::async(
+				boost::move( t),
+				pool) );
+
+		// access the result
+		std::cout << h.get() << std::endl;
+	}
+``
+
+
+[important Tasks should not be too small (performance overhead dominates) and avoid blocking 
+tasks[footnote see [@http://www.ddj.com/go-parallel/article/showArticle.jhtml?articleID=216500409 
+'Use Thread Pools Correctly'], Herb Sutter].]
+
+
+[include static_pool.qbk]
+[include channel.qbk]
+[include scheduler.qbk]
+[include shutdown.qbk]
+[include processor_binding.qbk]
+[include work_stealing.qbk]
+[include fork_join.qbk]
+
+
+[endsect]
+
diff -urN boost/libs/task/doc/processor_binding.qbk boost-altered/libs/task/doc/processor_binding.qbk
--- boost/libs/task/doc/processor_binding.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/processor_binding.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,30 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:processor_binding Processor binding]
+
+For some applications it is convenient to bind the __worker_threads__ to processors/cores of the system. For this purpose __fn_bind_to_processors__ must
+be given to constructor instead __pool_size__ so that a __worker_thread__ is created an bound the the core.
+
+``
+	typedef boost::task::static_pool<
+		boost::task::unbounded_channel< boost::tp::fifo >
+	> pool_type;
+
+	// constructs thread-pool with worker-threads as
+	// CPUs/Cores are available on the system
+	pool_type pool( pool_type::bind_to_processors() );
+``
+
+The constructor takes additional arguments for the [link_work_stealing work-stealing algorithm] and [link_channel high-] and [link_channel low-watermark] too.
+
+[note __boost_task__ does provide this feature only for Windows, Linux, AIX, HP-UX, Solaris and FreeBSD.]
+
+
+[endsect]
+
diff -urN boost/libs/task/doc/rationale.qbk boost-altered/libs/task/doc/rationale.qbk
--- boost/libs/task/doc/rationale.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/rationale.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,24 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:rationale Appendix A: Rationale]
+
+* task : because future does not catch std::exceptions, boost::thread_interrupted, boost::exception
+         support of task-id
+
+* pool : work-stealing and pre-forking of threads, inline execution of local tasks; scheduling
+         default pool with worker-threads as cores
+
+* this-task : functions useable inside tasks
+
+* handle : async completion token, task interruption, association with task via task-id
+
+* async : from mailing-list, execution of task in current thread, new thread in pool
+
+
+[endsect]
diff -urN boost/libs/task/doc/ref_async.qbk boost-altered/libs/task/doc/ref_async.qbk
--- boost/libs/task/doc/ref_async.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_async.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,57 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:async Non-member function `async( task< R > &&, EP)`]
+
+``
+	#include <boost/task/async.hpp>
+
+	template< typename R, typename EP >
+	handle< R > async( task< R > && t, EP ep);
+``
+
+[variablelist
+[[Effects:] [moves task to an asyncrounous executer and returns a handle associated with the task]]
+[[Throws:] [`boost::thread_resource_error`]]
+]
+
+[endsect]
+
+
+[section:async1 Non-member function `async( task< R > &&, pool< Channel > &)`]
+
+``
+	#include <boost/task/async.hpp>
+
+	template< typename R, typename Channel >
+	handle< R > async( task< R > && t, pool< Channel > & ep);
+``
+
+[variablelist
+[[Effects:] [moves task into a thread-pool and returns a handle associated with the task]]
+[[Throws:] [`boost::task::task_rejected`]]
+]
+
+[endsect]
+
+
+[section:async2 Non-member function `async( task< R > &&, Attr, pool< Channel > &)`]
+
+``
+	#include <boost/task/async.hpp>
+
+	template< typename R, typename Channel, typename Attr >
+	handle< R > async( task< R > && t, Attr attr, pool< Channel > & ep);
+``
+
+[variablelist
+[[Effects:] [moves attributed task into a thread-pool and returns a handle associated with the task]]
+[[Throws:] [`boost::task::task_rejected`]]
+]
+
+[endsect]
diff -urN boost/libs/task/doc/reference.qbk boost-altered/libs/task/doc/reference.qbk
--- boost/libs/task/doc/reference.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/reference.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,25 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:reference Reference]
+
+[include ref_task.qbk]
+[include ref_handle.qbk]
+[include ref_async.qbk]
+[include ref_own_thread.qbk]
+[include ref_new_thread.qbk]
+[include ref_static_pool.qbk]
+[include ref_utility.qbk]
+[include ref_meta.qbk]
+[include ref_poolsize.qbk]
+[include ref_watermark.qbk]
+[include ref_scanns.qbk]
+[include ref_exceptions.qbk]
+
+
+[endsect]
diff -urN boost/libs/task/doc/ref_exceptions.qbk boost-altered/libs/task/doc/ref_exceptions.qbk
--- boost/libs/task/doc/ref_exceptions.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_exceptions.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,271 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:invalid_poolsize Class `invalid_poolsize`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class invalid_poolsize : public std::invalid_argument
+	{
+	public:
+		invalid_poolsize( std::string const& msg);
+	};
+``
+
+[heading Constructor]
+
+	invalid_poolsize( std::string const& msg);
+
+[variablelist
+[[Effects:] [constructs a `boost::task::invalid_poolsize` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:invalid_scanns Class `invalid_scanns`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class invalid_scanns : public std::invalid_argument
+	{
+	public:
+		invalid_scanns( std::string const& msg);
+	};
+``
+
+[heading Constructor]
+
+	invalid_scanns( std::string const& msg)
+
+[variablelist
+[[Effects:] [constructs a `boost::task::invalid_scanns` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:invalid_timeduration Class `invalid_timeduration`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class invalid_timeduration : public std::invalid_argument
+	{
+	public:
+		invalid_timeduration( std::string const& msg);
+	};
+``
+
+[heading Constructor]
+
+	invalid_timeduration( std::string const& msg)
+
+[variablelist
+[[Effects:] [constructs a `boost::task::invalid_timeduration` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:invalid_watermark Class `invalid_watermark`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class invalid_watermark : public std::invalid_argument
+	{
+	public:
+		invalid_watermark( std::string const& msg);
+	};
+``
+
+[heading Constructor]
+
+	invalid_watermark( std::string const& msg)
+
+[variablelist
+[[Effects:] [constructs a `boost::task::invalid_watermark` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:task_rejected Class `task_rejected`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class task_rejected : public std::runtime_error
+	{
+	public:
+		task_rejected( std::string const& msg);
+	};
+``
+
+[heading Constructor]
+
+	task_rejected( std::string const& msg)
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task_rejected` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:task_unitialized Class `task_unitialized`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class task_unitialized : public std::logic_error
+	{
+	public:
+		task_unitialized();
+	};
+``
+
+[heading Constructor]
+
+	task_unitialized()
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task_unitialized` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:task_already_executed Class `task_already_executed`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class task_already_executed : public std::logic_error
+	{
+	public:
+		task_already_executed();
+	};
+``
+
+[heading Constructor]
+
+	task_already_executed()
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task_already_executed` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:task_moved Class `task_moved`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class task_moved : public std::logic_error
+	{
+	public:
+		task_moved();
+	};
+``
+
+[heading Constructor]
+
+	task_moved()
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task_moved` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:broken_task Class `broken_task`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class broken_task : public std::logic_error
+	{
+	public:
+		broken_task();
+	};
+``
+
+[heading Constructor]
+
+	broken_task()
+
+[variablelist
+[[Effects:] [constructs a `boost::task::broken_task` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:task_interrupted Class `task_interrupted`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class task_interrupted : public std::runtime_error
+	{
+	public:
+		task_interrupted();
+	};
+``
+
+[heading Constructor]
+
+	task_interrupted()
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task_interrupted` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:pool_moved Class `pool_moved`]
+
+``
+	#include <boost/task/exceptions.hpp>
+
+	class pool_moved : public std::logic_error
+	{
+	public:
+		pool_moved();
+	};
+``
+
+[heading Constructor]
+
+	pool_moved()
+
+[variablelist
+[[Effects:] [constructs a `boost::task::pool_moved` instance]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
diff -urN boost/libs/task/doc/ref_handle.qbk boost-altered/libs/task/doc/ref_handle.qbk
--- boost/libs/task/doc/ref_handle.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_handle.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,255 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+[section:handle Class template `handle`]
+
+``
+	#include <boost/task/handle.hpp>
+
+	template< typename R >
+	class handle
+	{
+		handle();
+
+		void interrupt();
+		void interrupt_and_wait();
+		void interrupt_and_wait_until( system_time const& abs_time);
+		template< typename Duration >
+		void interrupt_and_wait_for( Duration const& rel_time);
+		bool interruption_requested();
+
+		R get();
+		bool is_ready() const;
+		bool has_value() const;
+		bool has_exception() const;
+		void wait() const;
+
+		shared_future< R > & get_future();
+
+		void swap( handle< R > & other);
+	};
+
+	template< typename Iterator >
+	friend void waitfor_all( Iterator begin, Iterator end);
+
+	template< typename T1, typename T2 >
+	friend void waitfor_all( T1 & t1, T2 & t2);
+	...
+	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
+	friend void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);
+
+	template< typename Iterator >
+	friend Iterator waitfor_any( Iterator begin, Iterator end);
+
+	template< typename T1, typename T2 >
+	friend unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2);
+	...
+	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
+	friend unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);
+``
+
+[heading Constructor]
+
+	handle()
+
+[variablelist
+[[Effects:] [constructs an empty (invalid) handle]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `interruption_requested()`]
+
+	bool interruption_requested()
+
+[variablelist
+[[Effects:] [checks if interruption is already requested]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `interrupt()`]
+
+	void interrupt()
+
+[variablelist
+[[Effects:] [requests task interruption; doesn not block (immediatly returns)]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `interrupt_and_wait()`]
+
+	void interrupt_and_wait()
+
+[variablelist
+[[Effects:] [requests task interruption and blocks until worker-thread stops task]]
+[[Throws:] [`boost::thread_resource_error`]]
+]
+
+
+[heading Member function `interrupt_and_wait_until()`]
+
+	bool interrupt_and_wait_until( system_time const& abs_time)
+
+[variablelist
+[[Effects:] [requests task interruption and blocks until worker-thread stops task or time-point elapsed]]
+[[Returns:] [false if the the time specified by abs_time was reached, true otherwise]]
+[[Throws:] [`boost::thread_resource_error`]]
+]
+
+
+[heading Member function `interrupt_and_wait_for()`]
+
+	template< typename Duration >
+	bool interrupt_and_wait_for( Duration const& rel_time)
+
+[variablelist
+[[Effects:] [requests task interruption and blocks until worker-thread stops task or time-duration elapsed]]
+[[Returns:] [false if the the time specified by rel_time was reached, true otherwise]]
+[[Throws:] [`boost::thread_resource_error`]]
+]
+
+
+[heading Member function `get()`]
+
+	R get()
+
+[variablelist
+[[Effects:] [requests the result]]
+[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_uninialized`, `boost::task::task_rejected`, `boost::task::broken_task`]]
+]
+
+
+[heading Member function `wait()`]
+
+	void wait()
+
+[variablelist
+[[Effects:] [blocks caller until task is done]]
+[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_uninialized`, `boost::task::task_rejected`, `boost::task::broken_task`]]
+]
+
+
+[heading Member function `wait_for()`]
+
+	template< typename Duration >
+	bool wait_for( Duration const& rel_time) const
+
+[variablelist
+[[Effects:] [blocks caller until task is done]]
+[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_uninialized`, `boost::task::task_rejected`, `boost::task::broken_task`]]
+]
+
+
+[heading Member function `wait_until()`]
+
+	bool wait_until( system_time const& abs_time) const
+
+[variablelist
+[[Effects:] [blocks caller until task is done]]
+[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_uninialized`, `boost::task::task_rejected`, `boost::task::broken_task`]]
+]
+
+
+[heading Member function `is_ready()`]
+
+	bool is_ready()
+
+[variablelist
+[[Effects:] [checks if task is done]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `has_value()`]
+
+	bool has_value()
+
+[variablelist
+[[Effects:] [checks if task is done and a result value is set]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `has_exception()`]
+
+	bool has_exception()
+
+[variablelist
+[[Effects:] [checks if task is done and an exception is set]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `get_future()`]
+
+	shared_future< R > & get_future()
+
+[variablelist
+[[Effects:] [returns a reference to the internal shared_future< R >]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `swap()`]
+
+	void swap( handle< R > & other)
+
+[variablelist
+[[Effects:] [swapps handle]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Non-member function `wait_for_all()`]
+
+	template< typename Iterator >
+	void waitfor_all( Iterator begin, Iterator end);
+
+	template< typename T1, typename T2 >
+	void waitfor_all( T1 & t1, T2 & t2);
+
+	template< typename T1, typename T2, typename T3 >
+	void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3);
+
+	template< typename T1, typename T2, typename T3, typename T4 >
+	void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4);
+
+	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
+	void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);
+
+[variablelist
+[[Effects:] [waits for all handles to become ready]]
+[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_rejected`]]
+]
+
+
+[heading Non-member function `wait_for_any()`]
+
+	template< typename Iterator >
+	Iterator waitfor_any( Iterator begin, Iterator end);
+
+	template< typename T1, typename T2 >
+	unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2);
+
+	template< typename T1, typename T2, typename T3 >
+	unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3);
+
+	template< typename T1, typename T2, typename T3, typename T4 >
+	unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4);
+
+	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
+	unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);
+
+[variablelist
+[[Effects:] [waits for any handle to become ready]]
+[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_rejected`, `std::bad_alloc`]]
+]
+
+
+[endsect]
diff -urN boost/libs/task/doc/ref_meta.qbk boost-altered/libs/task/doc/ref_meta.qbk
--- boost/libs/task/doc/ref_meta.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_meta.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,49 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:has_attribute Meta function `has_attribute`]
+
+``
+	#include <boost/task/meta.hpp>
+
+	template< typename Pool >
+	struct has_attribute : public mpl::bool_<
+		is_same<
+			detail::has_priority,
+			typename Pool::scheduler_type::priority_tag_type
+		>::value
+	>
+	{};
+``
+
+[variablelist
+[[Effects:] [returns true if Pool supports attributes (priority-scheduling)]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
+
+
+[section:attribute_type Meta function `attribute_type`]
+
+``
+	#include <boost/task/meta.hpp>
+
+	template< typename Pool >
+	struct attribute_type
+	{
+		typedef typename Pool::scheduler_type::attribute_type   type;
+	};
+``
+
+[variablelist
+[[Effects:] [returns type of attribute]]
+[[Throws:] [nothing]]
+]
+
+[endsect]
diff -urN boost/libs/task/doc/ref_new_thread.qbk boost-altered/libs/task/doc/ref_new_thread.qbk
--- boost/libs/task/doc/ref_new_thread.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_new_thread.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,32 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:new_thread Class `new_thread`]
+
+``
+	#include <boost/task/async.hpp>
+
+	struct new_thread
+	{
+		template< typename R >
+		handle< R > operator()( task< R > &&);
+	};
+``
+
+[heading Member function `operator()( task< R > &&)`]
+
+	template< typename R >
+	handle< R > operator()( task< R > && t)
+
+[variablelist
+[[Effects:] [moves task in a new thread an returns an handle associated with the task]]
+[[Throws:] [`boost::thread_resource_error`]]
+]
+
+
+[endsect]
\ No newline at end of file
diff -urN boost/libs/task/doc/ref_own_thread.qbk boost-altered/libs/task/doc/ref_own_thread.qbk
--- boost/libs/task/doc/ref_own_thread.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_own_thread.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,32 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:own_thread Class `own_thread`]
+
+``
+	#include <boost/task/async.hpp>
+
+	struct own_thread
+	{
+		template< typename R >
+		handle< R > operator()( task< R > && t);
+	};
+``
+
+[heading Member function `operator()( task< R > &&)`]
+
+	template< typename R >
+	handle< R > operator()( task< R > && t)
+
+[variablelist
+[[Effects:] [moves task in the current thread an returns an handle associated with the task]]
+[[Throws:] [Nothing]]
+]
+
+
+[endsect]
\ No newline at end of file
diff -urN boost/libs/task/doc/ref_poolsize.qbk boost-altered/libs/task/doc/ref_poolsize.qbk
--- boost/libs/task/doc/ref_poolsize.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_poolsize.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,45 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:poolsize Class `poolsize`]
+
+``
+	#include <boost/task/poolsize.hpp>
+
+	class poolsize
+	{
+	public:
+		explicit poolsize( std::size_t value);
+
+		operator std::size_t () const;
+	};
+``
+
+[heading Constructor]
+
+	explicit poolsize( std::size_t value)
+
+[variablelist
+[[Preconditions:][value > 0]]
+[[Effects:] [constructs a `boost::task::poolsize` instance]]
+[[Postconditions:][operator std::size_t () > 0]]
+[[Throws:] [`boost::task::invalid_poolsize`]]
+]
+
+
+[heading Member function `operator std::size_t()`]
+
+	operator std::size_t () const
+
+[variablelist
+[[Effects:] [returns the value]]
+[[Throws:] [Nothing]]
+]
+
+
+[endsect]
diff -urN boost/libs/task/doc/ref_scanns.qbk boost-altered/libs/task/doc/ref_scanns.qbk
--- boost/libs/task/doc/ref_scanns.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_scanns.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,45 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:scanns Class `scanns`]
+
+``
+	#include <boost/task/scanns.hpp>
+
+	class scanns
+	{
+	public:
+		explicit scanns( std::size_t value);
+
+		operator std::size_t () const;
+	};
+``
+
+[heading Constructor]
+
+	explicit scanns( std::size_t value)
+
+[variablelist
+[[Preconditions:][value > 0]]
+[[Effects:] [constructs a `boost::task::scanns` instance]]
+[[Postconditions:][operator std::size_t () > 0]]
+[[Throws:] [`boost::task::invalid_poolsize`]]
+]
+
+
+[heading Member function `operator std::size_t()`]
+
+	operator std::size_t () const
+
+[variablelist
+[[Effects:] [returns the value]]
+[[Throws:] [Nothing]]
+]
+
+
+[endsect]
diff -urN boost/libs/task/doc/ref_static_pool.qbk boost-altered/libs/task/doc/ref_static_pool.qbk
--- boost/libs/task/doc/ref_static_pool.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_static_pool.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,405 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:static_pool Class template `static_pool`]
+
+``
+	#include <boost/task/static_pool.hpp>
+
+	template< typename Channel >
+	class static_pool : private noncopyable
+	{
+	public:
+		static_pool();
+
+		explicit static_pool(
+			poolsize const& psize,
+			posix_time::time_duration const& asleep = posix_time::microseconds( 10),
+			scanns const& scns = scanns( 20) );
+
+		explicit static_pool(
+			poolsize const& psize,
+			high_watermark const& hwm,
+			low_watermark const& lwm,
+			posix_time::time_duration const& asleep = posix_time::milliseconds( 100),
+			scanns const& scns = scanns( 20) );
+
+		static_pool( static_pool &&);
+
+		static_pool & operator=( static_pool &&);
+
+# if defined(BOOST_HAS_PROCESSOR_BINDINGS)
+		explicit static_pool(
+			<<unspec-type>>,
+			posix_time::time_duration const& asleep = posix_time::microseconds( 10),
+			scanns const& scns = scanns( 20) );
+
+		explicit static_pool(
+			<<unspec-type>>,
+			high_watermark const& hwm,
+			low_watermark const& lwm,
+			posix_time::time_duration const& asleep = posix_time::milliseconds( 100),
+			scanns const& scns = scanns( 20) );
+			
+		static <<unspec-type>> bind_to_processors();
+# endif
+
+		~static_pool();
+
+		std::size_t size();
+		std::size_t active();
+		std::size_t idle();
+
+		void shutdown();
+		void shutdown_now();
+
+		void interrupt_all_worker();
+
+		bool closed();
+		void clear();
+		bool empty();
+		std::size_t pending();
+
+		const std::size_t upper_bound();
+		void upper_bound( high_watermark const& hwm);
+		const std::size_t lower_bound();
+		void lower_bound( low_watermark const& lwm);
+
+		template< typename R >
+		handle< R > submit( task< R > && t);
+
+		template< typename R, typename Attr >
+		handle< R > submit( task< R > && t, Attr const& attr);
+
+		void swap( static_pool & other);
+
+		operator unspecified_bool_type() const;
+		bool operator!() const;
+	};
+``
+
+[heading Default constructor]
+
+	static_pool()
+
+[variablelist
+[[Effects:] [constructs an unitialized pool]]
+[[Throws:] [nothing]]
+]
+
+
+[heading Constructor (unbounded channel)]
+
+	explicit static_pool(
+		<<unspec-type>>,
+		posix_time::time_duration const& asleep = posix_time::microseconds( 10),
+		scanns const& scns = scanns( 20) )
+
+[variablelist
+[[Preconditions:] [operating system provides functionality for processor binding]]
+[[Effects:] [constructs a pool - for each processor a worker-thread is created and bound to one processor - global-queue can queue an unlimited number of tasks]]
+[[Throws:] [`boost::thread_resource_error`, `boost::task::invalid_scanns`, `boost::task::invalid_timeduration`]]
+[[Notes:] [constructor has to be called if a unbounded-channel is used and `bind_to_processors()` must be set as first argument]]
+]
+
+
+[heading Constructor (unbounded channel/poolsize)]
+
+	explicit static_pool(
+		poolsize const& psize,
+		posix_time::time_duration const& asleep = posix_time::microseconds( 10),
+		scanns const& scns = scanns( 20) )
+
+[variablelist
+[[Effects:] [constructs a pool containing psize worker-threads - global-queue can queue an unlimited number of tasks]]
+[[Throws:] [`boost::thread_resource_error`, `boost::task::invalid_scanns`, `boost::task::invalid_timeduration`]]
+[[Notes:] [constructor has to be called if a unbounded-channel is used]]
+]
+
+
+[heading Constructor (bounded channel)]
+
+	explicit static_pool(
+		<<unspec-type>>,
+		high_watermark const& hwm,
+		low_watermark const& lwm,
+		posix_time::time_duration const& asleep = posix_time::milliseconds( 100),
+		scanns const& scns = scanns( 20) )
+
+[variablelist
+[[Preconditions:] [operating system provides functionality for processor binding]]
+[[Effects:] [constructs a pool - for each processor a worker-thread is created and bound to one processor - global-queue can only queue a limited number of tasks]]
+[[Throws:] [`boost::thread_resource_error`, `boost::task::invalid_scanns`, `boost::task::invalid_timeduration`, `boost::task::invalid_watermark`]]
+[[Notes:] [constructor has to be called if a bounded-channel is used and `bind_to_processors()` must be set as first argument]]
+]
+
+
+[heading Constructor (bounded channel/poolsize)]
+
+	explicit static_pool(
+		poolsize const& psize,
+		high_watermark const& hwm,
+		low_watermark const& lwm,
+		posix_time::time_duration const& asleep = posix_time::milliseconds( 100),
+		scanns const& scns = scanns( 20) )
+
+[variablelist
+[[Effects:] [constructs a pool containing psize worker-threads - global-queue can only queue a limited number of tasks]]
+[[Throws:] [`boost::thread_resource_error`, `boost::task::invalid_scanns`, `boost::task::invalid_timeduration`, `boost::task::invalid_watermark`]]
+[[Notes:] [constructor has to be called if a bounded-channel is used]]
+]
+
+
+[heading Move-copy constructor]
+
+	static_pool( static_pool &&)
+
+[variablelist
+[[Effects:] [creates an pool out of another one which gets zeroed out]]
+[[Throws:] [nothing]]
+]
+
+
+[heading Move-assigment constructor]
+
+	static_pool & operator=( static_pool &&)
+
+[variablelist
+[[Effects:] [creates an pool out of another one which gets zeroed out]]
+[[Throws:] [nothing]]
+]
+
+
+[heading Destructor]
+
+	~static_pool()
+
+[variablelist
+[[Effects:] [calls `shutdown()` if not already called]]
+[[Throws:] [nothing]]
+]
+
+
+[heading Static member function `bind_to_processors()`]
+
+	<<unspec-type>> bind_to_processors()
+
+[variablelist
+[[Effects:] [used in order to let the pool create worker-threads as cores are available and bound the threads to the cores]]
+[[Throws:] [nothing]]
+]
+
+
+[heading Member function `size()`]
+
+	std::size_t size()
+
+[variablelist
+[[Effects:] [returns how many worker-threads are running in the pool]]
+[[Throws:] [`boost::task::pool_moved`]]
+]
+
+
+[heading Member function `active()`]
+
+	std::size_t active()
+
+[variablelist
+[[Effects:] [returns how many worker-threads are active (executing an task)]]
+[[Throws:] [`boost::task::pool_moved`]]
+]
+
+
+[heading Member function `idle()`]
+
+	std::size_t idle()
+
+[variablelist
+[[Effects:] [returns how many worker-threads are idle (not executing an task).]]
+[[Throws:] [`boost::task::pool_moved`]]
+[[Notes:] [the value is the difference of `size()` and `active()`]]
+]
+
+
+[heading Member function `shutdown()`]
+
+	void shutdown()
+
+[variablelist
+[[Effects:] [deactivates the channel and joins all worker-threads - the pool is closed]]
+[[Throws:] [`boost::thread_interrupted`, `boost::system::system_error`, `boost::task::pool_moved`]]
+[[Notes:] [all pending tasks are processed]]
+]
+
+
+[heading Member function `shutdown_now()`]
+
+	void shutdown_now()
+
+[variablelist
+[[Effects:] [deactivates the channel, send interruption request to all worker-threads and joins them - the pool is closed]]
+[[Throws:] [`boost::thread_interrupted`, `boost::system::system_error`, `boost::task::pool_moved`]]
+[[Notes:] [pending tasks are not processed but returned]]
+]
+
+
+[heading Member function `interrupt_all_worker()`]
+
+	void interrupt_all_worker()
+
+[variablelist
+[[Effects:] [interrupts all worker-threads without invalidating the pool]]
+[[Throws:] [nothing]]
+]
+
+
+[heading Member function `closed()`]
+
+	bool closed()
+
+[variablelist
+[[Effects:] [queries if the pool is closed (pool is shutdown)]]
+[[Throws:] [`boost::task::pool_moved`]]
+]
+
+
+[heading Member function `clear()`]
+
+	void clear()
+
+[variablelist
+[[Effects:] [removes all pending tasks from the channel]]
+[[Throws:] [`boost::task::pool_moved`]]
+]
+
+
+[heading Member function `empty()`]
+
+	bool empty()
+
+[variablelist
+[[Effects:] [queries if the channel is empty]]
+[[Throws:] [`boost::task::pool_moved`]]
+]
+
+
+[heading Member function `pending()`]
+
+	std::size_t pending()
+
+[variablelist
+[[Effects:] [queries how many tasks are pending (still unprocessed) in the global-queue (channel)]]
+[[Throws:] [`boost::task::pool_moved`]]
+]
+
+
+[heading Member function `upper_bound()`]
+
+	std::size_t upper_bound()
+
+[variablelist
+[[Preconditions:] [channel is of type bounded-channel]]
+[[Effects:] [returns the upper bound of the bounded-channel]]
+[[Throws:] [`boost::task::pool_moved`]]
+[[Notes:] [can only be used if a bounded-channel is used]]
+]
+
+
+[heading Member function `upper_bound( high_watermark const& hwm)`]
+
+	void upper_bound( high_watermark const& hwm)
+
+[variablelist
+[[Preconditions:] [channel is of type bounded-channel]]
+[[Effects:] [sets the upper bound of the bounded-channel]]
+[[Postconditions:] [`this->upper_bound() == hwm`]]
+[[Throws:] [`boost::task::invalid_watermark`, `boost::task::pool_moved`]]
+[[Notes:] [can only be used if a bounded-channel is used]]
+]
+
+
+[heading Member function `lower_bound()`]
+
+	std::size_t lower_bound();
+
+[variablelist
+[[Preconditions:] [channel is of type bounded-channel]]
+[[Effects:] [returns the lower bound of the bounded-channel]]
+[[Throws:] [`boost::task::pool_moved`]]
+[[Notes:] [can only be used if a bounded-channel is used]]
+]
+
+
+[heading Member function `lower_bound( low_watermark const& lwm)`]
+
+	void lower_bound( low_watermark const& lwm)
+
+[variablelist
+[[Preconditions:] [channel is of type bounded-channel]]
+[[Effects:] [sets the lower bound of the bounded-channel]]
+[[Postconditions:] [`this->lower_bound() == lwm`]]
+[[Throws:] [`boost::task::invalid_watermark`, `boost::task::pool_moved`]]
+[[Notes:] [can only be used if a bounded-channel is used]]
+]
+
+
+[heading Member function `submit( task< R > &&)`]
+
+	template< typename R >
+	handle< R > submit( task< R > && t)
+
+[variablelist
+[[Preconditions:] [has_attribute< pool >::value == false && ! closed()]]
+[[Effects:] [moves an task to the pool and returns an associated handle]]
+[[Throws:] [`boost::task::task_rejected`, `boost::task::pool_moved`]]
+]
+
+
+[heading Member function `submit( task< R > &&, Attr const& attr)`]
+
+	template< typename R, typename Attr >
+	handle< R > submit( task< R > && t, Attr const& attr)
+
+[variablelist
+[[Preconditions:] [has_attribute< pool >::value == true && ! closed()]]
+[[Effects:] [moves an task to the pool and returns an associated handle - task is scheduled by the attribute]]
+[[Throws:] [`boost::task::task_rejected`, `boost::task::pool_moved`]]
+]
+
+
+[heading Member function swap( static_pool &)`]
+
+	void swap( static_pool & other)
+
+[variablelist
+[[Effects:] [swaps pool]]
+[[Throws:] [nothing]]
+]
+
+
+[heading operator `operator unspecified_bool_type()`]
+
+	operator unspecified_bool_type() const
+
+[variablelist
+[[Effects:] [is static_pool valid == does static_pool own ownership]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading operator `operator!()`]
+
+	bool operator!() const
+
+[variablelist
+[[Effects:] [is static_pool invalid == static_pool does not have ownership]]
+[[Throws:] [Nothing]]
+]
+
+
+[endsect]
diff -urN boost/libs/task/doc/ref_task.qbk boost-altered/libs/task/doc/ref_task.qbk
--- boost/libs/task/doc/ref_task.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_task.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,184 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+[section:task Class template `task`]
+
+``
+	#include <boost/task/task.hpp>
+
+	template< typename R >
+	class task : private noncopyable
+	{
+	public:
+		task();
+
+		task( R( * fn)());
+
+		template< typename Fn >
+		task( Fn fn);
+
+		template< typename Fn, typename A0 >
+		task( Fn fn, A0 a0);
+		...
+		template< typename Fn, typename A0, ..., typename A9 >
+		task( Fn fn, A0 a0, ..., A9 a9);
+
+		task( task && t);
+		task & operator=( task && t);
+		task && move();
+
+		shared_future< R > & get_future();
+
+		void operator()();
+
+		template< typename Cb >
+		void set_wait_callback( Cb const& cb);
+
+		void swap( task< R > & other);
+
+		operator unspecified_bool_type() const;
+		bool operator!() const;
+	};
+``
+
+[heading Default constructor]
+
+	task()
+
+[variablelist
+[[Effects:] [constructs an unitialized `boost::task::task< R >`]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Constructor (function pointer)]
+
+	task( R( * fn)());
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task< R >` from a function pointer]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Constructor (functor)]
+
+	template< typename Fn >
+	task( Fn const& fn)
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task< R >` from a function object]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Constructor (functor with arguments)]
+
+	template< typename Fn, typename A0 >
+	task( Fn fn, A0 a0);
+	...
+	template< typename Fn, typename A0, ..., typename A9 >
+	task( Fn fn, A0 a0, ..., A9 a9);
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task< R >` from a function object and its arguments]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Move-copy constructor]
+
+	task( task &&)
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task< R >` from another task taking over the ownership]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Move-assignment operator]
+
+	task & operator=( task &&)
+
+[variablelist
+[[Effects:] [constructs a `boost::task::task< R >` from another task taking over the ownership]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `move()`]
+
+	task && move()
+
+[variablelist
+[[Effects:] [moves task releasing the ownership]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `get_future()`]
+
+	shared_future< R > & get_future()
+
+[variablelist
+[[Effects:] [returns a future assiciated with the task]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `operator()()`]
+
+	void operator()()
+
+[variablelist
+[[Effects:] [executes task's internal function object]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member template-function `set_wait_callback( Cb cons&)`]
+
+	template< typename Cb >
+	void set_wait_callback( Cb const cb&);
+
+[variablelist
+[[Effects:] [stores callback function object which will be called if task would block]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading Member function `swap( task< R > &)`]
+
+	void swap( task< R > & other)
+
+[variablelist
+[[Effects:] [swaps the task]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading operator `operator unspecified_bool_type()`]
+
+	operator unspecified_bool_type() const
+
+[variablelist
+[[Effects:] [is task valid == does task own ownership]]
+[[Throws:] [Nothing]]
+]
+
+
+[heading operator `operator!()`]
+
+	bool operator!() const
+
+[variablelist
+[[Effects:] [is task invalid == task does not have ownership]]
+[[Throws:] [Nothing]]
+]
+
+
+[endsect]
diff -urN boost/libs/task/doc/ref_utility.qbk boost-altered/libs/task/doc/ref_utility.qbk
--- boost/libs/task/doc/ref_utility.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_utility.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,131 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:reschedule_until Non-member function `reschedule_until()`]
+
+``
+	#include <boost/task/utility.hpp>
+
+	template< typename Pred >
+	void reschedule_until( Pred const&)
+``
+
+[variablelist
+[[Effects:] [reschedules current task until passed callable predicate becomes ready]]
+[[Throws:] [`boost::thread_interrupted`,`boost::system::system_error`]]
+[[Note:] [this function resides in namespace `boost::this_task`]]
+]
+
+[endsect]
+
+
+[section:get_pool Non-member function `get_pool()`]
+
+``
+	#include <boost/task/utility.hpp>
+
+	template< typename Pool >
+	Pool & get_pool()
+``
+
+[variablelist
+[[Effects:] [returns reference to the thread-pool where the current worker thread is executed]]
+[[Throws:] [nothing]]
+[[Note:] [this function resides in namespace `boost::this_task`]]
+]
+
+[endsect]
+
+
+[section:runs_in_pool Non-member function `runs_in_pool()`]
+
+``
+	#include <boost/task/utility.hpp>
+
+	bool runs_in_pool()
+``
+
+[variablelist
+[[Effects:] [returns true if the current task is executed in a thread-pool]]
+[[Throws:] [nothing]]
+[[Note:] [this function resides in namespace `boost::this_task`]]
+]
+
+[endsect]
+
+
+[section:worker_id Non-member function `worker_id()`]
+
+``
+	#include <boost/task/utility.hpp>
+
+	id worker_id()
+``
+
+[variablelist
+[[Effects:] [returns returns the thread-id of the worker-thread]]
+[[Throws:] [nothing]]
+[[Note:] [this function resides in namespace `boost::this_task`]]
+]
+
+[endsect]
+
+
+[section:delay Non-member function `delay()`]
+
+``
+	#include <boost/task/utility.hpp>
+
+	void delay( system_time abs_time)
+
+	template< typename Duration >
+	void delay( Duration const& rel_time)
+``
+
+[variablelist
+[[Effects:] [delays the execution of the current task so that the worker-thread can process another task in the meantime]]
+[[Throws:] [nothing]]
+[[Note:] [this function resides in namespace `boost::this_task`]]
+]
+
+[endsect]
+
+
+[section:yield Non-member function `yield()`]
+
+``
+	#include <boost/task/utility.hpp>
+
+	void yield()
+``
+
+[variablelist
+[[Effects:] [yields the current task so that the worker-threadcan process another task in the meantime]]
+[[Throws:] [nothing]]
+[[Note:] [this function resides in namespace `boost::this_task`]]
+]
+
+[endsect]
+
+
+[section:interrupt Non-member function `interrupt()`]
+
+``
+	#include <boost/task/utility.hpp>
+
+	void interrupt()
+``
+
+[variablelist
+[[Effects:] [task can request interruption for itself]]
+[[Throws:] [nothing]]
+[[Note:] [this function resides in namespace `boost::this_task`]]
+]
+
+[endsect]
+
diff -urN boost/libs/task/doc/ref_watermark.qbk boost-altered/libs/task/doc/ref_watermark.qbk
--- boost/libs/task/doc/ref_watermark.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/ref_watermark.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,79 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:high_watermark Class `high_watermark`]
+
+``
+	#include <boost/task/watermark.hpp>
+
+	class high_watermark
+	{
+	public:
+		explicit high_watermark( std::size_t value);
+
+		operator std::size_t () const;
+	};
+``
+
+[heading Constructor]
+
+	explicit high_watermark( std::size_t value)
+
+[variablelist
+[[Effects:] [constructs a `boost::tp::high_watermark` instance]]
+[[Throws:] [`boost::task::invalid_watermark`]]
+]
+
+
+[heading Member function `operator std::size_t()`]
+
+	operator std::size_t () const
+
+[variablelist
+[[Effects:] [returns high watermark]]
+[[Throws:] [Nothing]]
+]
+
+[endsect]
+
+
+[section:low_watermark Class `low_watermark`]
+
+``
+	#include <boost/task/watermark.hpp>
+
+	class low_watermark
+	{
+	public:
+		explicit low_watermark( std::size_t value);
+
+		operator std::size_t () const;
+	};
+``
+
+[heading Constructor]
+
+	explicit low_watermark( std::size_t value)
+
+[variablelist
+[[Effects:] [constructs a `boost::task::low_watermark` instance]]
+[[Throws:] [`boost::task::invalid_watermark`]]
+]
+
+
+[heading Member function `operator std::size_t()`]
+
+	operator std::size_t () const
+
+[variablelist
+[[Effects:] [returns low watermark]]
+[[Throws:] [Nothing]]
+]
+
+
+[endsect]
\ No newline at end of file
diff -urN boost/libs/task/doc/scheduler.qbk boost-altered/libs/task/doc/scheduler.qbk
--- boost/libs/task/doc/scheduler.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/scheduler.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,125 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:scheduling Scheduling]
+
+The scheduling policy determines how tasks are scheduled inside the __channel__.
+
+
+[heading fifo]
+
+First inserted pending __task__ gets taken first.
+
+
+[heading priority]
+
+Each __task__ is submitted to the pool with a priority attribute. The type and ordering of the priority is user-defined.
+
+``
+	// thread-pool with priority scheduling
+	// tasks with higher priority are
+	// scheduled first
+	boost::task::static_pool<
+		boost::task::unbounded_channel<
+			boost::task::priority< int > >
+	> pool( boost::task::poolsize( 5) );
+
+	boost::task::task< void > t1( some_fn);
+	boost::task::task< void > t2( another_fn);
+
+	// move task t1 with priority 5 to thread-pool
+	boost::task::async(
+		boost::move( t1),
+		5,
+		pool);
+
+	// move task t2 with priority 3 to thread-pool
+	boost::task::async(
+		boost::move( t2),
+		3,
+		pool);
+``
+
+In this example the tasks get scheduled by the assigned integer (third argument of __fn_async__). The __task__ with the
+lowest priority gets scheduled first (taken by a __worker_thread__). The ordering can be changed by the second argument
+of __priority__ (the default is `std::greater< Attr >`).
+
+``
+	// thread-pool with priority scheduling
+	// tasks with lower priority are
+	// scheduled first
+	boost::task::static_pool<
+		boost::task::unbounded_channel<
+			boost::task::priority< int, std::less< int > >
+		>
+	> pool( boost::task::poolsize( 5) );
+``
+
+
+[heading smart]
+
+Each inserted __task__ is associated with an attribute. The scheduler gets an put- and take-policy as template arguments.
+The corresponding policy gets applied for each insertion and removal.
+
+__boost_task__ provides __replace_oldest__ as put- policy and __take_oldest__ as take-policy. Both policies allow the
+replacement of older (pending) tasks in the scheduler by new ones.
+
+``
+	long fibonacci_fn( long n)
+	{
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+		return k1;
+	}
+
+	typedef boost::task::static_pool<
+		boost::task::unbounded_channel<
+			boost::task::smart<
+				int,
+				std::less< int >,
+				boost::task::replace_oldest,
+				boost::task::take_oldest
+			>
+		>
+	> pool_type;
+
+	void main()
+	{
+		pool_type pool( boost::task::poolsize( 1) );
+
+		...
+
+		boost::task::task< long > t1(
+			boost::bind( fibonacci_fn, 10) );
+		boost::task::task< long > t2(
+			boost::bind( fibonacci_fn, 5) );
+
+		// replaced by later task with same attribute == 2
+		// if still pending in pool
+		boost::task::async(
+			boost::move( t1),
+			2,
+			pool);
+
+		// will replace previous pending task with attribute == 2
+		boost::task::async(
+			boost::move( t2),
+			2,
+			pool);
+	}
+``
+
+
+[endsect]
diff -urN boost/libs/task/doc/shutdown.qbk boost-altered/libs/task/doc/shutdown.qbk
--- boost/libs/task/doc/shutdown.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/shutdown.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,127 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:pool_shutdown Pool shutdown]
+
+__boost_task__ allows to shutdown a __thread_pool__ explicitly via functions __fn_shutdown__ and __fn_shutdown_now__. The
+destructor of the pool calls __fn_shutdown__ if not already done so that all __worker_threads__ are joined and the topic of 
+[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html N2802] should be addressed.
+
+[heading Shutdown]
+
+If __fn_shutdown__ is called - the the pool is set the closed state and all __worker_threads__ are joined until all pending tasks are processed.
+No futher tasks can be submitted.
+
+
+``
+	long fibonacci_fn( long n)
+	{
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+		return k1;
+	}
+
+	typedef boost::task::static_pool<
+		boost::task::unbounded_channel<
+			boost::task::fifo
+		>
+	> pool_type;
+
+	void main()
+	{
+		pool_type pool( boost::task::poolsize( 1) );
+
+		...
+
+		boost::task::task< long > t1( fibonacci_fn, 10);
+		boost::task::task< long > t2( fibonacci_fn, 5);
+
+		boost::task::handle< long > h1(
+			boost::task::async(
+				boost::move( t1),
+				pool) );
+		boost::task::handle< long > h2(
+			boost::task::async(
+				boost::move( t2),
+				pool) );
+
+		// waits until all pending tasks are finished
+		pool.shutdown();
+
+		std::cout << "fibonacci(10) == " << h1.get() << "\n";
+		std::cout << "fibonacci(5) == " << h2.get() << std::endl;
+	}
+``
+
+[note The deconstructor calls __fn_shutdown__ if the pool was not shutdown yet.]
+
+
+[heading Shutdown immediatly]
+
+The function __fn_shutdown_now__ closes the pool, interrupts and then joins all __worker_threads__. Pending tasks are unprocessed.
+
+
+``
+	long fibonacci_fn( long n)
+	{
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+		return k1;
+	}
+
+	typedef boost::task::static_pool<
+		boost::task::unbounded_channel<
+			boost::task::fifo
+		>
+	> pool_type;
+
+	void main()
+	{
+		pool_type pool( boost::task::poolsize( 1) );
+
+		...
+
+		boost::task::task< long > t1( fibonacci_fn, 10);
+		boost::task::task< long > t2( fibonacci_fn, 5);
+
+		boost::task::handle< long > h1(
+			boost::task::async(
+				boost::move( t1),
+				pool) );
+		boost::task::handle< long > h2(
+			boost::task::async(
+				boost::move( t2),
+				pool) );
+
+		// requests task interruption and
+		// joins all worker-threads
+		pool.shutdown_now();
+
+		// accessing the result may throw task_interrupted
+		std::cout << "fibonacci(10) == " << h1.get() << "\n";
+		std::cout << "fibonacci(5) == " << h2.get() << std::endl;
+	}
+``
+
+
+[endsect]
+
diff -urN boost/libs/task/doc/static_pool.qbk boost-altered/libs/task/doc/static_pool.qbk
--- boost/libs/task/doc/static_pool.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/static_pool.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,43 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:static_pool Static thread-pool]
+
+__boost_task__ provides __static_pool__ - which contains an fixed set of pre-forked __worker_threads__ (the size of the pool doesn't change during its lifetime).
+__static_pool__ supports move semantics.
+
+
+``
+        boost::task::_static_pool<               // pool type
+                boost::task::unbounded_channel<  // queuing policy (unbounded_channel, bounded_channel)
+                       boost::task::fifo        // scheduling policy (fifo, priority, smart)
+                >
+        > pool(
+                boost::task::poolsize( 6),                         // pool with 6 pre-forked worker-threads
+                boost::posix_time::posix_time::milliseconds( 50),  // time to sleep if no work-item available
+                boost::task::scanns( 10) );                        // iterations over local-queues before sleep
+``
+
+
+The first argument of the constructor specifies how many __worker_threads__ the pool will contain. The second
+and third argument are used by the [link_work_stealing __work_stealing__] algorithm.
+
+[note If __bounded_channel__ is used as queuing policy the constructor has two additional arguments . ]
+
+__static_pool__ provides functionality to check the status of the pool - __fn_closed__ returns true when the pool was
+shutdown and __fn_active__ as well as __fn_idle__ returning how many __worker_threads__ are active (executing a task) or idle.
+The size of the pool can be accessed over __fn_size__.
+
+For informational pruposes __fn_empty__ and __fn_pending__ can be used in order to know if the global task-queue is empty or
+how many tasks are waiting for execution. With __fn_clear__ all tasks are removed from the global-queue.
+
+[note __fn_pending__ does not count tasks in the local-queues of the __worker_threads__.]
+
+
+[endsect]
+
diff -urN boost/libs/task/doc/task.qbk boost-altered/libs/task/doc/task.qbk
--- boost/libs/task/doc/task.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/task.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,258 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:task Task]
+
+A task is a chunk of code that can be executed independently.
+
+__task__ represents a __callable__ (provides __fn_operator__) object containing the unit of code to be execute by a __ep__.
+Function __fn_get_future__ returns a __act__ allowing to wait for the completion of the computation of the task, for
+getting the result of a computation or for transfering exceptions. __task__ supports move semantics (moving ownership).
+
+[/
+[heading Creation]
+
+__tasks__ are created by passing free-functions or member-functions of objects and its arguments to the task-constructor.
+
+* create task from free-function with arguments:
+
+``
+	boost::task::task< int > t( parallel_fib, 10);
+``
+
+* create task from member-function with arguments:
+
+``
+	struct X
+	{
+		void f( int i);
+	};
+
+	X x;
+	boost::task::task< int > t(
+		& X::f,
+		x,
+		10);
+``
+
+It is possible to create __task__ from a __callable__ too:
+
+``
+	struct Y
+	{
+		std::string operator()();
+	};
+    
+	Y y;
+	boost::task::task< std::string > t( y);
+``
+]
+
+[heading Cooperative task and interruption]
+
+Sometimes it is desired to stop a running task if it is no longer needed. In this case the thread is not killed - it stops
+only at well-defined points (__interruption_points__) its execution.
+In the context of task-interruption a task is known as cooperative if it checks for an interruption request between two
+__interruption_points__ via __fn_interruption_requested__ [footnote see [@http://www.ddj.com/architect/207100682
+'Interrupt Politely'], Herb Sutter].
+
+__interruption_points__ are:
+
+* `boost::thread::join()`
+* `boost::thread::timed_join()`
+* `boost::condition_variable::wait()`
+* `boost::condition_variable::timed_wait()`
+* `boost::condition_variable_any::wait()`
+* `boost::condition_variable_any::timed_wait()`
+* `boost::thread::sleep()`
+* `boost::this_thread::sleep()`
+* `boost::this_thread::interruption_point()`
+
+A __interruption_point__ throws __task_interrupted__ if an interruption was requested.
+
+``
+	long cooperative( long n)
+	{
+		// interruption point
+		boost::this_thread::interruption_point();
+		
+		if ( n == 0) return 0;
+		if ( n == 1) return 1;
+		long k1( 1), k2( 0);
+		for ( int i( 2); i <= n; ++i)
+		{
+			// check if interruption was requested
+			if ( boost::this_thread::interruption_requested() )
+				return;
+				
+			long tmp( k1);
+			k1 = k1 + k2;
+			k2 = tmp;
+		}
+		
+		// interruption point
+		boost::this_thread::interruption_point();
+		
+		return k1;
+	}
+
+	void main()
+	{
+		// task for computing fibonacci-number
+		boost::task::task< long > t( cooperative, 10) );
+
+		// execute task in new thread
+		// move task ownership to executor
+		boost::task::handle< long > h(
+			boost::task::async(
+				boost::move( t),
+				boost::task::new_thread() ) );
+
+		// interrupt task an wait until
+		// the task is removed by the worker-thread
+		h.interrupt_and_wait();
+
+		// access the result
+		// throws boost::task::task_interrupted
+		std::cout << "fibonacci(10) == " << h.get() << std::endl;
+	}
+``
+
+
+[heading Exceptions]
+
+Exceptions thrown by __task__ are transported by the __act__.
+
+``
+	void throwing()
+	{
+		...
+		throw std::domain_error("domain error");
+		...
+	}
+
+	void main()
+	{
+		// create task throwing std::domain_error
+		boost::task::task void > t( throwing);
+
+		// execute task asynchron
+		// move task ownership to executor
+		boost::task::handle< void > h(
+			boost::task::async(
+				boost::move( t),
+				boost::task::new_thread() ) );
+
+		// wait for task completion
+		// throws std::domain_error
+		std::cout << h.wait() << std::endl;
+	}
+``
+
+Exceptions rethrown by type are:
+
+*  `std::bad_alloc`
+*  `std::bad_cast`
+*  `std::bad_exception`
+*  `std::bad_typeid`
+*  `std::domain_error`
+*  `std::invalid_argument`
+*  `std::ios_base::failure`
+*  `std::length_error`
+*  `std::logic_error`
+*  `std::out_of_range`
+*  `std::overflow_error`
+*  `std::range_error`
+*  `std::runtime_error`
+*  `std::underflow_error`
+*  `boost::exception`
+*  `boost::future_already_set`
+*  `boost::future_cancel`
+*  `boost::invalid_thread_argument`
+*  `boost::lock_error`
+*  `boost::broken_task`
+*  `boost::pool_moved`
+*  `boost::task_already_executed`
+*  `boost::task_interrupted`
+*  `boost::task_moved`
+*  `boost::task::task_interrupted`
+*  `boost::task_task_rejected`
+*  `boost::task_unitialized`
+
+
+[heading Parent task]
+
+Top-level tasks have no parent. A parent task can create child tasks when it creates another task by using __as_sub_task__ as __ep__.  These children are implicitly treated as __sub_tasks__ of the larger task.  It is assumed that that __sub_tasks__ can be executed in any order because only overall operation
+speed matters (enabling strategies for fast execution of unordered __work_items__ as [link_work_stealing __work_stealing__]).
+
+``
+	long serial_fib( long n)
+	{
+		if( n < 2) return n;
+		else return serial_fib( n - 1) + serial_fib( n - 2);
+	}
+
+	long parallel_fib( long n, long cutof)
+	{
+		if ( n < cutof) return serial_fib( n);
+		else
+		{
+			// sub-task for computing fibonacci(n-1)
+			boost::task::task< long > t1(
+				parallel_fib,
+				n - 1,
+				cutof);
+			// sub-task for computing fibonacci(n-2)
+			boost::task::task< long > t2(
+				parallel_fib,
+				n - 2,
+				cutof);
+
+			// submit a sub-tasks to thread-pool
+			// move task ownership to executor
+			boost::task::handle< long > h1(
+				boost::task::async(
+					boost::move( t1) );
+			boost::task::handle< long > h2(
+				boost::task::async(
+					boost::move( t2) );
+
+			// computing fibonacci(n) by
+			// joining results of both sub-tasks
+			return h1.get() + h2.get();
+		}
+	}
+
+	void main()
+	{
+		// create thread-pool with five worker-threads
+		boost::task::static_pool<
+			boost::task::unbounded_channel<
+				boost::task::fifo
+			>
+		> pool( boost::task::poolsize( 5) );
+
+		// create task computing fibonacci-number for 10
+		boost::task::task< long > t(
+			parallel_fib,
+			10,
+			5);
+
+		// execute task asynchron in thread-pool
+		// move task ownership to executor
+		boost::task::handle< long > h(
+			boost::task::async(
+				boost::move( t),
+				pool) );
+
+		// access result
+		std::cout << "fibonacci(10) == " << h.get() << std::endl;
+	}
+``
+
+[endsect]
diff -urN boost/libs/task/doc/todo.qbk boost-altered/libs/task/doc/todo.qbk
--- boost/libs/task/doc/todo.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/todo.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,53 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:todo Appendix A: Future development]
+
+[heading Dynamic thread-pool]
+
+* __dynamic_pool__ adds or removes __worker_threads__ from the __thread_pool__ depending on the work-load (undersubscription/
+oversubscription).
+
+
+[heading Communication and synchronisation abstractions]
+
+* [*Event variable]: A event variable is a bivalued variable (up/down) on which a task can wait for an event to be set or reset. The
+calling task will be suspended until the state of the event variable is that required by the caller.
+
+* [*Buffer]: A bounded/unbounded buffer is shared between several tasks. The data must be placed in, and retrieved from, the buffer
+under mutual exclusion. Condition synchronisation is required because a calling task attempting to place data into the buffer. When
+the buffer is full, the task must be suspended until there is space int the buffer. Also a retrieving task must be suspended when
+the buffer is empty. The data, once read, is destroyed.
+
+* [*Multicast]: The data is sent to a specific group of tasks and all tasks in the group should receive the data. Only when all tasks
+have received one item of data then another item is allowed to be transmitted.
+
+* [*Rendezvous]: A rendezvous uses direct naming and synchronous communication between tasks. One task that executes its command first
+will be delayed until the other tasks is ready to rendezvous.
+
+* [*Protected resource]: A protected resource is a passive entity that controls access to the internal states (to the controled real
+resources).
+
+* [*Task groups]: A task group defines a graph of interdependent tasks that can mostly be run in parallel. The tasks in the group have
+dependencies or communicate with each other.
+
+
+[heading Interdepended task]
+
+* With special support of concurrence and synchronisation abstractions interdepended tasks work in __thread_pools__ without deadlocking the pool. 
+
+
+[heading Optimizations]
+ 
+* two-lock-queue as global queue in __thread_pool__
+
+* maybe lock-free-queue as global queue too (how to provide the scheduling policies fifo, priority, smart?)
+
+
+
+[endsect]
diff -urN boost/libs/task/doc/utilities.qbk boost-altered/libs/task/doc/utilities.qbk
--- boost/libs/task/doc/utilities.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/utilities.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,54 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:utilities Utilities]
+
+__boost_task__ provides some free-functions which can be used inside a __task__ to access some informations (like if the __task__ 
+runs in a __thread_pool__).
+
+
+[heading reschedule_until]
+
+In the function `boost::this_task::reschedule_until( Pred const&)` allows to synchronize the task with other asynchronous events
+without blocking the __worker_threads__ (bool Pred::operator()() must not block). The current task will be rescheduled until the
+passed predicate becomes true.
+
+
+[heading get_pool]
+
+The pool in which the current code (__task__) is executed can be accessed via __fn_get_pool__. If hte code is not executed by a
+__worker_thread__ an assertion is raised.
+
+
+[heading runs_in_pool]
+
+In order to check if the current code is executed in a __thread_pool__ __fn_runs_in_pool__ should be used.
+
+
+[heading worker_id]
+
+__fn_worker_id__ returns the __thread_id__ of the __worker_thread__ executing the current __task__.
+
+
+[heading delay]
+
+The execution of a __task__ can be delayed for a time-duration or until a specific time-point with __fn_delay__.
+
+
+[heading yield]
+
+If a __task__ detects that it would bould block it can yield itself with __fn_yield__ so that the __worker_thread__ can execute
+another __task__ in the meantime.
+
+
+[heading interrupt]
+
+A __task__ can interrupt itself via __fn_tt_interrupt__.
+
+
+[endsect]
diff -urN boost/libs/task/doc/work_stealing.qbk boost-altered/libs/task/doc/work_stealing.qbk
--- boost/libs/task/doc/work_stealing.qbk	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/doc/work_stealing.qbk	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,51 @@
+[/
+          Copyright Oliver Kowalke 2009.
+ Distributed under the Boost Software License, Version 1.0.
+    (See accompanying file LICENSE_1_0.txt or copy at
+          http://www.boost.org/LICENSE_1_0.txt
+]
+
+
+[section:work_stealing Work-Stealing]
+
+Traditional __thread_pools__ do not scale because they use a single global-queue protected by a global-lock. The frequency at which
+__worker_threads__ aquire the global-lock becomes a limiting factor for the throughput if:
+
+*  the tasks become smaller
+
+*  more processors are added
+
+
+A __work_stealing__ algorithm can be used to solve this problem. It uses a special kind of queue which has two ends, and allows
+lock-free pushes and pops from the ['private end] (accessed by the __worker_thread__ owning the queue), but requires synchronization
+from the ['public end] (accessed by the other __worker_threads__). Synchronization is necessary when the queue is sufficiently small
+that private and public operations could conflict.
+
+The pool contains one global-queue (__bounded_channel__ or __unbounded_channel__) protected by a global-lock and each __worker_thread__
+has its own private local worker-queue. If work is enqueued by a __worker_thread__ the __task__ is stored in the worker queue. If the
+work is enqueued by a application thread it goes into the global queue. When __worker_threads__ are looking for work, they have
+following search order:
+
+*  look into the private worker-queue - tasks can be dequeued without locks
+
+*  look in the global-queue - locks are used for synchronization
+
+*  check other worker-queues ('stealing' tasks from private worker queues of other __worker_threads__) - requires locks
+
+
+For a lot of recursively queued tasks (so called __sub_tasks__), the use of a worker-queue per thread substantially reduces the
+synchronization necessary to complete the work.  There are also fewer cache effects due to sharing of the global-queue information.
+
+Operations on the private worker queue are executed in LIFO order and operations on worker queues of other __worker_threads__ in
+FIFO order (steals).
+
+*  There are chances that memory is still hot in the cache, if the tasks are pushed in LIFO order into the private worker queue.
+
+*  If a __worker_thread__ steals work in FIFO order, increases the chances that a larger 'chunk' of work will be stolen (the need
+for other steals will be possibly reduced). Because the __sub_tasks__ are stored in LIFO order, the oldest items are closer to the
+['public end] of the queue (forming a tree). Stealing such an older __task__ also steals a (probably) larger subtree of tasks
+unfolded if the stolen work item get executed. Since a __sub_task__ is just part of a larger __task__, we dont need to worry about
+execution order.
+
+
+[endsect]
diff -urN boost/libs/task/examples/bind_to_processors.cpp boost-altered/libs/task/examples/bind_to_processors.cpp
--- boost/libs/task/examples/bind_to_processors.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/bind_to_processors.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,100 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/assert.hpp>
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+typedef tsk::static_pool< tsk::unbounded_channel< tsk::fifo > > pool_type;
+
+int serial_fib( int n)
+{
+	if( n < 2)
+		return n;
+	else
+		return serial_fib( n - 1) + serial_fib( n - 2);
+}
+
+int parallel_fib( int n, int cutof)
+{
+	if ( n < cutof)
+	{
+		return serial_fib( n);
+	}
+	else
+	{
+		BOOST_ASSERT( boost::this_task::runs_in_pool() );
+		tsk::task< int > t1(
+			parallel_fib,
+			n - 1,
+			cutof);
+		tsk::task< int > t2(
+			parallel_fib,
+			n - 2,
+			cutof);
+		tsk::handle< int > h1(
+			tsk::async( boost::move( t1), tsk::as_sub_task() ) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), tsk::as_sub_task() ) );
+		return h1.get() + h2.get();
+	}
+}
+
+int main( int argc, char *argv[])
+{
+# if defined(BOOST_HAS_PROCESSOR_BINDINGS)
+	try
+	{
+		pool_type pool( pool_type::bind_to_processors() );
+
+		std::vector< tsk::handle< int > > results;
+		results.reserve( 10);
+
+		for ( int i = 0; i < 10; ++i)
+		{
+			tsk::task< int > t(
+				parallel_fib,
+				i,
+				5);
+			results.push_back(
+				tsk::async(
+					boost::move( t),
+					pool) );
+		}
+
+		tsk::waitfor_all( results.begin(), results.end() );
+
+		int k = 0;
+		std::vector< tsk::handle< int > >::iterator e( results.end() );
+		for (
+			  std::vector< tsk::handle< int > >::iterator i( results.begin() );
+			  i != e;
+			  ++i)
+			std::cout << "fibonacci(" << k++ << ") == " << i->get() << std::endl;
+
+		return EXIT_SUCCESS;
+	}
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+# endif
+
+	return EXIT_FAILURE;
+}
+
+
diff -urN boost/libs/task/examples/delay.cpp boost-altered/libs/task/examples/delay.cpp
--- boost/libs/task/examples/delay.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/delay.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,87 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+typedef tsk::static_pool< tsk::unbounded_channel< tsk::fifo > > pool_type;
+
+int serial_fib( int n)
+{
+	if( n < 2)
+		return n;
+	else
+		return serial_fib( n - 1) + serial_fib( n - 2);
+}
+
+int parallel_fib_( int n, int cutof)
+{
+	if ( n < cutof)
+	{
+		if ( n == 0)
+			boost::this_task::delay( pt::seconds( 2) );
+		return serial_fib( n);
+	}
+	else
+	{
+		BOOST_ASSERT( boost::this_task::runs_in_pool() );
+		tsk::task< int > t1(
+			parallel_fib_,
+			n - 1,
+			cutof);
+		tsk::task< int > t2(
+			parallel_fib_,
+			n - 2,
+			cutof);
+		tsk::handle< int > h1(
+			tsk::async( boost::move( t1), tsk::as_sub_task() ) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), tsk::as_sub_task() ) );
+		return h1.get() + h2.get();
+	}
+}
+
+void parallel_fib( int n)
+{
+	int result = parallel_fib_( n, 5);
+	printf("fibonnaci(%d) == %d\n", n, result);
+}
+
+int main( int argc, char *argv[])
+{
+	try
+	{
+		pool_type pool( tsk::poolsize( 5) );
+		
+		for ( int i = 0; i < 10; ++i)
+		{
+			tsk::task< void > t(
+				& parallel_fib,
+				i);
+			tsk::async(
+				boost::move( t),
+				pool);
+		}
+
+		return EXIT_SUCCESS;
+	}
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/examples/fork_join.cpp boost-altered/libs/task/examples/fork_join.cpp
--- boost/libs/task/examples/fork_join.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/fork_join.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,100 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+typedef tsk::static_pool< tsk::unbounded_channel< tsk::fifo > > pool_type;
+
+int serial_fib( int n)
+{
+	if( n < 2)
+		return n;
+	else
+		return serial_fib( n - 1) + serial_fib( n - 2);
+}
+
+int parallel_fib( int n, int	cutof)
+{
+	if ( n < cutof) return serial_fib( n);
+	else
+	{
+		BOOST_ASSERT( boost::this_task::runs_in_pool() );
+		tsk::task< int > t1(
+			parallel_fib,
+			n - 1,
+			cutof);
+		tsk::task< int > t2(
+			parallel_fib,
+			n - 2,
+			cutof);
+		tsk::handle< int > h1(
+			tsk::async(
+				boost::move( t1),
+				tsk::as_sub_task() ) ) ;
+		tsk::handle< int > h2(
+			tsk::async(
+				boost::move( t2),
+				tsk::as_sub_task() ) );
+		return h1.get() + h2.get();
+	}
+}
+
+int main( int argc, char *argv[])
+{
+	try
+	{
+		pool_type pool( tsk::poolsize( 5) );
+
+		std::vector< tsk::handle< int > > results;
+		results.reserve( 10);
+
+		pt::ptime start( pt::microsec_clock::universal_time() );
+
+		for ( int i = 0; i < 10; ++i)
+		{
+			tsk::task< int > t(
+				& parallel_fib,
+				i,
+				5);
+			results.push_back(
+				tsk::async(
+					boost::move( t),
+					pool) );
+		}
+
+		tsk::waitfor_all( results.begin(), results.end() );
+
+		int k = 0;
+		std::vector< tsk::handle< int > >::iterator e( results.end() );
+		for (
+			std::vector< tsk::handle< int > >::iterator i( results.begin() );
+			i != e;
+			++i)
+			std::cout << "fibonacci(" << k++ << ") == " << i->get() << std::endl;
+
+		pt::ptime stop( pt::microsec_clock::universal_time() );
+		std::cout << ( stop - start).total_milliseconds() << " milli seconds" << std::endl;
+
+		return EXIT_SUCCESS;
+	}
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/examples/interrupt.cpp boost-altered/libs/task/examples/interrupt.cpp
--- boost/libs/task/examples/interrupt.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/interrupt.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,74 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+typedef tsk::static_pool< tsk::unbounded_channel< tsk::fifo > > pool_type;
+
+inline
+int fibonacci_fn( int n)
+{
+	if ( n == 0) return 0;
+	if ( n == 1) return 1;
+	int k1( 1), k2( 0);
+	for ( int i( 2); i <= n; ++i)
+	{
+		boost::this_thread::interruption_point();
+		int tmp( k1);
+		k1 = k1 + k2;
+		k2 = tmp;
+	}
+	boost::this_thread::interruption_point();
+	return k1;
+}
+
+inline
+void long_running_fn()
+{ boost::this_thread::sleep( pt::seconds( 1) ); }
+
+int main( int argc, char *argv[])
+{
+	try
+	{
+		pool_type pool( tsk::poolsize( 5) );
+		
+		tsk::task< void > t1( long_running_fn);
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::async(
+			boost::move( t1),
+			pool);
+		std::cout << "poolsize == " << pool.size() << std::endl;
+		std::cout << "idle threads == " << pool.idle() << std::endl;
+		std::cout << "active threads == " << pool.active() << std::endl;
+		tsk::handle< int > h(
+			tsk::async(
+				boost::move( t2),
+				pool) );
+		h.interrupt();
+		std::cout << h.get() << std::endl;
+
+		return EXIT_SUCCESS;
+	}
+	catch ( tsk::task_interrupted const& )
+	{ std::cerr << "task_interrupted: task was interrupted" << std::endl; }
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/examples/Jamfile.v2 boost-altered/libs/task/examples/Jamfile.v2
--- boost/libs/task/examples/Jamfile.v2	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/Jamfile.v2	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,37 @@
+# Boost.Task Library Examples Jamfile
+
+#          Copyright Oliver Kowalke 2009.
+# Distributed under the Boost Software License, Version 1.0.
+#    (See accompanying file LICENSE_1_0.txt or copy at
+#          http://www.boost.org/LICENSE_1_0.txt)
+
+# For more information, see http://www.boost.org/
+
+import os ;
+
+if [ os.name ] = SOLARIS
+{
+	lib socket ;
+}
+
+project boost/task/example
+    : requirements
+        <library>../../thread/build//boost_thread
+        <library>../../system/build//boost_system
+        <library>../build//boost_task
+        <link>static
+        <threading>multi
+	<os>SOLARIS:<library>socket
+    ;
+
+exe bind_to_processors : bind_to_processors.cpp ;
+exe delay : delay.cpp ;
+exe fork_join : fork_join.cpp ;
+exe interrupt : interrupt.cpp ;
+exe pending : pending.cpp ;
+exe priority : priority.cpp ;
+exe reschedule_until : reschedule_until.cpp ;
+exe shutdonw_now : shutdown_now.cpp ;
+exe smart : smart.cpp ;
+exe submit : submit.cpp ;
+exe yield : yield.cpp ;
diff -urN boost/libs/task/examples/pending.cpp boost-altered/libs/task/examples/pending.cpp
--- boost/libs/task/examples/pending.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/pending.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,70 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/ref.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+typedef tsk::static_pool< tsk::unbounded_channel< tsk::fifo > > pool_type;
+
+inline
+int fibonacci_fn( int n)
+{
+	if ( n == 0) return 0;
+	if ( n == 1) return 1;
+	int k1( 1), k2( 0);
+	for ( int i( 2); i <= n; ++i)
+	{
+		boost::this_thread::interruption_point();
+		int tmp( k1);
+		k1 = k1 + k2;
+		k2 = tmp;
+	}
+	boost::this_thread::interruption_point();
+	return k1;
+}
+
+inline
+void long_running_fn()
+{ boost::this_thread::sleep( pt::seconds( 1) ); }
+
+int main( int argc, char *argv[])
+{
+	try
+	{
+		pool_type pool( tsk::poolsize( 5) );
+
+		tsk::task< void > t1( long_running_fn);
+		tsk::async(
+			boost::move( t1),
+			pool);
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async(
+				boost::move( t2),
+				pool) );
+		std::cout << "pending tasks == " << pool.pending() << std::endl;
+		std::cout << h.get() << std::endl;
+
+		return EXIT_SUCCESS;
+	}
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/examples/priority.cpp boost-altered/libs/task/examples/priority.cpp
--- boost/libs/task/examples/priority.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/priority.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,66 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <string>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+inline
+void print_fn( std::string const& msg)
+{ printf("%s", msg.c_str() ); }
+
+inline
+void long_running_fn()
+{ boost::this_thread::sleep( pt::milliseconds( 250) ); }
+
+int main( int argc, char *argv[])
+{
+	try
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::priority< int > >
+		> pool( tsk::poolsize( 1) );
+
+		tsk::task< void > t1( long_running_fn);
+		tsk::task< void > t2( print_fn, "a text.\n");
+		tsk::task< void > t3( print_fn, " is ");
+		tsk::task< void > t4( print_fn, "This");
+
+		tsk::async(
+			boost::move( t1),
+			3,
+			pool);
+		tsk::async(
+			boost::move( t2),
+			0,
+			pool);
+		tsk::async(
+			boost::move( t3),
+			1,
+			pool);
+		tsk::async(
+			boost::move( t4),
+			2,
+			pool);
+
+		return EXIT_SUCCESS;
+	}
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/examples/reschedule_until.cpp boost-altered/libs/task/examples/reschedule_until.cpp
--- boost/libs/task/examples/reschedule_until.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/reschedule_until.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,181 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <cerrno>
+#include <cstddef>
+#include <cstring>
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <string>
+
+#include "boost/task/detail/config.hpp"
+
+# if defined(BOOST_POSIX_API)
+extern "C"
+{
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
+}
+# endif
+
+#include <boost/assert.hpp>
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/thread.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+typedef tsk::static_pool< tsk::unbounded_channel< tsk::fifo > > pool_type;
+
+int serial_fib( int n)
+{
+	if( n < 2)
+		return n;
+	else
+		return serial_fib( n - 1) + serial_fib( n - 2);
+}
+
+int parallel_fib_( int n, int cutof)
+{
+	if ( n == 4)
+		boost::this_task::yield();
+
+		if ( n < cutof)
+	{
+		if ( n == 0)
+			boost::this_task::delay( pt::seconds( 2) );
+		return serial_fib( n);
+	}
+	else
+	{
+		BOOST_ASSERT( boost::this_task::runs_in_pool() );
+		tsk::task< int > t1(
+			parallel_fib_,
+			n - 1,
+			cutof);
+		tsk::task< int > t2(
+			parallel_fib_,
+			n - 2,
+			cutof);
+		tsk::handle< int > h1(
+			tsk::async( boost::move( t1), tsk::as_sub_task() ) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), tsk::as_sub_task() ) );
+		return h1.get() + h2.get();
+	}
+}
+
+void parallel_fib( int n)
+{
+	printf("fibonacci(%d) == %d\n", n, parallel_fib_( n, 5) );
+}
+
+# if defined(BOOST_POSIX_API)
+bool has_bytes( int fd)
+{
+	char buffer[1];
+
+	int n = ::recv(
+		fd,
+		& buffer,
+		sizeof buffer,
+		MSG_PEEK | MSG_DONTWAIT);
+	if ( n == -1 && errno != EWOULDBLOCK)
+	{
+		printf("::recv() failed: %s(%d)\n", std::strerror( errno), errno);
+		::exit( 1);
+	}
+
+	return n > 0;
+}
+
+void do_read( int fd)
+{
+	int nread = 0;
+	do
+	{
+		boost::this_task::reschedule_until(
+			boost::bind(
+				has_bytes,
+				fd) );
+	
+		char buffer[4096];
+		int n = ::read( fd, buffer, sizeof( buffer) );
+		if ( n < 0)
+		{
+			printf("::read() failed: %s(%d)\n", std::strerror( errno), errno);
+			::exit( 1);
+		}
+		nread += n;
+		printf("%s\n", std::string( buffer, n).c_str() );
+	}
+	while ( nread < 12);
+}
+
+void do_write( int fd, std::string const& msg)
+{
+	if ( ::write( fd, msg.c_str(), msg.size() ) < 0)
+	{
+		printf("::write() failed: %s(%d)\n", std::strerror( errno), errno);
+		::exit( 1);
+	}
+}
+
+void create_sockets( int fd[2])
+{
+	if ( ::socketpair( PF_LOCAL, SOCK_STREAM, 0, fd) < 0)
+	{
+		printf("::pipe() failed: %s(%d)\n", std::strerror( errno), errno);
+		::exit( 1);
+	}
+}
+# endif
+
+int main( int argc, char *argv[])
+{
+# if defined(BOOST_POSIX_API)
+	try
+	{
+		pool_type pool( tsk::poolsize( 5) );
+
+		int fd[2];
+		create_sockets( fd);
+
+		tsk::task< void > t1( do_read, fd[0]);
+
+		tsk::async(
+			boost::move( t1),
+			pool);
+
+		do_write( fd[1], "Hello ");
+		boost::this_thread::sleep( pt::seconds( 1) );
+
+		for ( int i = 0; i < 10; ++i)
+		{
+			tsk::task< void > t( parallel_fib, i);
+			tsk::async(
+				boost::move( t),
+				pool);
+		}
+
+		do_write( fd[1], "World!");
+
+		return EXIT_SUCCESS;
+	}
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+# endif
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/examples/shutdown_now.cpp boost-altered/libs/task/examples/shutdown_now.cpp
--- boost/libs/task/examples/shutdown_now.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/shutdown_now.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,70 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/ref.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+inline
+int fibonacci_fn( int n)
+{
+	boost::this_thread::sleep( pt::milliseconds( 500) );
+	if ( n == 0) return 0;
+	if ( n == 1) return 1;
+	int k1( 1), k2( 0);
+	for ( int i( 2); i <= n; ++i)
+	{
+		boost::this_thread::interruption_point();
+		int tmp( k1);
+		k1 = k1 + k2;
+		k2 = tmp;
+	}
+	boost::this_thread::interruption_point();
+	return k1;
+}
+
+int main( int argc, char *argv[])
+{
+	try
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 1) );
+
+		tsk::task< int > t( fibonacci_fn, 10);
+				
+		tsk::handle< int > h(
+			tsk::async(
+				boost::move( t),
+				pool) );
+
+		boost::this_thread::sleep( pt::milliseconds( 250) );
+
+		pool.shutdown_now();
+
+		std::cout << h.get() << std::endl;
+
+		return EXIT_SUCCESS;
+	}
+	catch ( tsk::task_interrupted const& )
+	{ std::cerr << "task_interrupted: task was interrupted" << std::endl; }
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/examples/smart.cpp boost-altered/libs/task/examples/smart.cpp
--- boost/libs/task/examples/smart.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/smart.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,92 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <string>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+inline
+void fibonacci_fn( int n)
+{
+	if ( n == 0)
+	{
+		printf("fibonacci(%d) == 0\n", n);
+		return;
+	}
+	if ( n == 1)
+	{
+		printf("fibonacci(%d) == 1\n", n);
+		return;
+	}
+	int k1( 1), k2( 0);
+	for ( int i( 2); i <= n; ++i)
+	{
+		int tmp( k1);
+		k1 = k1 + k2;
+		k2 = tmp;
+	}
+	printf("fibonacci(%d) == %d\n", n, k1);
+}
+
+inline
+void long_running_fn()
+{ boost::this_thread::sleep( pt::milliseconds( 500) ); }
+
+int main( int argc, char *argv[])
+{
+	try
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel<
+				tsk::smart<
+					int,
+					std::less< int >,
+					tsk::replace_oldest,
+					tsk::take_oldest
+				>
+			>
+		> pool( tsk::poolsize( 1) );
+
+		tsk::task< void > t1( long_running_fn);
+		tsk::task< void > t2( fibonacci_fn, 0);
+		tsk::task< void > t3( fibonacci_fn, 1);
+		tsk::task< void > t4( fibonacci_fn, 10);
+
+		tsk::async(
+			boost::move( t1),
+			0,
+			pool);
+		tsk::async(
+			boost::move( t2),
+			1,
+			pool);
+		tsk::async(
+			boost::move( t3),
+			2,
+			pool);
+		tsk::async(
+			boost::move( t4),
+			2,
+			pool);
+
+		return EXIT_SUCCESS;
+	}
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/examples/submit.cpp boost-altered/libs/task/examples/submit.cpp
--- boost/libs/task/examples/submit.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/submit.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,77 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+
+#include <boost/bind.hpp>
+
+#include "boost/task.hpp"
+
+namespace tsk = boost::task;
+
+inline
+int fibonacci_fn( int n)
+{
+	if ( n == 0) return 0;
+	if ( n == 1) return 1;
+	int k1( 1), k2( 0);
+	for ( int i( 2); i <= n; ++i)
+	{
+		boost::this_thread::interruption_point();
+		int tmp( k1);
+		k1 = k1 + k2;
+		k2 = tmp;
+	}
+	boost::this_thread::interruption_point();
+	return k1;
+}
+
+int main( int argc, char *argv[])
+{
+	try
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::priority< int > >
+		> pool( tsk::poolsize( 3) );
+		
+		tsk::task< int > t1( fibonacci_fn, 10);
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::task< int > t3( fibonacci_fn, 10);
+		tsk::task< int > t4( fibonacci_fn, 10);
+
+		tsk::handle< int > h1(
+			tsk::async( boost::move( t1) ) );
+		tsk::handle< int > h2(
+			tsk::async(
+				boost::move( t2),
+				tsk::new_thread() ) );
+		tsk::handle< int > h3(
+			tsk::async(
+				boost::move( t3),
+				2,
+				pool) );
+		tsk::handle< int > h4(
+			tsk::async(
+				boost::move( t4),
+				2,
+				pool) );
+
+		std::cout << h1.get() << std::endl;
+		std::cout << h2.get() << std::endl;
+		std::cout << h3.get() << std::endl;
+		std::cout << h4.get() << std::endl;
+
+		return EXIT_SUCCESS;
+	}
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/examples/yield.cpp boost-altered/libs/task/examples/yield.cpp
--- boost/libs/task/examples/yield.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/examples/yield.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,89 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <iostream>
+#include <cstdlib>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/assert.hpp>
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+
+#include "boost/task.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+typedef tsk::static_pool< tsk::unbounded_channel< tsk::fifo > > pool_type;
+
+int serial_fib( int n)
+{
+	if( n < 2)
+		return n;
+	else
+		return serial_fib( n - 1) + serial_fib( n - 2);
+}
+
+int parallel_fib_( int n, int cutof)
+{
+	if ( n == 4)
+		boost::this_task::yield();
+
+		if ( n < cutof)
+	{
+		if ( n == 0)
+			boost::this_task::delay( pt::seconds( 2) );
+		return serial_fib( n);
+	}
+	else
+	{
+		BOOST_ASSERT( boost::this_task::runs_in_pool() );
+		tsk::task< int > t1(
+			parallel_fib_,
+			n - 1,
+			cutof);
+		tsk::task< int > t2(
+			parallel_fib_,
+			n - 2,
+			cutof);
+		tsk::handle< int > h1(
+			tsk::async( boost::move( t1), tsk::as_sub_task() ) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), tsk::as_sub_task() ) );
+		return h1.get() + h2.get();
+	}
+}
+
+void parallel_fib( int n)
+{
+	int result = parallel_fib_( n, 5);
+	printf("fibonnaci(%d) == %d\n", n, result);
+}
+
+int main( int argc, char *argv[])
+{
+	try
+	{
+		pool_type pool( tsk::poolsize( 3) );
+
+		for ( int i = 0; i < 10; ++i)
+		{
+			tsk::task< void > t( parallel_fib, i);
+			tsk::async(
+				boost::move( t),
+				pool);
+		}
+
+		return EXIT_SUCCESS;
+	}
+	catch ( std::exception const& e)
+	{ std::cerr << "exception: " << e.what() << std::endl; }
+	catch ( ... )
+	{ std::cerr << "unhandled" << std::endl; }
+
+	return EXIT_FAILURE;
+}
diff -urN boost/libs/task/src/guard.cpp boost-altered/libs/task/src/guard.cpp
--- boost/libs/task/src/guard.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/guard.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,30 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/detail/guard.hpp"
+
+#include <boost/assert.hpp>
+
+#include <boost/task/detail/atomic.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+guard::guard( volatile uint32_t & active_worker)
+: active_worker_( active_worker)
+{
+	BOOST_ASSERT( active_worker_ >= 0);
+	atomic_fetch_add( & active_worker_, 1);
+}
+
+guard::~guard()
+{
+	atomic_fetch_sub( & active_worker_, 1);
+	BOOST_ASSERT( active_worker_ >= 0);
+}
+} } }
+
diff -urN boost/libs/task/src/interrupter.cpp boost-altered/libs/task/src/interrupter.cpp
--- boost/libs/task/src/interrupter.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/interrupter.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,92 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/detail/interrupter.hpp"
+
+#include <boost/assert.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+void
+interrupter::impl::interrupt_()
+{
+	if ( ! interruption_requested_)
+	{
+		interruption_requested_ = true;
+		if ( thrd_) thrd_->interrupt();
+	}
+}
+
+interrupter::impl::impl()
+:
+interruption_requested_( false),
+mtx_(),
+thrd_()
+{}
+
+interrupter::impl::~impl()
+{ reset(); }
+
+void
+interrupter::impl::set( shared_ptr< thread > const& thrd)
+{
+	unique_lock< mutex > lk( mtx_);
+	thrd_ = thrd;
+	BOOST_ASSERT( thrd_);
+	if ( interruption_requested_)
+		if ( thrd_) thrd_->interrupt();
+}
+
+void
+interrupter::impl::reset()
+{
+	unique_lock< mutex > lk( mtx_);
+	try
+	{ this_thread::interruption_point(); }
+	catch ( thread_interrupted const&)
+	{}
+	thrd_.reset();
+	BOOST_ASSERT( ! this_thread::interruption_requested() );
+}
+
+void
+interrupter::impl::interrupt()
+{
+	unique_lock< mutex > lk( mtx_);
+	interrupt_();
+}
+
+bool
+interrupter::impl::interruption_requested()
+{
+	unique_lock< mutex > lk( mtx_);
+	return interruption_requested_;
+}
+
+interrupter::interrupter()
+: impl_( new impl() )
+{}
+
+void
+interrupter::set( shared_ptr< thread > const& thrd)
+{ impl_->set( thrd); }
+
+void
+interrupter::reset()
+{ impl_->reset(); }
+
+void
+interrupter::interrupt()
+{ impl_->interrupt(); }
+
+bool
+interrupter::interruption_requested()
+{ return impl_->interruption_requested(); }
+}
+} }
+
diff -urN boost/libs/task/src/pool_callable.cpp boost-altered/libs/task/src/pool_callable.cpp
--- boost/libs/task/src/pool_callable.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/pool_callable.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,36 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/detail/pool_callable.hpp"
+
+namespace boost { namespace task
+{
+namespace detail
+{
+pool_callable::pool_callable()
+: impl_()
+{}
+
+void
+pool_callable::operator()()
+{ impl_->run(); }
+
+bool
+pool_callable::empty() const
+{ return ! impl_; }
+
+void
+pool_callable::clear()
+{ impl_.reset(); }
+
+pool_callable::scoped_guard::scoped_guard( pool_callable & ca, shared_ptr< thread > & thrd)
+: ca_( ca)
+{ ca_.impl_->set( thrd); }
+
+pool_callable::scoped_guard::~scoped_guard()
+{ ca_.impl_->reset(); }
+} } }
+
diff -urN boost/libs/task/src/poolsize.cpp boost-altered/libs/task/src/poolsize.cpp
--- boost/libs/task/src/poolsize.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/poolsize.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,20 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/poolsize.hpp"
+
+#include <boost/task/exceptions.hpp>
+
+namespace boost { namespace task
+{
+poolsize::poolsize( std::size_t value)
+: value_( value)
+{ if ( value <= 0) throw invalid_poolsize(); }
+
+poolsize::operator std::size_t () const
+{ return value_; }
+} }
+
diff -urN boost/libs/task/src/scanns.cpp boost-altered/libs/task/src/scanns.cpp
--- boost/libs/task/src/scanns.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/scanns.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,20 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/scanns.hpp"
+
+#include <boost/task/exceptions.hpp>
+
+namespace boost { namespace task
+{
+scanns::scanns( std::size_t value)
+: value_( value)
+{ if ( value < 0) throw invalid_scanns(); }
+
+scanns::operator std::size_t () const
+{ return value_; }
+} }
+
diff -urN boost/libs/task/src/semaphore_posix.cpp boost-altered/libs/task/src/semaphore_posix.cpp
--- boost/libs/task/src/semaphore_posix.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/semaphore_posix.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,84 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/semaphore.hpp"
+
+#include <cerrno>
+
+#include <boost/system/error_code.hpp>
+#include <boost/system/system_error.hpp>
+
+#include "boost/task/utility.hpp"
+
+namespace boost { namespace task
+{
+semaphore::semaphore( int value)
+: handle_()
+{
+	if ( ::sem_init( & handle_, 0, value) == -1)
+		throw system::system_error( errno, system::system_category);
+}
+
+semaphore::~semaphore()
+{ ::sem_destroy( & handle_); }
+
+void
+semaphore::post()
+{
+	if ( ::sem_post( & handle_) == -1)
+		throw system::system_error( errno, system::system_category);
+}
+
+void
+semaphore::wait()
+{
+	int ret( -1);
+	if ( this_task::runs_in_pool() )
+	{
+		// TODO: use semaphore::try_wait(), create a fiber and do a reschedule until
+		// semaphore::try_wait() returns true
+		do
+		{ ret = ::sem_wait( & handle_); }
+		while ( ret == -1 && errno == EINTR);
+		if ( ret == -1)
+			throw system::system_error( errno, system::system_category);
+	}
+	else
+	{
+		do
+		{ ret = ::sem_wait( & handle_); }
+		while ( ret == -1 && errno == EINTR);
+		if ( ret == -1)
+			throw system::system_error( errno, system::system_category);
+	}
+}
+
+bool 
+semaphore::try_wait()
+{
+	int ret( -1);
+	do
+	{ ret = ::sem_trywait( & handle_); }
+	while ( ret == -1 && errno == EINTR);
+	if ( ret == -1)
+	{
+		if ( errno == EAGAIN)
+			return false;
+		else
+			throw system::system_error( errno, system::system_category);
+	}
+	return true;
+}
+
+int
+semaphore::value()
+{
+	int value( 0);
+	if ( ::sem_getvalue( & handle_, & value) == -1)
+		throw system::system_error( errno, system::system_category);
+	return value;
+}
+}}
diff -urN boost/libs/task/src/semaphore_windows.cpp boost-altered/libs/task/src/semaphore_windows.cpp
--- boost/libs/task/src/semaphore_windows.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/semaphore_windows.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,80 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/semaphore.hpp"
+
+#include <cerrno>
+#include <limits>
+
+#include <boost/system/error_code.hpp>
+#include <boost/system/system_error.hpp>
+
+#include "boost/task/utility.hpp"
+
+namespace boost { namespace task
+{
+semaphore::semaphore( int value)
+: handle_()
+{
+	if ( ( handle_ = ::CreateSemaphore( 0, value, (std::numeric_limits< int >::max)(), 0) ) == 0)
+		throw system::system_error( ::GetLastError(), system::system_category);
+}
+
+semaphore::~semaphore()
+{ ::CloseHandle( handle_); }
+
+void
+semaphore::post()
+{
+	if ( ! ::ReleaseSemaphore( handle_, 1, 0) )
+		throw system::system_error( ::GetLastError(), system::system_category);
+}
+
+void
+semaphore::wait()
+{
+	if ( this_task::runs_in_pool() )
+	{
+		// TODO: use semaphore::try_wait(), create a fiber and do a reschedule until
+		// semaphore::try_wait() returns true
+		if ( ::WaitForSingleObject( handle_, INFINITE) != WAIT_OBJECT_0)
+			throw system::system_error( ::GetLastError(), system::system_category);
+	}
+	else
+	{
+		if ( ::WaitForSingleObject( handle_, INFINITE) != WAIT_OBJECT_0)
+			throw system::system_error( ::GetLastError(), system::system_category);
+	}
+}
+
+bool 
+semaphore::try_wait()
+{
+	switch ( ::WaitForSingleObject( handle_, 0) )
+	{
+	case WAIT_OBJECT_0:
+		return true;
+	case WAIT_TIMEOUT:
+		return false;
+	default:
+		throw system::system_error( ::GetLastError(), system::system_category);
+	}
+	return true;
+}
+
+int
+semaphore::value()
+{
+	int value( 0);
+	if ( ::WaitForSingleObject( handle_, 0) != WAIT_TIMEOUT)
+	{
+		if ( ! ::ReleaseSemaphore( handle_, 1, ( LPLONG) & value) )
+			throw system::system_error( ::GetLastError(), system::system_category);
+		++ value;
+	}
+	return value;
+}
+}}
diff -urN boost/libs/task/src/watermark.cpp boost-altered/libs/task/src/watermark.cpp
--- boost/libs/task/src/watermark.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/watermark.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,32 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/watermark.hpp"
+
+#include <boost/task/exceptions.hpp>
+
+namespace boost { namespace task
+{
+high_watermark::high_watermark( std::size_t value)
+: value_( value)
+{
+	if ( value <= 0)
+		throw invalid_watermark("high watermark must be greater than zero");
+}
+
+high_watermark::operator std::size_t () const
+{ return value_; }
+
+low_watermark::low_watermark( std::size_t value)
+: value_( value)
+{
+	if ( value < 0)
+		throw invalid_watermark("low watermark must be greater than or equal to zero");
+}
+
+low_watermark::operator std::size_t () const
+{ return value_; }
+} }
diff -urN boost/libs/task/src/worker.cpp boost-altered/libs/task/src/worker.cpp
--- boost/libs/task/src/worker.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/worker.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,62 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/detail/worker.hpp"
+
+namespace boost { namespace task
+{
+namespace detail
+{
+thread_specific_ptr< worker > worker::tss_;
+
+const thread::id
+worker::get_id() const
+{ return impl_->get_id(); }
+
+void
+worker::join() const
+{ impl_->join(); }
+
+void
+worker::interrupt() const
+{ impl_->interrupt(); }
+
+void
+worker::signal_shutdown()
+{ impl_->signal_shutdown(); }
+
+void
+worker::signal_shutdown_now()
+{ impl_->signal_shutdown_now(); }
+
+void
+worker::put( pool_callable const& ca)
+{ impl_->put( ca); }
+
+bool
+worker::try_take( pool_callable & ca)
+{ return impl_->try_take( ca); }
+
+bool
+worker::try_steal( pool_callable & ca)
+{ return impl_->try_steal( ca); }
+
+void
+worker::reschedule_until( function< bool() > const& pred)
+{ return impl_->reschedule_until( pred); }
+
+void
+worker::run()
+{
+	worker::tss_.reset( new worker( * this) );
+	impl_->run();
+}
+
+worker *
+worker::tss_get()
+{ return worker::tss_.get(); }
+} } }
+
diff -urN boost/libs/task/src/worker_group.cpp boost-altered/libs/task/src/worker_group.cpp
--- boost/libs/task/src/worker_group.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/worker_group.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,88 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/detail/worker_group.hpp"
+
+#include <boost/foreach.hpp>
+#include <boost/utility.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+worker_group::worker_group()
+:
+cont_(),
+id_idx_( cont_.get< id_idx_tag >() ),
+rnd_idx_( cont_.get< rnd_idx_tag >() )
+{}
+
+const worker
+worker_group::operator[]( std::size_t pos) const
+{ return rnd_idx_[pos]; }
+
+std::size_t
+worker_group::size() const
+{ return cont_.size(); }
+
+const worker_group::iterator
+worker_group::begin()
+{ return id_idx_.begin(); }
+
+const worker_group::const_iterator
+worker_group::begin() const
+{ return id_idx_.begin(); }
+
+const worker_group::iterator
+worker_group::end()
+{ return id_idx_.end(); }
+
+const worker_group::const_iterator
+worker_group::end() const
+{ return id_idx_.end(); }
+
+const worker_group::const_iterator
+worker_group::find( thread::id const& id) const
+{ return id_idx_.find( id); }
+
+void
+worker_group::join_all()
+{
+	BOOST_FOREACH( worker w, cont_)
+	{
+		try
+		{ w.join(); }
+		catch (...)
+		{}
+	}
+}
+
+void
+worker_group::interrupt_all()
+{
+	BOOST_FOREACH( worker w, cont_)
+	{ w.interrupt(); }
+}
+
+void
+worker_group::insert( worker const& w)
+{ cont_.insert( w); }
+
+void
+worker_group::signal_shutdown_all()
+{
+	BOOST_FOREACH( worker w, cont_)
+	{ w.signal_shutdown(); }
+}
+
+void
+worker_group::signal_shutdown_now_all()
+{
+	BOOST_FOREACH( worker w, cont_)
+	{ w.signal_shutdown_now(); }
+}
+} } }
+
diff -urN boost/libs/task/src/wsq.cpp boost-altered/libs/task/src/wsq.cpp
--- boost/libs/task/src/wsq.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/src/wsq.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,119 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/task/detail/wsq.hpp"
+
+#include <boost/thread/locks.hpp>
+
+#include <boost/task/detail/atomic.hpp>
+
+namespace boost { namespace task
+{
+namespace detail
+{
+wsq::wsq()
+:
+initial_size_( 32),
+array_( new pool_callable[ initial_size_]),
+capacity_( initial_size_),
+mask_( initial_size_ - 1),
+head_idx_( 0),
+tail_idx_( 0),
+mtx_()
+{}
+
+bool
+wsq::empty() const
+{ return head_idx_ >= tail_idx_; }
+
+std::size_t
+wsq::size() const
+{ return tail_idx_ - head_idx_; }
+
+void
+wsq::put( pool_callable const& ca)
+{
+	uint32_t tail( tail_idx_);
+	if ( tail <= head_idx_ + mask_)
+	{
+		array_[tail & mask_] = ca;
+		tail_idx_ = tail + 1;
+	}
+	else
+	{
+		unique_lock< recursive_mutex > lk( mtx_);
+		uint32_t head( head_idx_);
+		int count( size() );
+
+		if ( count >= mask_)
+		{
+			capacity_ <<= 1;
+			shared_array< pool_callable > array( new pool_callable[capacity_]);
+			for ( int i( 0); i != count; ++i)
+				array[i] = array_[(i + head) & mask_];
+			array_.swap( array);
+			head_idx_ = 0;
+			tail_idx_ = tail = count;
+			mask_ = (mask_ << 1) | 1;
+		}
+		array_[tail & mask_] = ca;
+		tail_idx_ = tail + 1;
+	}
+}
+
+bool
+wsq::try_take( pool_callable & ca)
+{
+	uint32_t tail( tail_idx_);
+	if ( tail == 0)
+		return false;
+	tail -= 1;
+	atomic_exchange( & tail_idx_, tail);
+	if ( head_idx_ <= tail)
+	{
+		ca = array_[tail & mask_];
+		return true;
+	}
+	else
+	{
+		unique_lock< recursive_mutex > lk( mtx_);
+		if ( head_idx_ <= tail)
+		{
+			ca = array_[tail & mask_];
+			return true;
+		}
+		else
+		{
+			tail_idx_ = tail + 1;
+			return false;
+		}
+	}
+}
+
+bool
+wsq::try_steal( pool_callable & ca)
+{
+	recursive_mutex::scoped_try_lock lk( mtx_);
+	if ( lk.owns_lock() )
+	{
+		uint32_t head( head_idx_);
+		atomic_exchange( & head_idx_, head + 1);
+		if ( head < tail_idx_)
+		{
+			ca = array_[head & mask_];
+			return true;
+		}
+		else
+		{
+			head_idx_ = head;
+			return false;
+		}
+	}
+	return false;
+}
+} } }
+
+
diff -urN boost/libs/task/test/Jamfile.v2 boost-altered/libs/task/test/Jamfile.v2
--- boost/libs/task/test/Jamfile.v2	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/test/Jamfile.v2	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,34 @@
+# Boost.Task Library Tests Jamfile
+
+#          Copyright Oliver Kowalke 2009.
+# Distributed under the Boost Software License, Version 1.0.
+#    (See accompanying file LICENSE_1_0.txt or copy at
+#          http://www.boost.org/LICENSE_1_0.txt)
+
+import testing ;
+
+project boost/task/test
+    : requirements
+        <library>../../test/build//boost_unit_test_framework
+        <library>../../thread/build//boost_thread
+        <library>../../system/build//boost_system
+        <library>../build//boost_task
+        <link>static
+        <threading>multi
+    ;
+
+rule task-test ( source )
+{
+    return
+        [ run $(source).cpp ]
+    ;
+}
+
+test-suite task :
+    [ task-test test_futures ]
+    [ task-test test_task ]
+    [ task-test test_own_thread ]
+    [ task-test test_new_thread ]
+    [ task-test test_unbounded_pool ]
+    [ task-test test_bounded_pool ]
+    ;
diff -urN boost/libs/task/test/test_bounded_pool.cpp boost-altered/libs/task/test/test_bounded_pool.cpp
--- boost/libs/task/test/test_bounded_pool.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/test/test_bounded_pool.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,639 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/function.hpp>
+#include <boost/ref.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/barrier.hpp>
+#include <boost/type_traits/is_same.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task.hpp>
+
+#include "test_functions.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+class test_bounded_pool
+{
+public:
+	// check size, active, idle
+	void test_case_1()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool1(
+			tsk::poolsize( 3),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 5) );
+		BOOST_CHECK( pool1);
+		BOOST_CHECK_EQUAL( pool1.size(), std::size_t( 3) );
+		BOOST_CHECK_EQUAL( pool1.idle(), std::size_t( 3) );
+		BOOST_CHECK_EQUAL( pool1.active(), std::size_t( 0) );
+		BOOST_CHECK_EQUAL( pool1.upper_bound(), std::size_t( 10) );
+		BOOST_CHECK_EQUAL( pool1.lower_bound(), std::size_t( 5) );
+
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool2;
+		BOOST_CHECK( ! pool2);
+		BOOST_CHECK_THROW( pool2.size(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool2.idle(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool2.active(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool2.upper_bound(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool2.lower_bound(), tsk::pool_moved);
+
+		pool2 = boost::move( pool1);
+
+		BOOST_CHECK( ! pool1);
+		BOOST_CHECK_THROW( pool1.size(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool1.idle(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool1.active(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool1.upper_bound(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool1.lower_bound(), tsk::pool_moved);
+
+		BOOST_CHECK( pool2);
+		BOOST_CHECK_EQUAL( pool2.size(), std::size_t( 3) );
+		BOOST_CHECK_EQUAL( pool2.idle(), std::size_t( 3) );
+		BOOST_CHECK_EQUAL( pool2.active(), std::size_t( 0) );
+		BOOST_CHECK_EQUAL( pool2.upper_bound(), std::size_t( 10) );
+		BOOST_CHECK_EQUAL( pool2.lower_bound(), std::size_t( 5) );
+
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), pool2) );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check submit
+	void test_case_2()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check assignment
+	void test_case_3()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h1;
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t), pool) );
+		h1 = h2;
+		BOOST_CHECK_EQUAL( h1.get(), 55);
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+	}
+
+	// check swap
+	void test_case_4()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< int > t1( fibonacci_fn, 5);
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::handle< int > h1(
+			tsk::async( boost::move( t1), pool) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), pool) );
+		BOOST_CHECK_EQUAL( h1.get(), 5);
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+		BOOST_CHECK_NO_THROW( h1.swap( h2) );
+		BOOST_CHECK_EQUAL( h1.get(), 55);
+		BOOST_CHECK_EQUAL( h2.get(), 5);
+	}
+	
+	// check runs in pool
+	void test_case_5()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< bool > t( runs_in_pool_fn);
+		tsk::handle< bool > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK_EQUAL( h.get(), true);
+	}
+
+	// check shutdown
+	void test_case_6()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), pool) );
+		pool.shutdown();
+		BOOST_CHECK( pool.closed() );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check runtime_error throw inside task
+	void test_case_7()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< void > t( throwing_fn);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		pool.shutdown();
+		BOOST_CHECK_THROW( h.get(), std::runtime_error);
+	}
+
+	// check shutdown with task_rejected exception
+	void test_case_8()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		pool.shutdown();
+		BOOST_CHECK( pool.closed() );
+		BOOST_CHECK_THROW(
+			tsk::async( boost::move( t), pool),
+			tsk::task_rejected);
+	}
+
+	// check shutdown_now with thread_interrupted exception
+	void test_case_9()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 1),
+			tsk::low_watermark( 1) );
+		tsk::task< void > t( delay_fn, pt::millisec( 500) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		boost::this_thread::sleep( pt::millisec( 250) );
+		BOOST_CHECK_EQUAL( pool.size(), std::size_t( 1) );
+		pool.shutdown_now();
+		BOOST_CHECK( pool.closed() );
+		BOOST_CHECK_EQUAL( pool.size(), std::size_t( 1) );
+		BOOST_CHECK_EQUAL( pool.idle(), std::size_t( 1) );
+		BOOST_CHECK_EQUAL( pool.active(), std::size_t( 0) );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check pending
+	void test_case_10()
+	{
+		typedef tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool_type;
+		pool_type pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		boost::barrier b( 2);
+		tsk::task< void > t1(
+			barrier_fn,
+			boost::ref( b) );
+		tsk::task< int > t2(
+			fibonacci_fn,
+			10);
+		tsk::task< int > t3(
+			fibonacci_fn,
+			10);
+		tsk::handle< void > h1(
+			tsk::async( boost::move( t1), pool) );
+		boost::this_thread::sleep( pt::millisec( 250) );
+		BOOST_CHECK_EQUAL( pool.pending(), std::size_t( 0) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), pool) );
+		boost::this_thread::sleep( pt::millisec(250) );
+		BOOST_CHECK_EQUAL( pool.pending(), std::size_t( 1) );
+		tsk::handle< int > h3(
+			tsk::async( boost::move( t3), pool) );
+		boost::this_thread::sleep( pt::millisec(250) );
+		BOOST_CHECK_EQUAL( pool.pending(), std::size_t( 2) );
+		b.wait();
+		h1.get();
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+		BOOST_CHECK_EQUAL( h3.get(), 55);
+		BOOST_CHECK_EQUAL( pool.pending(), std::size_t( 0) );
+	}
+
+	// check wait
+	void test_case_11()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 1),
+			tsk::low_watermark( 1) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), pool) );
+		h.wait();
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check wait_for
+	void test_case_12()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 1),
+			tsk::low_watermark( 1) );
+		tsk::task< void > t( delay_fn, pt::seconds( 1) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( h.wait_for( pt::seconds( 3) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_13()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 1),
+			tsk::low_watermark( 1) );
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( ! h.wait_for( pt::seconds( 1) ) );
+		BOOST_CHECK( ! h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_14()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 1),
+			tsk::low_watermark( 1) );
+		tsk::task< void > t( delay_fn, pt::seconds( 1) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( h.wait_until( boost::get_system_time() + pt::seconds( 3) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_15()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 1),
+			tsk::low_watermark( 1) );
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( ! h.wait_until( boost::get_system_time() + pt::seconds( 1) ) );
+		BOOST_CHECK( ! h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check interrupt
+	void test_case_16()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		h.interrupt();
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_all_worker
+	void test_case_17()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< void > t1( delay_fn, pt::seconds( 3) );
+		tsk::task< void > t2( delay_fn, pt::seconds( 3) );
+		tsk::task< void > t3( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h1(
+			tsk::async( boost::move( t1), pool) );
+		tsk::handle< void > h2(
+			tsk::async( boost::move( t2), pool) );
+		tsk::handle< void > h3(
+			tsk::async( boost::move( t3), pool) );
+		boost::this_thread::sleep( pt::millisec( 250) );
+		pool.interrupt_all_worker();
+		BOOST_CHECK( ! h1.interruption_requested() );
+		BOOST_CHECK( ! h2.interruption_requested() );
+		BOOST_CHECK( ! h3.interruption_requested() );
+		BOOST_CHECK_THROW( h1.get(), tsk::task_interrupted);
+		BOOST_CHECK_THROW( h2.get(), tsk::task_interrupted);
+		BOOST_CHECK_THROW( h3.get(), tsk::task_interrupted);
+		BOOST_CHECK_EQUAL( pool.size(), std::size_t( 5) );
+	}
+
+	// check interrupt_and_wait
+	void test_case_18()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		bool finished( false);
+		tsk::task< void > t( interrupt_fn, pt::seconds( 1), boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		h.interrupt_and_wait();
+		BOOST_CHECK( finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait_for
+	void test_case_19()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		bool finished( false);
+		tsk::task< void > t( interrupt_fn, pt::seconds( 1), boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( h.interrupt_and_wait_for( pt::seconds( 3) ) );
+		BOOST_CHECK( finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait_for
+	void test_case_20()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< void > t( non_interrupt_fn, 3);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( ! h.interrupt_and_wait_for( pt::seconds( 1) ) );
+	}
+
+	// check interrupt_and_wait_until
+	void test_case_21()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 1),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( h.interrupt_and_wait_until( boost::get_system_time() + pt::seconds( 3) ) );
+		BOOST_CHECK( finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait_until
+	void test_case_22()
+	{
+		tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool(
+			tsk::poolsize( 5),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		tsk::task< void > t( non_interrupt_fn, 3);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( ! h.interrupt_and_wait_until( boost::get_system_time() + pt::seconds( 1) ) );
+	}
+
+	// check fifo scheduling
+	void test_case_23()
+	{
+		typedef tsk::static_pool<
+			tsk::bounded_channel< tsk::fifo >
+		> pool_type;
+		BOOST_CHECK( ! tsk::has_attribute< pool_type >::value);
+		pool_type pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		boost::barrier b( 2);
+		std::vector< int > buffer;
+		tsk::task< void > t1( barrier_fn, boost::ref( b) );
+		tsk::task< void > t2(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			10);
+		tsk::task< void > t3(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			0);
+		tsk::async( boost::move( t1), pool);
+		tsk::async( boost::move( t2), pool);
+		tsk::async( boost::move( t3), pool);
+		b.wait();
+		pool.shutdown();
+		BOOST_CHECK_EQUAL( buffer[0], 55);
+		BOOST_CHECK_EQUAL( buffer[1], 0);
+		BOOST_CHECK_EQUAL( buffer.size(), std::size_t( 2) );
+	}
+
+	// check priority scheduling
+	void test_case_24()
+	{
+		typedef tsk::static_pool<
+			tsk::bounded_channel< tsk::priority< int > >
+		> pool_type;
+		BOOST_CHECK( tsk::has_attribute< pool_type >::value);
+		typedef boost::is_same< tsk::attribute_type< pool_type >::type, int > type;
+		BOOST_CHECK( type::value);
+		pool_type pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		boost::barrier b( 2);
+		std::vector< int > buffer;
+		tsk::task< void > t1( barrier_fn, boost::ref( b) );
+		tsk::task< void > t2(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			10);
+		tsk::task< void > t3(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			0);
+		tsk::async( boost::move( t1), 0, pool);
+		tsk::async( boost::move( t2), 1, pool);
+		tsk::async( boost::move( t3), 0, pool);
+		b.wait();
+		pool.shutdown();
+		BOOST_CHECK_EQUAL( buffer[0], 55);
+		BOOST_CHECK_EQUAL( buffer[1], 0);
+		BOOST_CHECK_EQUAL( buffer.size(), std::size_t( 2) );
+	}
+
+	// check smart scheduling
+	void test_case_25()
+	{
+		typedef tsk::static_pool<
+			tsk::bounded_channel< tsk::smart< int, std::less< int >, tsk::replace_oldest, tsk::take_oldest > >
+		> pool_type;
+		BOOST_CHECK( tsk::has_attribute< pool_type >::value);
+		typedef boost::is_same< tsk::attribute_type< pool_type >::type, int > type;
+		BOOST_CHECK( type::value);
+		pool_type pool(
+			tsk::poolsize( 1),
+			tsk::high_watermark( 10),
+			tsk::low_watermark( 10) );
+		boost::barrier b( 2);
+		std::vector< int > buffer;
+		tsk::task< void > t1(
+			barrier_fn,
+			boost::ref( b) );
+		tsk::task< void > t2(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			10);
+		tsk::task< void > t3(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			0);
+		tsk::task< void > t4(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			1);
+		tsk::async( boost::move( t1), 0, pool);
+		tsk::async( boost::move( t2), 2, pool);
+		tsk::async( boost::move( t3), 1, pool);
+		tsk::async( boost::move( t4), 2, pool);
+		b.wait();
+		pool.shutdown();
+		BOOST_CHECK_EQUAL( buffer[0], 0);
+		BOOST_CHECK_EQUAL( buffer[1], 1);
+		BOOST_CHECK_EQUAL( buffer.size(), std::size_t( 2) );
+	}
+};
+
+boost::unit_test::test_suite * init_unit_test_suite( int, char* [])
+{
+	boost::unit_test::test_suite * test( BOOST_TEST_SUITE("Boost.Task: test suite") );
+
+	boost::shared_ptr< test_bounded_pool > instance( new test_bounded_pool() );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_1, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_2, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_3, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_4, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_5, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_6, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_7, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_8, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_9, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_10, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_11, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_12, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_13, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_14, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_15, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_16, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_17, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_18, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_19, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_20, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_21, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_22, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_23, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_24, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_bounded_pool::test_case_25, instance) );
+
+	return test;
+}
+
diff -urN boost/libs/task/test/test_functions.hpp boost-altered/libs/task/test/test_functions.hpp
--- boost/libs/task/test/test_functions.hpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/test/test_functions.hpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,99 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TP_TEST_FUNCTIONS_H
+#define BOOST_TP_TEST_FUNCTIONS_H
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/task/detail/config.hpp>
+
+extern "C"
+{
+#if defined( BOOST_POSIX_API)
+#include <unistd.h>
+# endif
+# if defined( BOOST_WINDOWS_API)
+#include <windows.h>
+# endif
+}
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/function.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/test/auto_unit_test.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/barrier.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task.hpp>
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+void barrier_fn(
+	boost::barrier & b)
+{ b.wait(); }
+
+void delay_fn( pt::time_duration const& td)
+{ boost::this_thread::sleep( td); }
+
+void non_interrupt_fn( int sec)
+{
+# if defined( BOOST_WINDOWS_API)
+	::Sleep( sec * 1000);
+# else
+	::sleep( sec);
+# endif
+}
+
+void interrupt_fn( pt::time_duration const& td, bool & finished)
+{
+	try
+	{ boost::this_thread::sleep( td); }
+	catch (...)
+	{
+		finished = true;
+		throw;
+	}
+}
+
+inline
+int fibonacci_fn( int n)
+{
+	if ( n < 2) return n;
+	int k1( 1), k2( 0);
+	for ( int i( 2); i <= n; ++i)
+	{
+		boost::this_thread::interruption_point();
+		int tmp( k1);
+		k1 = k1 + k2;
+		k2 = tmp;
+	}
+	boost::this_thread::interruption_point();
+	return k1;
+}
+
+inline
+void buffer_fibonacci_fn(
+	std::vector< int > & buffer,
+	int n)
+{ buffer.push_back( fibonacci_fn( n) ); }
+
+inline
+bool runs_in_pool_fn()
+{ return boost::this_task::runs_in_pool(); }
+
+inline
+void throwing_fn()
+{ throw std::runtime_error("exception thrown"); }
+
+#endif // BOOST_TP_TEST_FUNCTIONS_H
diff -urN boost/libs/task/test/test_futures.cpp boost-altered/libs/task/test/test_futures.cpp
--- boost/libs/task/test/test_futures.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/test/test_futures.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,758 @@
+//  (C) Copyright 2008 Anthony Williams 
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+
+#include "boost/thread/thread.hpp"
+#include "boost/thread/mutex.hpp"
+#include "boost/thread/condition.hpp"
+#include "boost/task/future.hpp"
+#include <assert.h>
+#include <utility>
+#include <memory>
+#include <string>
+
+#ifdef BOOST_HAS_RVALUE_REFS
+    template<typename T>
+    typename boost::remove_reference<T>::type&& move(T&& t)
+    {
+        return t;
+    }
+#else
+    template<typename T>
+    boost::detail::thread_move_t<T> move(T& t)
+    {
+        return boost::move(t);
+    }
+#endif
+
+struct X
+{
+private:
+    
+    X(X& other);
+    
+public:
+    
+    int i;
+    
+    X():
+        i(42)
+    {}
+#ifdef BOOST_HAS_RVALUE_REFS
+    X(X&& other):
+        i(other.i)
+    {
+        other.i=0;
+    }
+#else
+    X(boost::detail::thread_move_t<X> other):
+        i(other->i)
+    {
+        other->i=0;
+    }
+    operator boost::detail::thread_move_t<X>()
+    {
+        return boost::detail::thread_move_t<X>(*this);
+    }
+#endif
+    ~X()
+    {}
+};
+
+int make_int()
+{
+    return 42;
+}
+
+int throw_runtime_error()
+{
+    throw std::runtime_error("42");
+}
+
+void set_promise_thread(boost::promise<int>* p)
+{
+    p->set_value(42);
+}
+
+struct my_exception
+{};
+
+void set_promise_exception_thread(boost::promise<int>* p)
+{
+    p->set_exception(boost::copy_exception(my_exception()));
+}
+
+
+void test_store_value_from_thread()
+{
+    boost::promise<int> pi2;
+    boost::unique_future<int> fi2=pi2.get_future();
+    boost::thread(set_promise_thread,&pi2);
+    int j=fi2.get();
+    assert(j==42);
+    assert(fi2.is_ready());
+    assert(fi2.has_value());
+    assert(!fi2.has_exception());
+    assert(fi2.get_state()==boost::future_state::ready);
+}
+
+
+void test_store_exception()
+{
+    boost::promise<int> pi3;
+    boost::unique_future<int> fi3=pi3.get_future();
+    boost::thread(set_promise_exception_thread,&pi3);
+    try
+    {
+        fi3.get();
+        assert(false);
+    }
+    catch(my_exception)
+    {
+        assert(true);
+    }
+    
+    assert(fi3.is_ready());
+    assert(!fi3.has_value());
+    assert(fi3.has_exception());
+    assert(fi3.get_state()==boost::future_state::ready);
+}
+
+void test_initial_state()
+{
+    boost::unique_future<int> fi;
+    assert(!fi.is_ready());
+    assert(!fi.has_value());
+    assert(!fi.has_exception());
+    assert(fi.get_state()==boost::future_state::uninitialized);
+    int i;
+    try
+    {
+        i=fi.get();
+        assert(false);
+    }
+    catch(boost::future_uninitialized)
+    {
+        assert(true);
+    }
+}
+
+void test_waiting_future()
+{
+    boost::promise<int> pi;
+    boost::unique_future<int> fi;
+    fi=pi.get_future();
+
+    int i=0;
+    assert(!fi.is_ready());
+    assert(!fi.has_value());
+    assert(!fi.has_exception());
+    assert(fi.get_state()==boost::future_state::waiting);
+    assert(i==0);
+}
+
+void test_cannot_get_future_twice()
+{
+    boost::promise<int> pi;
+    pi.get_future();
+
+    try
+    {
+        pi.get_future();
+        assert(false);
+    }
+    catch(boost::future_already_retrieved&)
+    {
+        assert(true);
+    }
+}
+
+void test_set_value_updates_future_state()
+{
+    boost::promise<int> pi;
+    boost::unique_future<int> fi;
+    fi=pi.get_future();
+
+    pi.set_value(42);
+    
+    assert(fi.is_ready());
+    assert(fi.has_value());
+    assert(!fi.has_exception());
+    assert(fi.get_state()==boost::future_state::ready);
+}
+
+void test_set_value_can_be_retrieved()
+{
+    boost::promise<int> pi;
+    boost::unique_future<int> fi;
+    fi=pi.get_future();
+
+    pi.set_value(42);
+    
+    int i=0;
+    assert(i=fi.get());
+    assert(i==42);
+    assert(fi.is_ready());
+    assert(fi.has_value());
+    assert(!fi.has_exception());
+    assert(fi.get_state()==boost::future_state::ready);
+}
+
+void test_set_value_can_be_moved()
+{
+//     boost::promise<int> pi;
+//     boost::unique_future<int> fi;
+//     fi=pi.get_future();
+
+//     pi.set_value(42);
+    
+//     int i=0;
+//     assert(i=fi.get());
+//     assert(i==42);
+//     assert(fi.is_ready());
+//     assert(fi.has_value());
+//     assert(!fi.has_exception());
+//     assert(fi.get_state()==boost::future_state::ready);
+}
+
+void test_future_from_packaged_task_is_waiting()
+{
+    boost::packaged_task<int> pt(make_int);
+    boost::unique_future<int> fi=pt.get_future();
+    int i=0;
+    assert(!fi.is_ready());
+    assert(!fi.has_value());
+    assert(!fi.has_exception());
+    assert(fi.get_state()==boost::future_state::waiting);
+    assert(i==0);
+}
+
+void test_invoking_a_packaged_task_populates_future()
+{
+    boost::packaged_task<int> pt(make_int);
+    boost::unique_future<int> fi=pt.get_future();
+
+    pt();
+
+    int i=0;
+    assert(fi.is_ready());
+    assert(fi.has_value());
+    assert(!fi.has_exception());
+    assert(fi.get_state()==boost::future_state::ready);
+    assert(i=fi.get());
+    assert(i==42);
+}
+
+void test_invoking_a_packaged_task_twice_throws()
+{
+    boost::packaged_task<int> pt(make_int);
+
+    pt();
+    try
+    {
+        pt();
+        assert(false);
+    }
+    catch(boost::task_already_started)
+    {
+        assert(true);
+    }
+}
+
+
+void test_cannot_get_future_twice_from_task()
+{
+    boost::packaged_task<int> pt(make_int);
+    pt.get_future();
+    try
+    {
+        pt.get_future();
+        assert(false);
+    }
+    catch(boost::future_already_retrieved)
+    {
+        assert(true);
+    }
+}
+
+void test_task_stores_exception_if_function_throws()
+{
+    boost::packaged_task<int> pt(throw_runtime_error);
+    boost::unique_future<int> fi=pt.get_future();
+
+    pt();
+
+    int i=0;
+    assert(fi.is_ready());
+    assert(!fi.has_value());
+    assert(fi.has_exception());
+    assert(fi.get_state()==boost::future_state::ready);
+    try
+    {
+        fi.get();
+        assert(false);
+    }
+    catch(std::exception&)
+    {
+        assert(true);
+    }
+    catch(...)
+    {
+        assert(!"Unknown exception thrown");
+    }
+    
+}
+
+void test_void_promise()
+{
+    boost::promise<void> p;
+    boost::unique_future<void> f=p.get_future();
+    p.set_value();
+    assert(f.is_ready());
+    assert(f.has_value());
+    assert(!f.has_exception());
+    assert(f.get_state()==boost::future_state::ready);
+    f.get();
+}
+
+void test_reference_promise()
+{
+    boost::promise<int&> p;
+    boost::unique_future<int&> f=p.get_future();
+    int i=42;
+    p.set_value(i);
+    assert(f.is_ready());
+    assert(f.has_value());
+    assert(!f.has_exception());
+    assert(f.get_state()==boost::future_state::ready);
+    assert(&f.get()==&i);
+}
+
+void do_nothing()
+{}
+
+void test_task_returning_void()
+{
+    boost::packaged_task<void> pt(do_nothing);
+    boost::unique_future<void> fi=pt.get_future();
+
+    pt();
+
+    assert(fi.is_ready());
+    assert(fi.has_value());
+    assert(!fi.has_exception());
+    assert(fi.get_state()==boost::future_state::ready);
+}
+
+int global_ref_target=0;
+
+int& return_ref()
+{
+    return global_ref_target;
+}
+
+void test_task_returning_reference()
+{
+    boost::packaged_task<int&> pt(return_ref);
+    boost::unique_future<int&> fi=pt.get_future();
+
+    pt();
+
+    assert(fi.is_ready());
+    assert(fi.has_value());
+    assert(!fi.has_exception());
+    assert(fi.get_state()==boost::future_state::ready);
+    int& i=fi.get();
+    assert(&i==&global_ref_target);
+}
+
+void test_shared_future()
+{
+    boost::packaged_task<int> pt(make_int);
+    boost::unique_future<int> fi=pt.get_future();
+
+    boost::shared_future<int> sf(boost::move(fi));
+    assert(fi.get_state()==boost::future_state::uninitialized);
+
+    pt();
+
+    int i=0;
+    assert(sf.is_ready());
+    assert(sf.has_value());
+    assert(!sf.has_exception());
+    assert(sf.get_state()==boost::future_state::ready);
+    assert(i=sf.get());
+    assert(i==42);
+}
+
+void test_copies_of_shared_future_become_ready_together()
+{
+    boost::packaged_task<int> pt(make_int);
+    boost::unique_future<int> fi=pt.get_future();
+
+    boost::shared_future<int> sf(boost::move(fi));
+    boost::shared_future<int> sf2(sf);
+    boost::shared_future<int> sf3;
+    sf3=sf;
+    assert(sf.get_state()==boost::future_state::waiting);
+    assert(sf2.get_state()==boost::future_state::waiting);
+    assert(sf3.get_state()==boost::future_state::waiting);
+
+    pt();
+
+    int i=0;
+    assert(sf.is_ready());
+    assert(sf.has_value());
+    assert(!sf.has_exception());
+    assert(sf.get_state()==boost::future_state::ready);
+    assert(i=sf.get());
+    assert(i==42);
+    i=0;
+    assert(sf2.is_ready());
+    assert(sf2.has_value());
+    assert(!sf2.has_exception());
+    assert(sf2.get_state()==boost::future_state::ready);
+    assert(i=sf2.get());
+    assert(i==42);
+    i=0;
+    assert(sf3.is_ready());
+    assert(sf3.has_value());
+    assert(!sf3.has_exception());
+    assert(sf3.get_state()==boost::future_state::ready);
+    assert(i=sf3.get());
+    assert(i==42);
+}
+
+void test_shared_future_can_be_move_assigned_from_unique_future()
+{
+    boost::packaged_task<int> pt(make_int);
+    boost::unique_future<int> fi=pt.get_future();
+
+    boost::shared_future<int> sf;
+    sf=boost::move(fi);
+    assert(fi.get_state()==boost::future_state::uninitialized);
+
+    int i=0;
+    assert(!sf.is_ready());
+    assert(!sf.has_value());
+    assert(!sf.has_exception());
+    assert(sf.get_state()==boost::future_state::waiting);
+}
+
+void test_shared_future_void()
+{
+    boost::packaged_task<void> pt(do_nothing);
+    boost::unique_future<void> fi=pt.get_future();
+
+    boost::shared_future<void> sf(boost::move(fi));
+    assert(fi.get_state()==boost::future_state::uninitialized);
+
+    pt();
+
+    assert(sf.is_ready());
+    assert(sf.has_value());
+    assert(!sf.has_exception());
+    assert(sf.get_state()==boost::future_state::ready);
+    sf.get();
+}
+
+void test_shared_future_ref()
+{
+    boost::promise<int&> p;
+    boost::shared_future<int&> f(p.get_future());
+    int i=42;
+    p.set_value(i);
+    assert(f.is_ready());
+    assert(f.has_value());
+    assert(!f.has_exception());
+    assert(f.get_state()==boost::future_state::ready);
+    assert(&f.get()==&i);
+}
+
+void test_can_get_a_second_future_from_a_moved_promise()
+{
+    boost::promise<int> pi;
+    boost::unique_future<int> fi=pi.get_future();
+    
+    boost::promise<int> pi2(boost::move(pi));
+    boost::unique_future<int> fi2=pi.get_future();
+
+    pi2.set_value(3);
+    assert(fi.is_ready());
+    assert(!fi2.is_ready());
+    assert(fi.get()==3);
+    pi.set_value(42);
+    assert(fi2.is_ready());
+    assert(fi2.get()==42);
+}
+
+void test_can_get_a_second_future_from_a_moved_void_promise()
+{
+    boost::promise<void> pi;
+    boost::unique_future<void> fi=pi.get_future();
+    
+    boost::promise<void> pi2(boost::move(pi));
+    boost::unique_future<void> fi2=pi.get_future();
+
+    pi2.set_value();
+    assert(fi.is_ready());
+    assert(!fi2.is_ready());
+    pi.set_value();
+    assert(fi2.is_ready());
+}
+
+void test_unique_future_for_move_only_udt()
+{
+    boost::promise<X> pt;
+    boost::unique_future<X> fi=pt.get_future();
+
+    pt.set_value(X());
+    X res(fi.get());
+    assert(res.i==42);
+}
+
+void test_unique_future_for_string()
+{
+    boost::promise<std::string> pt;
+    boost::unique_future<std::string> fi=pt.get_future();
+
+    pt.set_value(std::string("hello"));
+    std::string res(fi.get());
+    assert(res=="hello");
+
+    boost::promise<std::string> pt2;
+    fi=pt2.get_future();
+
+    std::string const s="goodbye";
+    
+    pt2.set_value(s);
+    res=fi.get();
+    assert(res=="goodbye");
+
+    boost::promise<std::string> pt3;
+    fi=pt3.get_future();
+
+    std::string s2="foo";
+    
+    pt3.set_value(s2);
+    res=fi.get();
+    assert(res=="foo");
+}
+
+boost::mutex callback_mutex;
+unsigned callback_called=0;
+
+void wait_callback(boost::promise<int>& pi)
+{
+    boost::lock_guard<boost::mutex> lk(callback_mutex);
+    ++callback_called;
+    try
+    {
+        pi.set_value(42);
+    }
+    catch(...)
+    {
+    }
+}
+
+void do_nothing_callback(boost::promise<int>& pi)
+{
+    boost::lock_guard<boost::mutex> lk(callback_mutex);
+    ++callback_called;
+}
+
+void test_wait_callback()
+{
+    callback_called=0;
+    boost::promise<int> pi;
+    boost::unique_future<int> fi=pi.get_future();
+    pi.set_wait_callback(wait_callback);
+    fi.wait();
+    assert(callback_called);
+    assert(fi.get()==42);
+    fi.wait();
+    fi.wait();
+    assert(callback_called==1);
+}
+
+void test_wait_callback_with_timed_wait()
+{
+    callback_called=0;
+    boost::promise<int> pi;
+    boost::unique_future<int> fi=pi.get_future();
+    pi.set_wait_callback(do_nothing_callback);
+    bool success=fi.timed_wait(boost::posix_time::milliseconds(10));
+    assert(callback_called);
+    assert(!success);
+    success=fi.timed_wait(boost::posix_time::milliseconds(10));
+    assert(!success);
+    success=fi.timed_wait(boost::posix_time::milliseconds(10));
+    assert(!success);
+    assert(callback_called==3);
+    pi.set_value(42);
+    success=fi.timed_wait(boost::posix_time::milliseconds(10));
+    assert(success);
+    assert(callback_called==3);
+    assert(fi.get()==42);
+    assert(callback_called==3);
+}
+
+void test_wait_callback_with_timed_wait_until()
+{
+    callback_called=0;
+    boost::promise<int> pi;
+    boost::unique_future<int> fi=pi.get_future();
+    pi.set_wait_callback(do_nothing_callback);
+    bool success=fi.timed_wait_until(boost::get_system_time() + boost::posix_time::milliseconds(10));
+    assert(callback_called);
+    assert(!success);
+    success=fi.timed_wait_until(boost::get_system_time() + boost::posix_time::milliseconds(10));
+    assert(!success);
+    success=fi.timed_wait_until(boost::get_system_time() + boost::posix_time::milliseconds(10));
+    assert(!success);
+    assert(callback_called==3);
+    pi.set_value(42);
+    success=fi.timed_wait_until(boost::get_system_time() + boost::posix_time::milliseconds(10));
+    assert(success);
+    assert(callback_called==3);
+    assert(fi.get()==42);
+    assert(callback_called==3);
+}
+
+
+void wait_callback_for_task(boost::packaged_task<int>& pt)
+{
+    boost::lock_guard<boost::mutex> lk(callback_mutex);
+    ++callback_called;
+    try
+    {
+        pt();
+    }
+    catch(...)
+    {
+    }
+}
+
+
+void test_wait_callback_for_packaged_task()
+{
+    callback_called=0;
+    boost::packaged_task<int> pt(make_int);
+    boost::unique_future<int> fi=pt.get_future();
+    pt.set_wait_callback(wait_callback_for_task);
+    fi.wait();
+    assert(callback_called);
+    assert(fi.get()==42);
+    fi.wait();
+    fi.wait();
+    assert(callback_called==1);
+}
+
+void test_packaged_task_can_be_moved()
+{
+    boost::packaged_task<int> pt(make_int);
+
+    boost::unique_future<int> fi=pt.get_future();
+
+    assert(!fi.is_ready());
+    
+    boost::packaged_task<int> pt2=boost::move(pt);
+    assert(!fi.is_ready());
+    try
+    {
+        pt();
+        assert(!"Can invoke moved task!");
+    }
+    catch(boost::task_moved&)
+    {
+    }
+
+    assert(!fi.is_ready());
+
+    pt2();
+    
+    assert(fi.is_ready());
+}
+
+void test_destroying_a_promise_stores_broken_promise()
+{
+    boost::unique_future<int> f;
+    
+    {
+        boost::promise<int> p;
+        f=p.get_future();
+    }
+    assert(f.is_ready());
+    assert(f.has_exception());
+    try
+    {
+        f.get();
+    }
+    catch(boost::broken_promise&)
+    {
+    }
+}
+
+void test_destroying_a_packaged_task_stores_broken_promise()
+{
+    boost::unique_future<int> f;
+    
+    {
+        boost::packaged_task<int> p(make_int);
+        f=p.get_future();
+    }
+    assert(f.is_ready());
+    assert(f.has_exception());
+    try
+    {
+        f.get();
+    }
+    catch(boost::broken_promise&)
+    {
+    }
+}
+
+int make_int_slowly()
+{
+    boost::this_thread::sleep(boost::posix_time::seconds(1));
+    return 42;
+}
+
+int main()
+{
+    test_initial_state();
+    test_waiting_future();
+    test_cannot_get_future_twice();
+   test_set_value_updates_future_state();
+   test_set_value_can_be_retrieved();
+   test_set_value_can_be_moved();
+   test_store_value_from_thread();
+   test_store_exception();
+   test_future_from_packaged_task_is_waiting();
+   test_invoking_a_packaged_task_populates_future();
+   test_invoking_a_packaged_task_twice_throws();
+   test_cannot_get_future_twice_from_task();
+   test_task_stores_exception_if_function_throws();
+   test_void_promise();
+   test_reference_promise();
+   test_task_returning_void();
+   test_task_returning_reference();
+   test_shared_future();
+   test_copies_of_shared_future_become_ready_together();
+  test_shared_future_can_be_move_assigned_from_unique_future();
+  test_shared_future_void();
+  test_shared_future_ref();
+   test_can_get_a_second_future_from_a_moved_promise();
+   test_can_get_a_second_future_from_a_moved_void_promise();
+   test_unique_future_for_move_only_udt();
+   test_unique_future_for_string();
+   test_wait_callback();
+   test_wait_callback_with_timed_wait();
+   test_wait_callback_with_timed_wait_until();
+   test_wait_callback_for_packaged_task();
+   test_packaged_task_can_be_moved();
+   test_destroying_a_promise_stores_broken_promise();
+   test_destroying_a_packaged_task_stores_broken_promise();
+}
diff -urN boost/libs/task/test/test_new_thread.cpp boost-altered/libs/task/test/test_new_thread.cpp
--- boost/libs/task/test/test_new_thread.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/test/test_new_thread.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,290 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/function.hpp>
+#include <boost/ref.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/barrier.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task.hpp>
+
+#include "test_functions.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+class test_new_thread
+{
+public:
+	// check assignment
+	void test_case_1()
+	{
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h1;
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		h1 = h2;
+		BOOST_CHECK_EQUAL( h1.get(), 55);
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+	}
+
+	// check swap
+	void test_case_2()
+	{
+		tsk::task< int > t1( fibonacci_fn, 5);
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::handle< int > h1(
+			tsk::async( boost::move( t1), tsk::new_thread() ) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), tsk::new_thread() ) );
+		BOOST_CHECK_EQUAL( h1.get(), 5);
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+		BOOST_CHECK_NO_THROW( h1.swap( h2) );
+		BOOST_CHECK_EQUAL( h1.get(), 55);
+		BOOST_CHECK_EQUAL( h2.get(), 5);
+	}
+
+	// check runs not in pool
+	void test_case_3()
+	{
+		tsk::task< bool > t( runs_in_pool_fn);
+		tsk::handle< bool > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK_EQUAL( h.get(), false);
+	}
+
+	// check runtime_error throw inside task
+	void test_case_4()
+	{
+		tsk::task< void > t( throwing_fn);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK_THROW( h.get(), std::runtime_error);
+	}
+
+	// check wait
+	void test_case_5()
+	{
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		h.wait();
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check wait_for
+	void test_case_6()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 1) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK( h.wait_for( pt::seconds( 3) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_7()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK( ! h.wait_for( pt::seconds( 1) ) );
+		BOOST_CHECK( ! h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_8()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 1) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK( h.wait_until( boost::get_system_time() + pt::seconds( 3) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_9()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK( ! h.wait_until( boost::get_system_time() + pt::seconds( 1) ) );
+		BOOST_CHECK( ! h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check interrupt
+	void test_case_10()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		h.interrupt();
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait
+	void test_case_11()
+	{
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 1),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		h.interrupt_and_wait();
+		BOOST_CHECK( finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait_for
+	void test_case_12()
+	{
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 1),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK( h.interrupt_and_wait_for( pt::seconds( 3) ) );
+		BOOST_CHECK( finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait_for
+	void test_case_13()
+	{
+		tsk::task< void > t( non_interrupt_fn, 3);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK( ! h.interrupt_and_wait_for( pt::seconds( 1) ) );
+	}
+
+	// check interrupt_and_wait_until
+	void test_case_14()
+	{
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 1),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK( h.interrupt_and_wait_until( boost::get_system_time() + pt::seconds( 3) ) );
+		BOOST_CHECK( finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait_until
+	void test_case_15()
+	{
+		tsk::task< void > t( non_interrupt_fn, 3);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::new_thread() ) );
+		BOOST_CHECK( ! h.interrupt_and_wait_until( boost::get_system_time() + pt::seconds( 1) ) );
+	}
+
+	// check waitfor_all()
+	void test_case_16()
+	{
+		std::vector< tsk::handle< int > > vec;
+		for ( int i = 0; i <= 5; ++i)
+		{
+			tsk::task< int > t( fibonacci_fn, i);
+			vec.push_back(
+				tsk::async( boost::move( t), tsk::new_thread() ) );
+		}
+		tsk::waitfor_all( vec.begin(), vec.end() );
+		BOOST_CHECK( vec[0].is_ready() );
+		BOOST_CHECK( vec[1].is_ready() );
+		BOOST_CHECK( vec[2].is_ready() );
+		BOOST_CHECK( vec[3].is_ready() );
+		BOOST_CHECK( vec[4].is_ready() );
+		BOOST_CHECK( vec[5].is_ready() );
+		BOOST_CHECK_EQUAL( vec[0].get(), 0);
+		BOOST_CHECK_EQUAL( vec[1].get(), 1);
+		BOOST_CHECK_EQUAL( vec[2].get(), 1);
+		BOOST_CHECK_EQUAL( vec[3].get(), 2);
+		BOOST_CHECK_EQUAL( vec[4].get(), 3);
+		BOOST_CHECK_EQUAL( vec[5].get(), 5);
+	}
+
+	// check waitfor_any()
+	void test_case_17()
+	{
+		tsk::task< void > t1( delay_fn, pt::seconds( 3) );
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::handle< void > h1(
+			tsk::async( boost::move( t1), tsk::new_thread() ) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), tsk::new_thread() ) );
+		tsk::waitfor_any( h1, h2);
+		BOOST_CHECK( ! h1.is_ready() );
+		BOOST_CHECK( h2.is_ready() );
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+	}
+};
+
+boost::unit_test::test_suite * init_unit_test_suite( int, char* [])
+{
+	boost::unit_test::test_suite * test( BOOST_TEST_SUITE("Boost.Task: test suite") );
+
+	boost::shared_ptr< test_new_thread > instance( new test_new_thread() );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_1, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_2, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_3, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_4, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_5, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_6, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_7, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_8, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_9, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_10, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_11, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_12, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_13, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_14, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_15, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_16, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_new_thread::test_case_17, instance) );
+
+	return test;
+}
diff -urN boost/libs/task/test/test_own_thread.cpp boost-altered/libs/task/test/test_own_thread.cpp
--- boost/libs/task/test/test_own_thread.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/test/test_own_thread.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,318 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/function.hpp>
+#include <boost/ref.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/barrier.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task.hpp>
+
+#include "test_functions.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+class test_own_thread
+{
+public:
+	// check assignment
+	void test_case_1()
+	{
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h1;
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		h1 = h2;
+		BOOST_CHECK_EQUAL( h1.get(), 55);
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+	}
+
+	// check swap
+	void test_case_2()
+	{
+		tsk::task< int > t1( fibonacci_fn, 5);
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::handle< int > h1(
+			tsk::async( boost::move( t1), tsk::own_thread() ) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), tsk::own_thread() ) );
+		BOOST_CHECK_EQUAL( h1.get(), 5);
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+		BOOST_CHECK_NO_THROW( h1.swap( h2) );
+		BOOST_CHECK_EQUAL( h1.get(), 55);
+		BOOST_CHECK_EQUAL( h2.get(), 5);
+	}
+
+	// check runs not in pool
+	void test_case_3()
+	{
+		tsk::task< bool > t( runs_in_pool_fn);
+		tsk::handle< bool > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK_EQUAL( h.get(), false);
+	}
+
+	// check runtime_error throw inside task
+	void test_case_4()
+	{
+		tsk::task< void > t( throwing_fn);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK_THROW( h.get(), std::runtime_error);
+	}
+
+	// check task_uninitialized
+	void test_case_5()
+	{
+		tsk::handle< int > h;
+		BOOST_CHECK_THROW( h.get(), tsk::task_uninitialized);
+		BOOST_CHECK_THROW( h.wait(), tsk::task_uninitialized);
+		BOOST_CHECK_THROW( h.wait_for( pt::seconds( 1) ), tsk::task_uninitialized);
+		BOOST_CHECK_THROW(
+			h.wait_until( boost::get_system_time() + pt::seconds( 1) ),
+			tsk::task_uninitialized);
+		BOOST_CHECK( ! h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait
+	void test_case_6()
+	{
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		h.wait();
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check wait_for
+	void test_case_7()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 1) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK( h.wait_for( pt::seconds( 2) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_8()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 2) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK( h.wait_for( pt::seconds( 1) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_9()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 1) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK( h.wait_until( boost::get_system_time() + pt::seconds( 3) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_10()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 2) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK( h.wait_until( boost::get_system_time() + pt::seconds( 1) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check interrupt
+	void test_case_11()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		h.interrupt();
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_NO_THROW( h.get() );
+	}
+
+	// check interrupt_and_wait
+	void test_case_12()
+	{
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 3),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		h.interrupt_and_wait();
+		BOOST_CHECK( ! finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_NO_THROW( h.get() );
+	}
+
+	// check interrupt_and_wait_for
+	void test_case_13()
+	{
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 1),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK( h.interrupt_and_wait_for( pt::seconds( 2) ) );
+		BOOST_CHECK( ! finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_NO_THROW( h.get() );
+	}
+
+	// check interrupt_and_wait_for
+	void test_case_14()
+	{
+		tsk::task< void > t( non_interrupt_fn, 2);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK( h.interrupt_and_wait_for( pt::seconds( 1) ) );
+		BOOST_CHECK_NO_THROW( h.get() );
+	}
+
+	// check interrupt_and_wait_until
+	void test_case_15()
+	{
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 1),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK( h.interrupt_and_wait_until( boost::get_system_time() + pt::seconds( 2) ) );
+		BOOST_CHECK( ! finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_NO_THROW( h.get() );
+	}
+
+	// check interrupt_and_wait_until
+	void test_case_16()
+	{
+		tsk::task< void > t( non_interrupt_fn, 2);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		BOOST_CHECK( h.interrupt_and_wait_until( boost::get_system_time() + pt::seconds( 1) ) );
+		BOOST_CHECK_NO_THROW( h.get() );
+	}
+
+	// check waitfor_all()
+	void test_case_17()
+	{
+		std::vector< tsk::handle< int > > vec;
+		for ( int i = 0; i <= 5; ++i)
+		{
+			tsk::task< int > t( fibonacci_fn, i);
+			vec.push_back(
+				tsk::async( boost::move( t), tsk::own_thread() ) );
+		}
+		tsk::waitfor_all( vec.begin(), vec.end() );
+		BOOST_CHECK( vec[0].is_ready() );
+		BOOST_CHECK( vec[1].is_ready() );
+		BOOST_CHECK( vec[2].is_ready() );
+		BOOST_CHECK( vec[3].is_ready() );
+		BOOST_CHECK( vec[4].is_ready() );
+		BOOST_CHECK( vec[5].is_ready() );
+		BOOST_CHECK_EQUAL( vec[0].get(), 0);
+		BOOST_CHECK_EQUAL( vec[1].get(), 1);
+		BOOST_CHECK_EQUAL( vec[2].get(), 1);
+		BOOST_CHECK_EQUAL( vec[3].get(), 2);
+		BOOST_CHECK_EQUAL( vec[4].get(), 3);
+		BOOST_CHECK_EQUAL( vec[5].get(), 5);
+	}
+
+	// check waitfor_any()
+	void test_case_18()
+	{
+		tsk::task< void > t1( delay_fn, pt::seconds( 3) );
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::handle< void > h1(
+			tsk::async( boost::move( t1), tsk::own_thread() ) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), tsk::own_thread() ) );
+		tsk::waitfor_any( h1, h2);
+		BOOST_CHECK( h1.is_ready() );
+		BOOST_CHECK( h2.is_ready() );
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+	}
+
+	// check interrupt + wait
+	void test_case_19()
+	{
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), tsk::own_thread() ) );
+		h.interrupt();
+		BOOST_CHECK_NO_THROW( h.wait() );
+		BOOST_CHECK_NO_THROW( h.get() );
+	}
+};
+
+boost::unit_test::test_suite * init_unit_test_suite( int, char* [])
+{
+	boost::unit_test::test_suite * test( BOOST_TEST_SUITE("Boost.Task: test suite") );
+
+	boost::shared_ptr< test_own_thread > instance( new test_own_thread() );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_1, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_2, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_3, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_4, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_5, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_6, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_7, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_8, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_9, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_10, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_11, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_12, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_13, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_14, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_15, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_16, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_17, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_18, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_own_thread::test_case_19, instance) );
+
+	return test;
+}
diff -urN boost/libs/task/test/test_task.cpp boost-altered/libs/task/test/test_task.cpp
--- boost/libs/task/test/test_task.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/test/test_task.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,84 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/function.hpp>
+#include <boost/ref.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/barrier.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task.hpp>
+
+#include "test_functions.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+class test_task
+{
+public:
+	// check vaild task
+	void test_case_1()
+	{
+		tsk::task< int > t1( fibonacci_fn, 10);
+		tsk::task< int > t2;
+		BOOST_CHECK( t1);
+		BOOST_CHECK( ! t2);
+	}
+
+	// check moved task
+	void test_case_2()
+	{
+		tsk::task< int > t1( fibonacci_fn, 10);
+		BOOST_CHECK( t1);
+		tsk::task< int > t2( boost::move( t1) );
+		BOOST_CHECK( ! t1);
+		BOOST_CHECK_THROW( t1(), tsk::task_moved);
+		BOOST_CHECK_NO_THROW( t2() );
+	}
+
+	// check execute twice
+	void test_case_3()
+	{
+		tsk::task< int > t1( fibonacci_fn, 10);
+		BOOST_CHECK_NO_THROW( t1() );
+		BOOST_CHECK_THROW( t1(), tsk::task_already_executed);
+	}
+
+	// check swap
+	void test_case_4()
+	{
+		tsk::task< int > t1( fibonacci_fn, 10);
+		tsk::task< int > t2;
+		BOOST_CHECK_NO_THROW( t1() );
+		BOOST_CHECK_THROW( t2(), tsk::task_moved);
+		t1.swap( t2);
+		BOOST_CHECK_THROW( t1(), tsk::task_moved);
+		BOOST_CHECK_THROW( t2(), tsk::task_already_executed);
+	}
+};
+
+boost::unit_test::test_suite * init_unit_test_suite( int, char* [])
+{
+	boost::unit_test::test_suite * test( BOOST_TEST_SUITE("Boost.Task: test suite") );
+
+	boost::shared_ptr< test_task > instance( new test_task() );
+	test->add( BOOST_CLASS_TEST_CASE( & test_task::test_case_1, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_task::test_case_2, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_task::test_case_3, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_task::test_case_4, instance) );
+
+	return test;
+}
diff -urN boost/libs/task/test/test_unbounded_pool.cpp boost-altered/libs/task/test/test_unbounded_pool.cpp
--- boost/libs/task/test/test_unbounded_pool.cpp	1969-12-31 16:00:00.000000000 -0800
+++ boost-altered/libs/task/test/test_unbounded_pool.cpp	2009-06-30 17:52:18.000000000 -0700
@@ -0,0 +1,553 @@
+
+//          Copyright Oliver Kowalke 2009.
+// Distributed under the Boost Software License, Version 1.0.
+//    (See accompanying file LICENSE_1_0.txt or copy at
+//          http://www.boost.org/LICENSE_1_0.txt)
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <stdexcept>
+#include <vector>
+
+#include <boost/bind.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <boost/function.hpp>
+#include <boost/ref.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/barrier.hpp>
+#include <boost/type_traits/is_same.hpp>
+#include <boost/utility.hpp>
+
+#include <boost/task.hpp>
+
+#include "test_functions.hpp"
+
+namespace pt = boost::posix_time;
+namespace tsk = boost::task;
+
+class test_unbounded_pool
+{
+public:
+	// check size, active, idle
+	void test_case_1()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool1( tsk::poolsize( 3) );
+		BOOST_CHECK( pool1);
+		BOOST_CHECK_EQUAL( pool1.size(), std::size_t( 3) );
+		BOOST_CHECK_EQUAL( pool1.idle(), std::size_t( 3) );
+		BOOST_CHECK_EQUAL( pool1.active(), std::size_t( 0) );
+
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool2;
+		BOOST_CHECK( ! pool2);
+		BOOST_CHECK_THROW( pool2.size(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool2.idle(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool2.active(), tsk::pool_moved);
+
+		pool2 = boost::move( pool1);
+
+		BOOST_CHECK( ! pool1);
+		BOOST_CHECK_THROW( pool1.size(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool1.idle(), tsk::pool_moved);
+		BOOST_CHECK_THROW( pool1.active(), tsk::pool_moved);
+
+		BOOST_CHECK( pool2);
+		BOOST_CHECK_EQUAL( pool2.size(), std::size_t( 3) );
+		BOOST_CHECK_EQUAL( pool2.idle(), std::size_t( 3) );
+		BOOST_CHECK_EQUAL( pool2.active(), std::size_t( 0) );
+
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), pool2) );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check submit
+	void test_case_2()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check assignment
+	void test_case_3()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h1;
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t), pool) );
+		h1 = h2;
+		BOOST_CHECK_EQUAL( h1.get(), 55);
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+	}
+
+	// check swap
+	void test_case_4()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< int > t1( fibonacci_fn, 5);
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::handle< int > h1(
+			tsk::async( boost::move( t1), pool) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), pool) );
+		BOOST_CHECK_EQUAL( h1.get(), 5);
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+		BOOST_CHECK_NO_THROW( h1.swap( h2) );
+		BOOST_CHECK_EQUAL( h1.get(), 55);
+		BOOST_CHECK_EQUAL( h2.get(), 5);
+	}
+
+	// check runs in pool
+	void test_case_5()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 1) );
+		tsk::task< bool > t( runs_in_pool_fn);
+		tsk::handle< bool > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK_EQUAL( h.get(), true);
+	}
+
+	// check shutdown
+	void test_case_6()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 1) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), pool) );
+		pool.shutdown();
+		BOOST_CHECK( pool.closed() );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check runtime_error throw inside task
+	void test_case_7()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 1) );
+		tsk::task< void > t( throwing_fn);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		pool.shutdown();
+		BOOST_CHECK_THROW( h.get(), std::runtime_error);
+	}
+
+	// check shutdown with task_rejected exception
+	void test_case_8()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 1) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		pool.shutdown();
+		BOOST_CHECK( pool.closed() );
+		BOOST_CHECK_THROW(
+			tsk::async( boost::move( t), pool),
+			tsk::task_rejected);
+	}
+
+	// check shutdown_now with thread_interrupted exception
+	void test_case_9()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 1) );
+		tsk::task< void > t( delay_fn, pt::millisec( 500) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		boost::this_thread::sleep( pt::millisec( 250) );
+		BOOST_CHECK_EQUAL( pool.size(), std::size_t( 1) );
+		pool.shutdown_now();
+		BOOST_CHECK( pool.closed() );
+		BOOST_CHECK_EQUAL( pool.size(), std::size_t( 1) );
+		BOOST_CHECK_EQUAL( pool.idle(), std::size_t( 1) );
+		BOOST_CHECK_EQUAL( pool.active(), std::size_t( 0) );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check pending
+	void test_case_10()
+	{
+		typedef tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool_type;
+		pool_type pool( tsk::poolsize( 1) );
+		boost::barrier b( 2);
+		tsk::task< void > t1( barrier_fn, boost::ref( b) );
+		tsk::task< int > t2( fibonacci_fn, 10);
+		tsk::task< int > t3( fibonacci_fn, 10);
+		tsk::handle< void > h1(
+			tsk::async( boost::move( t1), pool) );
+		boost::this_thread::sleep( pt::millisec( 250) );
+		BOOST_CHECK_EQUAL( pool.pending(), std::size_t( 0) );
+		tsk::handle< int > h2(
+			tsk::async( boost::move( t2), pool) );
+		boost::this_thread::sleep( pt::millisec(250) );
+		BOOST_CHECK_EQUAL( pool.pending(), std::size_t( 1) );
+		tsk::handle< int > h3(
+			tsk::async( boost::move( t3), pool) );
+		boost::this_thread::sleep( pt::millisec(250) );
+		BOOST_CHECK_EQUAL( pool.pending(), std::size_t( 2) );
+		b.wait();
+		h1.get();
+		BOOST_CHECK_EQUAL( h2.get(), 55);
+		BOOST_CHECK_EQUAL( h3.get(), 55);
+		BOOST_CHECK_EQUAL( pool.pending(), std::size_t( 0) );
+	}
+
+	// check wait
+	void test_case_11()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< int > t( fibonacci_fn, 10);
+		tsk::handle< int > h(
+			tsk::async( boost::move( t), pool) );
+		h.wait();
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+		BOOST_CHECK_EQUAL( h.get(), 55);
+	}
+
+	// check wait_for
+	void test_case_12()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< void > t( delay_fn, pt::seconds( 1) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( h.wait_for( pt::seconds( 3) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_for
+	void test_case_13()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( ! h.wait_for( pt::seconds( 1) ) );
+		BOOST_CHECK( ! h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_until
+	void test_case_14()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< void > t( delay_fn, pt::seconds( 1) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( h.wait_until( boost::get_system_time() + pt::seconds( 3) ) );
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check wait_until
+	void test_case_15()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( ! h.wait_until( boost::get_system_time() + pt::seconds( 1) ) );
+		BOOST_CHECK( ! h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( ! h.has_exception() );
+	}
+
+	// check interrupt
+	void test_case_16()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< void > t( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		h.interrupt();
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_all_worker
+	void test_case_17()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 5) );
+		tsk::task< void > t1( delay_fn, pt::seconds( 3) );
+		tsk::task< void > t2( delay_fn, pt::seconds( 3) );
+		tsk::task< void > t3( delay_fn, pt::seconds( 3) );
+		tsk::handle< void > h1(
+			tsk::async( boost::move( t1), pool) );
+		tsk::handle< void > h2(
+			tsk::async( boost::move( t2), pool) );
+		tsk::handle< void > h3(
+			tsk::async( boost::move( t3), pool) );
+		boost::this_thread::sleep( pt::millisec( 250) );
+		pool.interrupt_all_worker();
+		BOOST_CHECK( ! h1.interruption_requested() );
+		BOOST_CHECK( ! h2.interruption_requested() );
+		BOOST_CHECK( ! h3.interruption_requested() );
+		BOOST_CHECK_THROW( h1.get(), tsk::task_interrupted);
+		BOOST_CHECK_THROW( h2.get(), tsk::task_interrupted);
+		BOOST_CHECK_THROW( h3.get(), tsk::task_interrupted);
+		BOOST_CHECK_EQUAL( pool.size(), std::size_t( 5) );
+	}
+
+	// check interrupt_and_wait
+	void test_case_18()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 1),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		h.interrupt_and_wait();
+		BOOST_CHECK( finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait_for
+	void test_case_19()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 1),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( h.interrupt_and_wait_for( pt::seconds( 3) ) );
+		BOOST_CHECK( finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait_for
+	void test_case_20()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< void > t( non_interrupt_fn, 3);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( ! h.interrupt_and_wait_for( pt::seconds( 1) ) );
+	}
+
+	// check interrupt_and_wait_until
+	void test_case_21()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		bool finished( false);
+		tsk::task< void > t(
+			interrupt_fn,
+			pt::seconds( 1),
+			boost::ref( finished) );
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( h.interrupt_and_wait_until( boost::get_system_time() + pt::seconds( 3) ) );
+		BOOST_CHECK( finished);
+		BOOST_CHECK( h.is_ready() );
+		BOOST_CHECK( ! h.has_value() );
+		BOOST_CHECK( h.has_exception() );
+		BOOST_CHECK( h.interruption_requested() );
+		BOOST_CHECK_THROW( h.get(), tsk::task_interrupted);
+	}
+
+	// check interrupt_and_wait_until
+	void test_case_22()
+	{
+		tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool( tsk::poolsize( 3) );
+		tsk::task< void > t( non_interrupt_fn, 3);
+		tsk::handle< void > h(
+			tsk::async( boost::move( t), pool) );
+		BOOST_CHECK( ! h.interrupt_and_wait_until( boost::get_system_time() + pt::seconds( 1) ) );
+	}
+
+	// check fifo scheduling
+	void test_case_23()
+	{
+		typedef tsk::static_pool<
+			tsk::unbounded_channel< tsk::fifo >
+		> pool_type;
+		BOOST_CHECK( ! tsk::has_attribute< pool_type >::value);
+		pool_type pool( tsk::poolsize( 1) );
+		boost::barrier b( 2);
+		std::vector< int > buffer;
+		tsk::task< void > t1( barrier_fn, boost::ref( b) );
+		tsk::task< void > t2(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			10);
+		tsk::task< void > t3(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			0);
+		tsk::async( boost::move( t1), pool);
+		tsk::async( boost::move( t2), pool);
+		tsk::async( boost::move( t3), pool);
+		b.wait();
+		pool.shutdown();
+		BOOST_CHECK_EQUAL( buffer[0], 55);
+		BOOST_CHECK_EQUAL( buffer[1], 0);
+		BOOST_CHECK_EQUAL( buffer.size(), std::size_t( 2) );
+	}
+
+	// check priority scheduling
+	void test_case_24()
+	{
+		typedef tsk::static_pool<
+			tsk::unbounded_channel< tsk::priority< int > >
+		> pool_type;
+		BOOST_CHECK( tsk::has_attribute< pool_type >::value);
+		typedef boost::is_same< tsk::attribute_type< pool_type >::type, int > type;
+		BOOST_CHECK( type::value);
+		pool_type pool( tsk::poolsize( 1) );
+		boost::barrier b( 2);
+		std::vector< int > buffer;
+		tsk::task< void > t1( barrier_fn, boost::ref( b) );
+		tsk::task< void > t2(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			10) ;
+		tsk::task< void > t3(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			0);
+		tsk::async( boost::move( t1), 0, pool);
+		tsk::async( boost::move( t2), 1, pool);
+		tsk::async( boost::move( t3), 0, pool);
+		b.wait();
+		pool.shutdown();
+		BOOST_CHECK_EQUAL( buffer[0], 55);
+		BOOST_CHECK_EQUAL( buffer[1], 0);
+		BOOST_CHECK_EQUAL( buffer.size(), std::size_t( 2) );
+	}
+
+	// check smart scheduling
+	void test_case_25()
+	{
+		typedef tsk::static_pool<
+			tsk::unbounded_channel< tsk::smart< int, std::less< int >, tsk::replace_oldest, tsk::take_oldest > >
+		> pool_type;
+		BOOST_CHECK( tsk::has_attribute< pool_type >::value);
+		typedef boost::is_same< tsk::attribute_type< pool_type >::type, int > type;
+		BOOST_CHECK( type::value);
+		pool_type pool( tsk::poolsize( 1) );
+		boost::barrier b( 2);
+		std::vector< int > buffer;
+		tsk::task< void > t1( barrier_fn, boost::ref( b) );
+		tsk::task< void > t2(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			10);
+		tsk::task< void > t3(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			0);
+		tsk::task< void > t4(
+			buffer_fibonacci_fn,
+			boost::ref( buffer),
+			1);
+		pool.submit( boost::move( t1), 0);
+		tsk::async( boost::move( t2), 2, pool);
+		tsk::async( boost::move( t3), 1, pool);
+		tsk::async( boost::move( t4), 2, pool);
+		b.wait();
+		pool.shutdown();
+		BOOST_CHECK_EQUAL( buffer[0], 0);
+		BOOST_CHECK_EQUAL( buffer[1], 1);
+		BOOST_CHECK_EQUAL( buffer.size(), std::size_t( 2) );
+	}
+};
+
+boost::unit_test::test_suite * init_unit_test_suite( int, char* [])
+{
+	boost::unit_test::test_suite * test( BOOST_TEST_SUITE("Boost.Task: test suite") );
+
+	boost::shared_ptr< test_unbounded_pool > instance( new test_unbounded_pool() );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_1, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_2, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_3, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_4, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_5, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_6, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_7, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_8, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_9, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_10, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_11, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_12, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_13, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_14, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_15, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_16, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_17, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_18, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_19, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_20, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_21, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_22, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_23, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_24, instance) );
+	test->add( BOOST_CLASS_TEST_CASE( & test_unbounded_pool::test_case_25, instance) );
+
+	return test;
+}
